{
  "Caching formula and fetcher results": {
    "Formula cache {: #formula}": "Before Coda executes your [Pack formula][formulas], it first checks a cache of previous formula results. If a matching entry is found, it is returned instead of re-running your code. When a cached result is returned, the Pack Maker Tools logs entry will end with **returned a prior result from the cache** and the **Cache hit** field will be set to **true**.\n\n<img src=\"../../../images/cache_formula_logs.png\" srcset=\"../../../images/cache_formula_logs_2x.png 2x\" class=\"screenshot\" alt=\"Cached formula in the logs\">\n\nFormula result caching is enabled by default for all Pack formulas. You can adjust the caching behavior by setting the [`cacheTtlSecs`][formulas_cacheTtlSecs] field on the formula definition, which specifies for how many seconds the result should be cached. To disable caching for a formula set that value to zero.\n\nThe following types of formulas are never cached:\n\n['[Action formulas][actions]', '[Sync formulas][sync_formula]', 'Formulas that result in an error']",
    "Fetcher cache {: #fetcher}": {
      "Force caching for non-`GET` requests {:#forcecache}": "By default non-`GET` requests (`POST`, etc) cannot be cached, since they are usually used to change state on the server. However there are times when these HTTP methods are used in a read-only way, such as submitting a GraphQL request, when caching would be desirable. In those cases you can enable caching of non-`GET` requests using the field `forceCache`.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://api.example.com\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(payload),\n  forceCache: true,\n  cacheTtlSecs: 300,\n});\n```",
      "In-progress request de-duplication": "If multiple, identical `GET` requests are all made at the same time they will be de-duplicated into a single request. This means that only the first request will actually be sent to the server, and the result will be returned for all of the requests. This de-duplication happens even when caching is disabled, and it won't show up in the logs as a cached response.\n\nThis is not an issue for most APIs, but if you are using a `GET` request to return a random or unique value then you could end up with duplicates. To bypass this de-duplication behavior simply add a unique query parameter to your URL for each request. The value in `context.invocationToken` is unique for each Pack execution and can be used for this purpose."
    },
    "Disable caching": "To fully disable caching for a formula you must ensure you set the `cacheTtlSecs` to zero on the formula and on any fetcher requests used by the formula.\n\n```\npack.addFormula({\n  // ...\n  cacheTtlSecs: 0, // Disable formula caching.\n  execute: async function ([], context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://example.com\",\n      cacheTtlSecs: 0, // Disable fetcher caching.\n    });\n    // ...\n  },\n});\n```",
    "Duration and scope": "The default time to live (TTL) for both caches is 5 minutes, and the maximum you can set is 24 hours. Both of these values are subject to change without warning. Setting a `cacheTtlSecs` value larger than the maximum will not result in an error, but will reduced down to the maximum. This TTL is best effort, and for a variety of reasons a cache entry may be evicted earlier.\n\nBoth caches are scoped to the unique inputs (formula name and parameters, or fetcher URL and headers) as well as the connected account (if [authentication][authentication] is used). The formula cache is additionally scoped to the document it's used in and the specific version of the Pack. Building or releasing a new version of your Pack will effectively invalidate the formula cache, ensuring you get fresh results using your new code.",
    "Recommendations": "How long to set the caching time depends a lot on the specific data and how it's being used. However there are some general guidelines you can use:\n\n['**Random data** - Formulas that return random data (random quote, etc) should fully disable caching. This ensures that each execution provides a unique value.', '**User data** - Formulas that return user data from another service (events in a calendar, etc) should cache the results for a few minutes. Some caching is useful for performance reasons, but too much can lead to user confusion, if for instance they update their data in the service and expect to see that change in the doc.', '**Stable data** - Formulas that return stable data (population of a country, etc) should cache the results for many hours. This data is very unlikely to change within a given time period, and maximizing the use of caching ensure the best performance for users.']\n\n[formulas]: ../blocks/formulas.md\n[formulas_recalculation]: ../blocks/formulas.md#recalculation\n[formulas_cacheTtlSecs]: ../../reference/sdk/interfaces/core.PackFormulaDef.md#cachettlsecs\n[fetcher_cacheTtlSecs]: ../../reference/sdk/interfaces/core.FetchRequest.md#cacheTtlSecs\n[actions]: ../blocks/actions.md\n[sync_formula]: ../blocks/sync-tables/index.md#formula\n[authentication]: ../basics/authentication/index.md\n[fetcher]: ../basics/fetcher.md\n\n[]\n\ndescription: Embed external content using Packs and optimize your app for embedding."
  },
  "Embedding content": {
    "Adding support": "If you want to add embed support to your own application follow the instructions in the [Iframely documentation][iframely_docs]. This is most commonly done by adding support for the [oEmbed specification][oembed], which is used by many platforms. Once that is complete, [submit your application][iframely_submit] to Iframely to have it added to their registry.\n\nThe iframe containing the embed is sandboxed by default has limited permissions (for example, it can't present content full screen). If you need access to additional iframe sandbox permissions please [contact support][support].\n\n!!! note \"User embeds\"\nUsers can [embed content in their docs][help_center_embed] directly, without Packs, using the `/embed` slash command or the `=Embed()` formula. Even if you aren't planning to build a Pack you may want to support embeds for your users that manually embed the content in their docs.",
    "Generating an embed": {
      "Forcing an embed": "You may still be able to embed URLs that aren't supported by Iframely by using the `force` option.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  schema: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Embed,\n    force: true,\n  },\n  execute: async function ([], context) {\n    // TODO: Build or fetch embed URL.\n    return embedUrl;\n  },\n});\n```\n\nA forced embed is initially displayed in a disabled state:\n\n<img src=\"../../../images/embed_force_enable.png\" srcset=\"../../../images/embed_force_enable_2x.png 2x\" class=\"screenshot\" alt=\"Force embeds are initially disabled\">\n\nOnce a user clicks the embed they are prompted to approve embedding the URL:\n\n<img src=\"../../../images/embed_force_approve.png\" srcset=\"../../../images/embed_force_approve_2x.png 2x\" class=\"screenshot\" alt=\"Force embeds must be approved\">\n\n!!! info \"Embed approval scope\"\nThis approval is once per-domain, per-user. This means that each user in the document will need to approve the embed in order to see the content, but that approval works across all embeds in that doc or others.\n\nOnce approved, Coda attempts to load the URL int an `<iframe>` element with [sandboxing applied][mdn_iframe_sandbox]. The URL must be secure (begin with `https://`) and must not prevent being loaded in an iframe (via the [`X-Frame-Options`][mdn_xfo] or [`Content-Security-Policy`][mdn_csp] headers).\n\n[help_center_embed]: https://help.coda.io/en/articles/1211364-embedding-content-in-your-doc\n[iframely]: https://iframely.com/\n[iframely_check]: https://iframely.com/embed\n[iframely_docs]: https://iframely.com/docs/webmasters\n[oembed]: https://oembed.com/\n[iframely_submit]: https://iframely.com/qa/request\n[mdn_iframe_sandbox]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox\n[mdn_xfo]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n[mdn_csp]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n[support]: ../../support/index.md\n\n[]\n\nnav: Error handling\ndescription: Handle exceptions and display error messages to users.\n\n[]"
      },
      "pack": {
        "name": "Jina.ai Reader",
        "description": "Fetch content from Jina.ai Reader API into Coda.",
        "version": "1.0.0",
        "author": "Your Name",
        "formulas": [
          {
            "name": "FetchContent",
            "description": "Fetch content from Jina.ai Reader API.",
            "parameters": [
              {
                "type": "string",
                "name": "query",
                "description": "The query to search for content."
              }
            ],
            "resultType": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": { "type": "string" },
                "title": { "type": "string" },
                "content": { "type": "string" },
                "url": { "type": "string", "codaType": "url" }
              },
              "displayProperty": "title",
              "idProperty": "id",
              "featuredProperties": ["title", "url"]
            }
          }
        ],
        "networkDomains": ["jina.ai"],
        "authentication": {
          "type": "headerBearerToken",
          "instructionsUrl": "https://jina.ai/docs/authentication"
        }
      }
    }
  },
  "Handling errors": {
    "Fetcher errors": "When the fetcher receives a response from the API indicating there was a problem it throws an exception. You can detect and handle these exceptions if there are known error cases, or if left unhandled a generic error message will be shown to the user. More information about these errors can be found in the [Fetching remote data guide][fetcher].",
    "User-visible errors": "By default an unhandled exception in your code will be presented to the user as a generic error message.\n\n```\npack.addFormula({\n  name: \"CreateOrder\",\n  description: \"Create a new order.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"sku\",\n      description: \"The SKU of the item to order.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"The number of items to order.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([sku, quantity], context) {\n    if (quantity < 0) {\n      throw new Error(\"The quantity must be greater than zero.\");\n    }\n    // ...\n  },\n});\n```\n\n<img src=\"../../../images/errors_generic.png\" srcset=\"../../../images/errors_generic_2x.png 2x\" class=\"screenshot\" alt=\"Generic error message.\">\n\nWhen you want to provide a more specific error message, throw a `UserVisibleError` exception instead.\n\n```\npack.addFormula({\n  // ...\n  execute: async function ([sku, quantity], context) {\n    if (quantity < 0) {\n      throw new coda.UserVisibleError(\"The quantity must be greater than zero.\");\n    }\n    // ...\n  },\n});\n```\n\n<img src=\"../../../images/errors_user_visible.png\" srcset=\"../../../images/errors_user_visible_2x.png 2x\" class=\"screenshot\" alt=\"User-visible error message.\">\n\nWhen the error originates from an API or library, you can catch the error and throw a `UserVisibleError` one instead.\n\n```\npack.addFormula({\n  // ...\n  execute: async function ([sku, quantity], context) {\n    let response;\n    try {\n      response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.example.com/orders\",\n        form: { sku: sku, quantity: String(quantity) },\n      });\n    } catch (error) {\n      // If the error came from the API (400 status code).\n      if (error.statusCode === 400) {\n        // Use the message field in the response, or fallback to generic one.\n        let message = error.body?.message ?? \"Invalid parameters.\";\n        throw new coda.UserVisibleError(message);\n      }\n      // If the error wasn't from the API, just re-throw it.\n      throw error;\n    }\n    // ...\n  },\n});\n```",
    "Common error handling function": "Some Packs include multiple formulas that call the same API, and it can be useful to share error handling logic between them. This can be done by using the `onError` field of the formula to specify a common error handling function. If running the `execute` function results in an error, it will first be sent to the `onError` function before being returned to the doc.\n\n```\npack.addFormula({\n  name: \"CreateOrder\",\n  // ...\n  onError: handleError,\n  execute: async function ([sku, quantity], context) {\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://api.example.com/orders\",\n      form: { sku: sku, quantity: String(quantity) },\n    });\n    return response.body.id;\n  },\n});\n\npack.addFormula({\n  name: \"CreateInvoice\",\n  // ...\n  onError: handleError,\n  execute: async function ([orderId], context) {\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://api.example.com/invoice\",\n      form: { orderId: orderId },\n    });\n    return response.body.id;\n  },\n});\n\nfunction handleError(error) {\n  // If the error came from the API and indicates a problem with the request.\n  if (error.statusCode === 400) {\n    // Use the message field in the response, or fallback to generic one.\n    let message = error.body?.message ?? \"Invalid parameters.\";\n    throw new coda.UserVisibleError(message);\n  }\n  // If the error wasn't from the API, just re-throw it.\n  throw error;\n}\n```\n\n[fetcher]: ../basics/fetcher.md#errors\n\n[]\n\nnav: Images & files\ndescription: Use images and files as parameters and return types.\n\n[]"
  },
  "Working with images and files": {
    "Parameters and result types": "Formulas can accept an image as a parameter using the parameter type `Image`, which is then passed to the `execute` function as a URL. Likewise, formulas can return images as URLs, using the hint type `ImageReference` or `ImageAttachment`. When using an image reference the image is always loaded from the source URL, while for attachments Coda copies the image from the source URL into the document and shows that local copy.\n\nImage attachments should be used in most cases. An image reference may make more sense if you expect the image to be updated often and want to ensure the doc is always using the latest copy, or when contractually obligated to hotlink to the image.\n\nFiles work very much the same as images, with the `File` parameter type and for input and the `Attachment` value hint for output.\n\nSee the [Parameters][parameters_images] and [Data types][data_types_images] guides for more information.",
    "Expiring images {: #expiring}": "Some APIs provide access to images using URLs that expire after a short amount of time. In these cases, return the URL with the hint type `ImageAttachment`, which instructs Coda to ingest the image and store a copy in the document.\n\nIngesting an image can take a few seconds, and Coda will show a paperclip icon for the image until it is complete. This delay can be more noticeable for sync tables, since they can return many images at once and they are ingested sequentially.\n\n!!! bug\nImage attachments currently only work correctly within a sync table. When used outside of a sync table they behave like image references and load the image from the source URL.",
    "Private images {: #private}": "Some APIs return links to private images, that require authentication credentials to be provided in order to access their content. Before Coda can ingest these images you must first copy them to a location that is publicly accessible. The Pack SDK provides a utility for this, known as [`TemporaryBlobStorage`][reference_temporaryblobstorage]. It is made available at `context.temporaryBlobStorage`, and the `storeUrl()` method fetches the image (with authentication credentials), stores the data in a temporary location, and returns the resulting URL. This temporary URL can then be returned as an `ImageAttachment` as [discussed above](#expiring).\n\n```\nlet privateImageUrl = response.body.imageUrl;\nlet temporaryImageUrl =\n  await context.temporaryBlobStorage.storeUrl(privateImageUrl);\nreturn temporaryImageUrl;\n```",
    "Raw image data": "Some APIs return the raw image data directly in the response object, typically as a base64-encoded string. Additionally, JavaScript libraries used to generate or manipulate images may also return raw image data.\n\nSimilar to [private images](#private) discussed above, you can use `TemporaryBlobStorage` to store the image data in a temporary location and get a URL which Coda can then ingest. The `storeBlob()` method accepts a [Node.js `Buffer`][buffer] containing the data and the content type of the image.\n\n```\nlet imageBase64 = response.body.image;\nlet buffer = Buffer.from(imageBase64, \"base64\");\nlet temporaryImageUrl =\n  await context.temporaryBlobStorage.storeBlob(buffer, \"image/png\");\nreturn temporaryImageUrl;\n```",
    "SVG images": {
      "Dark mode": "You may want to adjust the colors of your generated SVG based on whether the user has dark mode enabled. To accomplish this:\n\n['Assign an `id` to the root element of your SVG, using the value provided in `coda.SvgConstants.DarkModeFragmentId`.', 'Create a CSS style rule for that element and the [CSS `:target` selector][mdn_target], that applies the dark mode styling changes.', 'Return the SVG using the `coda.SvgConstants.DataUrlPrefixWithDarkModeSupport` prefix.']\n\n```\nlet darkModeId = coda.SvgConstants.DarkModeFragmentId;\nlet svg = `\n  <svg ...>\n    <g id=\"${darkModeId}\">\n      ...\n    </g>\n    <style>\n      #${darkModeId}:target { ... }\n    </style>\n  </svg>\n`.trim();\nlet encoded = Buffer.from(svg).toString(\"base64\");\nreturn coda.SvgConstants.DataUrlPrefixWithDarkModeSupport + encoded;\n```\n\n[samples]: ../../samples/topic/image.md\n[parameters_images]: ../basics/parameters/index.md#images\n[data_types_images]: ../basics/data-types.md#images\n[reference_temporaryblobstorage]: ../../reference/sdk/interfaces/core.TemporaryBlobStorage.md\n[buffer]: https://nodejs.org/api/buffer.html#buffer\n[mdn_data_urls]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n[mdn_svg]: https://developer.mozilla.org/en-US/docs/Web/SVG\n[pack_latex]: https://coda.io/packs/latex-1058\n[mdn_target]: https://developer.mozilla.org/en-US/docs/Web/CSS/:target\n\n[]\n\nnav: Schemas\ndescription: Design schemas to represent rich data, for use in formulas and sync tables.\n\n[]"
    }
  },
  "Structuring data with schemas": {
    "Using schemas": {
      "Object return types": "Formulas that return an `Object` value must specify an object schema that defines the properties of the object. It is specified in the `schema` field of the formula definition.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: MySchema,\n  // ...\n});\n```\n\nSee the [Data types guide][data_types_objects] for more information on object values.",
      "Array return types": "Formulas that return an `Array` value must specify a schema that defines the items in the array. It is specified in the `items` field of the formula definition.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Array,\n  items: MySchema,\n  // ...\n});\n```"
    },
    "Creating schemas": "Schemas are created using the [`makeSchema`][makeSchema] method.\n\n```\nlet NumberSchema = coda.makeSchema({\n  type: coda.ValueType.Number,\n});\n```\n\nWhen defining a schema for the `Object` value type, use the more specific [`makeObjectSchema`][makeObjectSchema] method. The `type` field can be omitted, since the type must be `Object`.\n\n```\nlet MySchema = coda.makeObjectSchema({\n  properties: {\n    name: {type: coda.ValueType.String},\n  },\n  displayProperty: \"name\",\n});\n```\n\nSchemas can also be declared inline in the formula or sync table where they are used.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.Number,\n  }),\n  // ...\n});\n```\n\n!!! tip\nWe recommend against defining object schemas inline, as they can get quite long and are likely to be reused within the Pack.",
    "Data types": "The primary role of a schema is to define the type of data that will be returned. This is done by specifying a value type and optionally a value hint. The value type corresponds to the JavaScript type that will be returned, and the value hint indicates how Coda should interpret that value. These are set using the `type` and `codaType` field respectively.\n\n```\nlet DateSchema = coda.makeSchema({\n  type: coda.ValueType.String,\n  codaType: coda.ValueHintType.Date,\n});\n```\n\nSee the [Data types guide][data_types] for more information about the supported value types and value hints.",
    "Object schemas {: #object}": {
      "Properties": "The individual properties of the object are defined using the `properties` field of the schema. It contains a set of key value/pairs, where the key is the name of the property and the value is a schema describing the property.\n\n```\nlet PersonSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    born: { type: coda.ValueType.String, codaType: coda.ValueHintType.Date },\n    age: { type: coda.ValueType.Number },\n  },\n  // ...\n});\n```\n\nObject schema properties can themselves contain other object schemas, allowing complex nesting of structured data.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    year: { type: coda.ValueType.Number },\n    director: PersonSchema,\n    actors: {\n      type: coda.ValueType.Array,\n      items: PersonSchema,\n    },\n  },\n  // ...\n});\n```\n\nBy default all properties are considered optional, but you can add `required: true` to the property's schema to indicate that the property is required. This adds some type checking to help ensure that formulas return all the required properties, but it cannot catch all cases.",
      "Property descriptions": "While a good property name may speak for itself, it's often useful to add additional context about what kind of information the property contains. This can be done by adding a `description` field to the property schema:\n\n```\nlet PersonSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      type: coda.ValueType.String,\n      description: \"The full name of the person.\",\n    },\n    born: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n      description: \"The date when the person was born.\",\n    },\n    age: {\n      type: coda.ValueType.Number,\n      description: \"The age of the person, in years.\",\n    },\n  },\n  // ...\n});\n```\n\nThese descriptions are shown shown in various places in the Coda UI.\n\n=== \"Formula editor\"\n\nWhen inspecting the property in the formula editor.\n\n<img src=\"../../../images/schemas_descriptions.png\" srcset=\"../../../images/schemas_descriptions_2x.png 2x\" class=\"screenshot\" alt=\"A schema property description being shown in the formula editor\">\n\n\n=== \"Column description\"\n\nWhen used in sync tables or column formats, schema properties can be broken out into their own columns, and the property's description will be used as the initial value for the column's description. This column description is set once when the column is added to the table, and it can later be edited or removed by the user.\n\n<img src=\"../../../images/schemas_column_descriptions.png\" srcset=\"../../../images/schemas_column_descriptions_2x.png 2x\" class=\"screenshot\" alt=\"A column description being shown in a sync table\">\n\n\n??? tip \"Add descriptions to object properties\"\n\nIf a schema is only used by a single property, or you want to show the description everywhere, then simply add the description to the schema.\n\n```{.ts hl_lines=\"2\"}\nlet PersonSchema = coda.makeObjectSchema({\n  description: \"A person\",\n  // ...\n});\n```\n\nMore commonly however a schema is reused across multiple properties, where the context and meaning of the value are different. In that case you can use [JavaScript's spread syntax][mdn_spread_object] to copy of the schema and add a description.\n\n```{.ts hl_lines=\"6-7 10-11\"}\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    year: { type: coda.ValueType.Number },\n    director: {\n      ...PersonSchema,\n      description: \"The director of the movie.\",\n    },\n    producer: {\n      ...PersonSchema,\n      description: \"The primary producer of the movie.\",\n    },\n  },\n  // ...\n});\n```\n\n",
      "Object mapping": "When a formula or sync table returns an object, only the fields matching the properties defined in the schema are retained, and all others are discarded. The simplest approach is to define a schema where the property names are the same as the fields returned by the API.\n\n```\nlet LocationSchema = coda.makeObjectSchema({\n  properties: {\n    // These names match exactly what the API returns.\n    latDeg: { type: coda.ValueType.Number },\n    longDeg: { type: coda.ValueType.Number },\n  },\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: LocationSchema,\n  execute: async function([], context) {\n    let location = await fetchLocationFromAPI(context);\n    // Return the API response as-is.\n    return location;\n  },\n});\n```\n\nHowever sometimes the names in the API aren't the most user-friendly, and it would be nicer to use a different name in your Pack. To do so, give your property a better name and then use the `fromKey` field of the schema to map it back to the API response.\n\n```\nlet LocationSchema = coda.makeObjectSchema({\n  properties: {\n    // These are custom names, mapped to the API response using \"fromKey\".\n    latitude: { type: coda.ValueType.Number, fromKey: \"latDeg\" },\n    longitude: { type: coda.ValueType.Number, fromKey: \"longDeg\" },\n  },\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: LocationSchema,\n  execute: async function([], context) {\n    let location = await fetchLocationFromAPI(context);\n    // Return the API response as-is.\n    return location;\n  },\n});\n```\n\n??? \"Using `fromKey` with existing schemas\"\nWhen mapping a response field to an existing schema, it isn't clear where to put the `fromKey` field. The best approach is to use the [spread operator (`...`)][mdn_spread_object] to copy the schema and then add on the `fromKey` field.\n\n```ts\nlet PersonSchema = coda.makeObjectSchema({\n  // ...\n});\n\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    director: {\n      ...PersonSchema,\n      fromKey: \"director_info\",\n    },\n    // ...\n  },\n  // ...\n});\n```\n\n\nThe `fromKey` field works for simple renaming, but doesn't handle more complex cases such as pulling up a nested field. A more flexible approach is to rearrange the data from the API before you return it to ensure it matches the schema.\n\n```\nlet LocationSchema = coda.makeObjectSchema({\n  properties: {\n    // These are custom names.\n    latitude: { type: coda.ValueType.Number },\n    longitude: { type: coda.ValueType.Number },\n  },\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: LocationSchema,\n  execute: async function([], context) {\n    let location = await fetchLocationFromAPI(context);\n    // Return a new object that matches the schema.\n    return {\n      latitude: location.latDeg,\n      longitude: location.longDeg,\n    };\n  },\n});\n```",
      "Display value {: #display}": "Object schemas must define what value should be displayed within the chip when it is rendered in the doc. This is done by setting the `displayProperty` field to the name of the property containing the value to display.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    // ...\n  },\n  displayProperty: \"title\",\n  // ...\n});\n```\n\nYou can select any property to use as the display value, although usually a name or title is best. Some APIs may not return a suitable display value, and you may have to create a new property for that purpose.\n\nConsider an API that returns locations with a separate `city` and `state` field. Neither of those alone is a very great display value, but you could combine them together to create one.\n\n```\nlet LocationSchema = coda.makeObjectSchema({\nproperties: {\n    city: { type: coda.ValueType.String },\n    state: { type: coda.ValueType.String },\n    // Add an additional property to use as the display value.\n    display: { type: coda.ValueType.String },\n    // ...\n  },\n  displayProperty: \"display\",\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: LocationSchema,\n  execute: async function([], context) {\n    let location = await fetchLocationFromAPI(context);\n    return {\n      city: location.city,\n      state: location.state,\n      // Populate the display value using data from the API.\n      display: location.city + \", \" + location.state,\n    },\n  },\n});\n```",
      "Property name normalization {: #normalization}": "To ensure compatibility with the Coda Formula Language and consistency across Packs, all property names are normalized to a standard format before they are shown to the user. This process removes all punctuation and whitespace and reformats the name to upper camel case (AKA PascalCase). For example, `fooBar`, `foo_bar`, and `foo bar` will all be normalized to `FooBar`. This normalization happens after your Pack is run, and you should refer to the non-normalized property names throughout your code.\n\nThe normalized name of a property is shown in the formula editor, but it also impacts the display name of that property elsewhere in the doc. In the hover dialog and in sync table columns the normalized name is again converted, this time from upper camel case to space-separated. For example, the normalized property `FooBar` will be displayed as \"Foo Bar\". See the section [Column Names](#column-names) to learn how to explicitly set column names and preserve special characters.",
      "Data attribution {: #attribution}": "The terms of service for some APIs require you to provide visual attribution when you display their data. This can be accommodated in Packs using the `attribution` field of the schema. You can include a mix of text, links, and images which will be displayed when the user hovers over the object's chip.\n\n```\nlet TaskSchema = coda.makeObjectSchema({\n  // ...\n  attribution: [\n    {\n      type: coda.AttributionNodeType.Text,\n      text: \"Provided by Todoist\",\n    },\n    {\n      type: coda.AttributionNodeType.Link,\n      anchorText: \"todoist.com\",\n      anchorUrl: \"https://todoist.com\",\n    },\n    {\n      type: coda.AttributionNodeType.Image,\n      imageUrl: \"https://todoist.com/favicon.ico\",\n      anchorUrl: \"https://todoist.com\",\n    },\n  ],\n});\n```\n\n<img src=\"../../../images/schemas_attribution.png\" srcset=\"../../../images/schemas_attribution_2x.png 2x\" class=\"screenshot\" alt=\"How attribution is displayed on hover\">"
    },
    "Schemas in sync tables": {
      "Row identifier": "Object schemas used in a sync table must specify which property value should be used as a unique identifier for that row. This ID is needed by the syncing logic to ensure that rows are added, updated, and removed correctly. The ID only needs to be unique within that sync table.\n\nSimilar to the [display value](#display-value), this is done by setting the `idProperty` field to the name of the property containing the unique identifier.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    id: { type: coda.ValueType.String },\n    // ...\n  },\n  idProperty: \"id\",\n  // ...\n});\n```",
      "Schema identity": "Sync tables have an `identityName` field which defines the [unique identifier][sync_tables_identity] for that table, and a schema that defines the shape of the data in each row. In some cases you need to set the identity name of the sync table in the schema itself:\n\n['Manually constructing a [reference schema](#references).', 'Returning an object schema in an action formula to [update the sync table row][actions_sync].']\n\nThis can be done by adding an `identity` to your schema and setting its `name` field.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n  identity: {\n    name: \"Movie\",\n  },\n});\n```\n\nAlternatively, you can use the helper function `coda.withIdentity()` to make a copy of the schema with the identity set. This can allow for better reuse of schemas across your Pack.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n});\n\npack.addFormula({\n  name: \"UpdateMovie\",\n  description: \"Update the movie details.\",\n  resultType: coda.ValueType.Object,\n  schema: coda.withIdentity(MovieSchema, \"Movie\"),\n  //...\n});\n```",
      "Featured columns": "By default a sync table will only contain one column, containing a chip with the synced object. When viewing the hover card for the object, users can click the **Add column** button to create a new column from any property. Alternatively, they can manually create new columns and use the formula editor to reference a property of the synced object.\n\nYou can specify additional default columns by setting the `featuredProperties` field of the schema. This field should contain the names of the properties that should be given their own columns when the sync table is created.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    year: { type: coda.ValueType.Number },\n    director: PersonSchema,\n    actors: {\n      type: coda.ValueType.Array,\n      items: PersonSchema,\n    },\n  },\n  // When creating the sync table, automatically add columns for these fields.\n  featuredProperties: [\"director\", \"actors\"],\n  // ...\n});\n```\n\n!!! tip\nSelect a small but meaningful set of featured columns for your sync tables. Too few and users may not know what data is available, and too many could be overwhelming.",
      "Reference schemas {: #references}": "Reference schemas are used by sync tables to create relations between tables. See the [Sync tables guide][sync_tables_references] for more information on how row references work.\n\nThe simplest way to create a reference schema is to use the helper function [`makeReferenceSchemaFromObjectSchema`][makeReferenceSchemaFromObjectSchema]. Simply pass in the full schema and sync table's `identityName` and it will be converted to a reference schema.\n\n```\nlet PersonReferenceSchema =\n    coda.makeReferenceSchemaFromObjectSchema(PersonSchema, \"Person\");\n```\n\nIn some instances you may have to create the reference schema manually however, like when you want a row to be able to reference other rows in the same table. A reference schema is an object schema with the `codaType` field set to `Reference`. It must specify both an `idProperty` and `displayProperty`, and those properties must be marked as `required`. It must also have an `identity` set, with the name matching the `identityName` of the target sync table.\n\n```\nlet PersonReferenceSchema = coda.makeObjectSchema({\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: { type: coda.ValueType.String, required: true },\n    id: { type: coda.ValueType.String, required: true },\n    // Other properties can be omitted.\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  identity: {\n    name: \"Person\",\n  },\n});\n```\n\nYou can then use the reference schema in other sync table schemas in your Pack.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    year: { type: coda.ValueType.Number },\n    director: PersonReferenceSchema,\n    actors: {\n      type: coda.ValueType.Array,\n      items: PersonReferenceSchema,\n    },\n  },\n  // ...\n});\n```\n\nIn your sync formula you only need to populate the fields of the reference object corresponding to the `idProperty` and `displayProperty` fields. If your API only returns the ID of the referenced item, you can set the display value to \"Not found\" or something equivalent, as this value will only be shown when the referenced row hasn't been synced yet.\n\n!!! warning\nReference schemas are only resolved to rows when they are used in a sync table. If used in a formula or column format they will always appear in a broken state, even if the row they are referencing is present.",
      "Column IDs": "In addition to a user-visible name, each column in a sync table has a stable identifier. Although this ID isn't used today, in the future it will enable advanced features like being able to rename a column without impacting existing docs. By default a property's key in the schema will be used as the column ID.\n\nIn most cases this default behavior is sufficient, but in rare cases you may want to set a different ID value for the column. For example, if you generate your schema dynamically to include custom fields returned by an API, you should use the ID of those custom fields instead of their name.\n\nIn these cases you should adjust your `getSchema` function to set the ID manually using the `fixedId` field.\n\n```\nfor (let customField of customFeilds) {\n  properties[customField.name] = {\n    type: coda.ValueType.String,\n    // Use the custom field's ID as the column ID.\n    fixedId: customField.id,\n  }\n}\n```",
      "Column names {: #column-names}": "By default sync table column names are derived from the [normalized name](#normalization) of the corresponding schema property. For example, a property with the key `contact_email` would be normalized to the property name `ContactEmail` which would result in a column named \"Contact email\". This is just the default name for the column however, and users can later rename it in their doc if they so desire.\n\nWhile these automatically derived column names are convenient, they can result in some strange column names when the original property key contains punctuation, special characters, or a mixture of casing. For example, a property key of `iPhone_version` will end up as a column named \"I phone version\".\n\nYou can more accurately control the resulting column name for a property by setting the `displayName` field of the property.\n\n```\nlet DeviceSchema = coda.makeObjectSchema({\n  properties: {\n    iPhone_version: {\n      type: coda.ValueType.String,\n      displayName: \"iPhone version\",\n    },\n    // ...\n  },\n  // ...\n});\n```\n\nThis display name will only be used to set the default column name for that property, and the normalized name will still be shown in other contexts. Changes to the `displayName` will rename existing columns upon their next sync, as long as the user hasn't manually changed the column name."
    },
    "Schemas in cards {: #cards}": {
      "Property labels {: #labels}": "A card's subtitle contains a set of properties, joined with a separator. Unlike other areas of the card where only the property's value is shown, in the subtitle a label is shown as well. By default, the label and value are shown together as `{label}: {value}`.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n  subtitleProperties: [\"director\", \"year\", \"rating\"],\n});\n```\n\n<img src=\"../../../images/schemas_labels_default.png\" srcset=\"../../../images/schemas_labels_default_2x.png 2x\" class=\"screenshot\" alt=\"Default labels for subtitle properties\">\n\nHowever, there are times when the default label isn't a great fit. For instance you may want to put the property name after the value (`10 bugs` instead of `Bugs: 10`) or remove the label completely (`P1` instead of `Priority: P1`).\n\nTo customize the label, when specifying the `subtitleProperties` pass a [`PropertyIdentifierDetails`][PropertyIdentifierDetails] object instead of a string. Set the `property` field to the path of the property (what the string value normally contains) and set the `label` field to the template string to use for the label.\n\nThere are three options for setting the label:\n\n['Pass a string which will be used as an alternative label.', \"Pass a string containing the constant [`PropertyLabelValueTemplate`][PropertyLabelValueTemplate], which acts as a placeholder for where the property's value should be inserted.\", 'Pass an empty string, which will remove the label completely.']\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n  subtitleProperties: [\n    \"director\",\n    // Fully customize the label for the year property.\n    { property: \"year\", label: `Released in ${coda.PropertyLabelValueTemplate}` },\n    // Only show the value of the rating property.\n    { property: \"rating\", label: \"\" },\n  ],\n});\n```\n\n<img src=\"../../../images/schemas_labels_custom.png\" srcset=\"../../../images/schemas_labels_custom_2x.png 2x\" class=\"screenshot\" alt=\"Custom labels for subtitle properties\">",
      "Property placeholders": "When a property used in a card doesn't have a value set the corresponding section of the card is hidden. For example, an empty subtitle property will not render any label or value in the card's subtitle. However there are cases where you may want to show some default or fallback value to the user instead. While these default values could be injected in your formula code, you can simplify the process by specifying a placeholder value in the schema.\n\nTo do so, use a [`PropertyIdentifierDetails`][PropertyIdentifierDetails] object to specify the property to use and set the `placeholder` field to the default / fallback value to display when the property is empty.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n  subtitleProperties: [\n    \"director\",\n    { property: \"year\", placeholder: \"In production\" },\n    { property: \"rating\", placeholder: \"TBD\" },\n  ],\n});\n```\n\n<img src=\"../../../images/schemas_placeholders.png\" srcset=\"../../../images/schemas_placeholders_2x.png 2x\" class=\"screenshot\" alt=\"Placeholders for subtitle properties\">\n\nA property will be considered empty and fallback to the placeholder when it's value is one of the following: `null`, `undefined`, `\"\"`, `[]`, `{}`. The placeholder is only used to render the card, and when using the Coda Formula Language to access the property it will still return the original value. Placeholders are currently only supported on the following fields:\n\n['[`titleProperty`][titleProperty]', '[`subtitleProperties`][subtitleProperties]', '[`snippetProperty`][snippetProperty]']"
    },
    "Property paths": "Object schema fields that expect a property name (`titleProperty`, `snippetProperty`, etc) also accept a path to a property on a nested object. The paths are specified using a subset of the [JSONPath syntax][jsonpath], which at it's simplest just joins the property names with a dot (like `property1.property2`).\n\n!!! warning \"Only supported for card fields\"\nAt the moment property paths can only be used in the object [schema fields used by cards](#cards).\n<!-- TODO(spencer): Remove this warning when support has been added for the other fields. -->\n\nConsider the following schema for a movie:\n\n```\nlet PersonSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    // ...\n  },\n});\n\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    director: PersonSchema,\n    actors: {\n      type: coda.ValueType.Array,\n      items: PersonSchema,\n    },\n    // ...\n  },\n});\n```\n\nThe following property Paths are all valid:\n\n['`director.name` - The name of the director.', '`actors[0].name` - The name of the first actor.', '`actors[*].name` - The names of all of the actors (comma separated).']\n\nIf you need to further customize the value, such as combining the value of multiple properties or doing some other transformation, you'll need to create a new property to hold that value and manually populate it in your `execute` function. See the [Display value](#display) for an example of this.\n\n!!! info \"Set property labels in card subtitle\"\nWhen using property paths to specify a card's subtitle, it's recommended that you manually set the [labels for those properties](#labels). Coda will generate a label based off of the property path, but the result is often not desirable.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  // ...\n  subtitleProperties: [\n    { property: \"director.name\", label: \"Director\" },\n  ],\n});\n```\n\n\n\n\n[samples]: ../../samples/topic/schema.md\n[data_types]: ../basics/data-types.md\n[sync_tables]: ../blocks/sync-tables/index.md\n[makeSchema]: ../../reference/sdk/functions/core.makeSchema.md\n[makeObjectSchema]: ../../reference/sdk/functions/core.makeObjectSchema.md\n[sync_tables_identity]: ../blocks/sync-tables/index.md#identity\n[todoist]: ../../samples/full/todoist.md\n[makeReferenceSchemaFromObjectSchema]: ../../reference/sdk/functions/core.makeReferenceSchemaFromObjectSchema.md\n[sync_tables_references]: ../blocks/sync-tables/index.md#references\n[data_types_objects]: ../basics/data-types.md#objects\n[mdn_spread_object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals\n[actions_sync]: ../blocks/actions.md#sync\n[cards]: ../blocks/cards.md\n[PropertyIdentifierDetails]: ../../reference/sdk/interfaces/core.PropertyIdentifierDetails.md\n[PropertyLabelValueTemplate]: ../../reference/sdk/variables/core.PropertyLabelValueTemplate.md\n[titleProperty]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#titleproperty\n[subtitleProperties]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#subtitleproperties\n[snippetProperty]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#snippetproperty\n[linkProperty]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#linkproperty\n[imageProperty]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#imageproperty\n[jsonpath]: https://goessner.net/articles/JsonPath/index.html\n\n[]\n\nnav: Timezones\ndescription: Work with dates and times across the various timezone contexts in a Pack.\ncSpell:words: Luxon\n\n[]"
  },
  "Timezones in Coda": {
    "Timezone shifting {: #shifting}": "Any date or time values passed into a Pack are shifted from the doc's timezone to UTC. For example, the value \"11/12/1955, 10:04 PM\" in a document with the timezone set to \"America/Los Angeles\" will be passed to a Pack as `1955-11-13T06:04:00.000Z`. While this accurately represents the exact same moment in time, you'll notice that the day and hour values have changed due to the change in timezone.\n\n!!! info\nTimezone shifting of parameters happens even for date-only (ex: `11/12/1955`) and time-only (`10:04 PM`) values. As per the [Parameters guide][parameters_date], these values are passed to Packs as full `Date` objects.\n\nLikewise when returning a date or time value Coda will shift the value back. When the value represents an exact moment in time (either a number of seconds since the epoch or a full date and time string with a timezone identifier) it will be shifted to that equivalent moment in the document's timezone. However, if the Pack returns a string which represents a relative date or time (it's just a date or time, or has no timezone identifier) it will be assumed that it's already in the timezone of the document and won't be shifted.",
    "Working with timezones {: #working}": {
      "Localized strings": "You can get a string version of a date object localized to the timezone of the document by using the `toLocaleString()` method and the `timeZone` option:\n\n```\nlet formatted = date.toLocaleString(\"en-US\", {\n  timeZone: context.timezone,\n});\n```\n\nThere are also equivalent `getLocaleDateString()` and `getLocaleTimeString()` methods for getting just the date or time component respectively.",
      "Localized parts": "The JavaScript class `Intl.DateTimeFormat` allows for formatting a date using a [variety of options][DateTimeFormat_parameters]. Instead of formatting a date into a single string, it also has the ability to format it into a set of named parts. This allows you to more easily extract various portions of the date or time, within the document's timezone.\n\n```\nlet formatter = new Intl.DateTimeFormat(\"en\", {\n  timeZone: context.timezone, // Use the doc's timezone (important!)\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\",\n});\n\n// Format the date into individual parts.\nlet parts = formatter.formatToParts(date);\n\n// Find the day, month, and year parts.\nlet day = parts.find(part => part.type === \"day\").value;\nlet month = parts.find(part => part.type === \"month\").value;\nlet year = parts.find(part => part.type === \"year\").value;\n```",
      "Libraries": "If you are building a Pack using the CLI you may want to consider utilizing more robust date libraries. The JavaScript community has a number of them, with some of the most popular being [Moment.js][moment], [Luxon][luxon], [Day.js][dayjs], and [date-fns][date_fns]. In addition to allowing you to work across timezones, they also often include helper functions and utilities that make it easier to do common tasks.\n\n[wikipedia_utc]: https://en.wikipedia.org/wiki/Coordinated_Universal_Time\n[wikipedia_tz]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n[moment]: https://momentjs.com/\n[luxon]: https://moment.github.io/luxon/#/\n[dayjs]: https://day.js.org/\n[date_fns]: https://date-fns.org/\n[DateTimeFormat_parameters]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#parameters\n[luxon_math]: https://moment.github.io/luxon/#/math?id=calendar-math-vs-time-math\n[parameters_date]: ../basics/parameters/index.md#dates\n[data_types_date]: ../basics/data_types.md#dates\n[data_types_duration]: ../basics/data_types.md#durations\n[ExecutionContext_timezone]: ../../reference/sdk/interfaces/core.ExecutionContext.md#timezone\n\n[]\n\nnav: AWS\ndescription: Configure authentication for an Amazon Web Services (AWS) API.\n\n[]"
    }
  },
  "Authenticating using Amazon Web Services": {
    "Access key": "The simplest method of authentication requires that the Coda user provides an access key and secret associated with an AWS user. Coda will use these values to sign outgoing requests. Simply set the authentication type to [`AWSAccessKey`][sdk_awsaccesskey] and specify the AWS service you are connecting to.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  service: \"s3\",\n});\n```\n\nWhen authenticating, the user will be prompted to enter their access key and secret.\n\n<img src=\"../../../../images/auth_aws_access_key.png\" srcset=\"../../../../images/auth_aws_access_key_2x.png 2x\" class=\"screenshot\" alt=\"Prompting the user for their access key and secret\">\n\nYou can learn more about how to generate access keys in the [AWS documentation][awsdocs_accesskey].\n\n[View Sample Code][sample_aws]{ .md-button }",
    "Assume role": {
      "Trust policy": "In addition to supplying the role and external ID, the user authenticating the Pack must also create a trust relationship between Coda's AWS account and their role. This is done by setting a trust policy on the role, associating the role with the account and an external ID.\n\n```\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"GrantCodaPackAssumeRole\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": [\n          \"arn:aws:iam::029208794193:root\"\n        ]\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"sts:ExternalId\": \"<INSERT_SECRET_VALUE_HERE>\"\n        }\n      }\n    }\n  ]\n}\n```\n\nCoda's AWS account has the ID `arn:aws:iam::029208794193:root`, and this is same for all Packs. To ensure that other Packs can't access the role, users must generate an external ID (usually a UUID) to act as a shared secret. While AWS doesn't strictly require an external ID to use the `AssumeRole` flow, it is recommended for cross-account access scenarios like this and Coda enforces it as a best practice.",
      "Running locally": "If you are developing your Pack locally using the CLI, when you run your Pack using `coda execute` it won't be running under Coda's AWS account. Instead you'll need to create your own AWS user and setup your local environment to use it.\n\nFirst update your policy to include the ID of the user you created.\n\n```\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"GrantCodaPackAssumeRole\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": [\n          \"arn:aws:iam::029208794193:root\",\n          \"<ARN_OF_USER>\"\n        ]\n      },\n      // ...\n    }\n  ]\n}\n```\n\nThen generate an access key and secret for the user, and pass these using the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` respectively.\n\n```\nAWS_ACCESS_KEY_ID=\"<ACCESS_KEY>\" AWS_SECRET_ACCESS_KEY=\"<SECRET>\" \\\nnpx coda execute pack.ts <FormulaName>\n```\n\nYou can alternatively use the AWS CLI to manage these credentials for you.\n\n[awsdocs_sv4]: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html\n[sdk_awsaccesskey]: ../../../reference/sdk/enums/core.AuthenticationType.md#awsaccesskey\n[awsdocs_accesskey]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html\n[sample_aws]: ../../../samples/topic/authentication.md#aws-signature-version-4\n[awsdocs_assumerole]: https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html\n[sdk_awsassumerole]: ../../../reference/sdk/enums/core.AuthenticationType.md#awsassumerole\n[awsdocs_createrole]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user.html\n\n[]\n\nnav: Authentication\ndescription: Configure your Pack to request credentials from the user and pass them along with your fetcher requests.\n\n[]"
    }
  },
  "Authenticating with other services": {
    "Using a Pack with authentication": {
      "Connecting an account": "The first time a user adds a building block that requires authentication they will be shown a **Connect an account** button. Upon clicking it the user will be launched into a sign-in flow, which varies depending on the type of authentication used and the service the user is connecting to.\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of authenticating with a Pack.\" class=\"screenshot\"><source src=\"../../../images/auth_sign_in.mp4\" type=\"video/mp4\"></source></video>\n\nUsers can sign in to additional accounts and change their sharing settings from the **Settings** tab of the Pack's side panel. Accounts can be reused across docs, and  users can manage all of their connected accounts on the [Account settings][account_settings] page.",
      "Selecting an account": "In the formula editor the account is shown as the first parameter to the formula, and in the other dialogs the account to use is displayed as a dropdown list.\n\n=== \"In the formula editor\"\n<img src=\"../../../images/auth_formula.png\" srcset=\"../../../images/auth_formula_2x.png 2x\" class=\"screenshot\" alt=\"Account selection in the formula editor\">\n=== \"In the action builder\"\n<img src=\"../../../images/auth_action.png\" srcset=\"../../../images/auth_action_2x.png 2x\" class=\"screenshot\" alt=\"Account selection in the action builder\">\n=== \"In the column format settings\"\n<img src=\"../../../images/auth_column_format.png\" srcset=\"../../../images/auth_column_format_2x.png 2x\" class=\"screenshot\" alt=\"Account selection in the column format settings\">\n=== \"In the sync table settings\"\n<img src=\"../../../images/auth_sync_table.png\" srcset=\"../../../images/auth_sync_table_2x.png 2x\" class=\"screenshot\" alt=\"Account selection in the sync table settings\">"
    },
    "Adding authentication to your Pack": {
      "Per-user authentication {: #user}": "User authentication requires that users of the Pack provide their own credentials. This is the most common form of authentication, as it allows the Pack to access the private data of each user. To add per-user authentication use the `setUserAuthentication()` method:\n\n```\npack.setUserAuthentication({\n  // A variety of different authentication types are supported.\n  type: coda.AuthenticationType.HeaderBearerToken,\n  // Additional settings...\n});\n```\n\nThe types of authentication supported, as well as the additional settings, are described in the sections below.",
      "System-wide authentication {: #system}": "System authentication requires the Pack maker to provide a single set of credentials that all users will share. This form of authentication is often used for APIs that require an API key or token, but don't provide access to private data. To add system-wide authentication use the `setSystemAuthentication()` method:\n\n```\npack.setSystemAuthentication({\n  // A variety of different authentication types are supported.\n  type: coda.AuthenticationType.HeaderBearerToken,\n  // Additional settings...\n});\n```\n\nAfter adding the code, build a new version of your Pack and then navigate to the **Settings** tab. There you'll see an **Add system authentication** button you can use to set the credentials.\n\n<img src=\"../../../images/auth_system.png\" srcset=\"../../../images/auth_system_2x.png 2x\" class=\"screenshot\" alt=\"Entering system credentials\">\n\nThe types of authentication supported, as well as the additional settings, are described in the sections below."
    },
    "Authentication types": {
      "Simple tokens": "Many APIs use tokens or keys for authentication. Per-user tokens are typically generated from a settings screen within the application, while API keys are often generated when registering an app in a developer portal. How you pass these tokens varies depending on the API, and Coda provides built-in support for the most common methods:\n\n=== \"Authorization header\"\n\nUse [`HeaderBearerToken`][HeaderBearerToken] authentication for APIs that expect the token to be passed in the `Authorization` header with the prefix `Bearer`. For example:\n\n```\nGET /users/me\nHost: api.example.com\nAuthorization: Bearer <token>\n```\n\nCan be implemented using:\n\n```ts\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n});\n```\n\n[View Sample Code][sample_auth_header]{ .md-button }\n\n\n=== \"Custom header\"\n\nUse [`CustomHeaderToken`][CustomHeaderToken] authentication for APIs that expect the token in a custom header, with an optional prefix. For example:\n\n```\nGET /users/me\nHost: api.example.com\nX-API-Key: <token>\n```\n\nCan be implemented using:\n\n```ts\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-API-Key\",\n});\n```\n\n[View Sample Code][sample_custom_header]{ .md-button }\n\n\n=== \"Multiple headers\"\n\nUse [`MultiHeaderToken`][MultiHeaderToken] authentication for APIs that expect multiple tokens in HTTP headers. For example:\n\n```\nGET /users/me\nHost: api.example.com\nX-API-Key: <token>\nX-API-Secret: <secret>\n```\n\nCan be implemented using:\n\n```ts\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiHeaderToken,\n  headers: [\n    { name: \"X-API-Key\", description: \"The key.\" },\n    { name: \"X-API-Secret\", description: \"The secret.\" },\n  ],\n});\n```\n\n[View Sample Code][sample_multiple_headers]{ .md-button }\n\n\n=== \"Query parameter\"\n\nUse [`QueryParamToken`][QueryParamToken] authentication for APIs that expect the token in a URL query parameter. For example:\n\n```\nGET /users/me?key=<token>\nHost: api.example.com\n```\n\nCan be implemented using:\n\n```ts\npack.setUserAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"key\",\n});\n```\n\n[View Sample Code][sample_query_param]{ .md-button }\n\n\n=== \"Multiple query parameters\"\n\nUse [`MultiQueryParamToken`][MultiQueryParamToken] authentication for APIs that expect multiple tokens in URL query parameters. For example:\n\n```\nGET /users/me?key=<token>&secret=<secret>\nHost: api.example.com\n```\n\nCan be implemented using:\n\n```ts\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiQueryParamToken,\n  params: [\n    { name: \"key\", description: \"The key.\" },\n    { name: \"secret\", description: \"The secret.\" },\n  ],\n});\n```\n\n[View Sample Code][sample_multiple_query_params]{ .md-button }\n\n\n[]\n\nWhen using per-user authentication, the user will be prompted to enter their token when connecting their account.\n\n<img src=\"../../../images/auth_token.png\" srcset=\"../../../images/auth_token_2x.png 2x\" class=\"screenshot\" alt=\"Users entering an auth token\">\n\n!!! tip \"Set an instructions URL\"\nIt may not be obvious to users where they can find their API token. You can set the `instructionsUrl` field of the authentication configuration to a relevant help center article, or in some cases directly to the screen within the application that lists the API token. Coda will link to this URL in the dialog.\n```ts\npack.setUserAuthentication({\ntype: coda.AuthenticationType.HeaderBearerToken,\ninstructionsUrl: \"https://help.example.com/where-is-my-api-token\",\n});\n```",
      "Custom tokens {: #custom-tokens}": "Some APIs require a combination of tokens to be used, or for them to be passed in the request body or URL. In these cases you can use the [`Custom`][Custom] authentication type.\n\n!!! warning \"Approval required\"\nIn order to use `Custom` authentication in your Pack must get approval from Coda. [Contact support][support_network_domain] to request approval.\n\nConsider this example, where a key is passed in the URL and an additional token is passed in the request body:\n\n```\nPOST /api/<key>/users\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"token\": \"<token>\",\n  \"name\": \"Art Vandelay\"\n}\n```\n\nThis can be accomplished using a `Custom` authentication configuration like:\n\n```\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.Custom,\n  params: [\n    {name: \"key\", description: \"The API key\"},\n    {name: \"token\", description: \"The account token\"},\n  ],\n});\n```\n\nEach token defined within the `params` array will result in an additional prompt in the authentication dialog:\n\n<img src=\"../../../images/auth_custom.png\" srcset=\"../../../images/auth_custom_2x.png 2x\" class=\"screenshot\" alt=\"Entering tokens for custom authentication\">\n\n{% raw %}\nUnlike with other authentication types where the values are added to your fetch requests automatically, with `Custom` authentication you must manually add these tokens to your request. Wherever you need to inject one of these tokens enter a placeholder value instead, and before your request is sent Coda will replace it with the value of the corresponding token. The placeholder format is `{{<paramName>-<invocationToken>}}`, where `<paramName>` is the name of the token you defined and `<invocateToken>` is the unique ID generated for that execution of your Pack.\n{% endraw %}\n\n{% raw %}\n\n```\npack.addFormula({\n  // ...\n  execute: async function ([], context) {\n    let invocationToken = context.invocationToken;\n    let keyPlaceholder = \"{{key-\" + invocationToken + \"}}\";\n    let tokenPlaceholder = \"{{token-\" + invocationToken + \"}}\";\n    let url = \"https://api.example.com/api/\" + keyPlaceholder + \"/users\";\n    let body = {\n      token: tokenPlaceholder,\n      name: \"Art Vandelay\",\n    };\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n    // ...\n  },\n});\n```\n\n{% endraw %}\n\n[View Sample Code][sample_custom]{ .md-button }",
      "Username and password": "Some APIs authenticate using a username and password, or an equivalent account identifier and secret. The web has long supported this through the [\"Basic\" authorization scheme][wikipedia_basic_auth], where the username and password are encoded and passed in the `Authorization` header.\n\n```\nGET /users/me\nHost: api.example.com\nAuthorization: Basic <base64 encoded username & password>\n```\n\nYou can support this by using [`WebBasic`][WebBasic] authentication in your Pack:\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.WebBasic,\n});\n```\n\n<img src=\"../../../images/auth_basic.png\" srcset=\"../../../images/auth_basic_2x.png 2x\" class=\"screenshot\" alt=\"Users entering their username and password\">\n\n[View Sample Code][sample_web_basic]{ .md-button }\n\n!!! tip \"Customize the dialog\"\nSometimes Basic authentication is used for other types of identifiers and secrets, and the terms \"Username\" and \"Password\" in the dialog can be misleading. You can customize the dialog using the `uxOptions` field of the authentication configuration.\n```ts\npack.setUserAuthentication({\ntype: coda.AuthenticationType.WebBasic,\nuxConfig: {\nplaceholderUsername: \"Account ID\",\nplaceholderPassword: \"Secret Token\",\n},\n});\n```",
      "Token exchange": "Some APIs use short-lived tokens which must be obtained through an credential exchange or approval process. The industry-wide standard for this is OAuth 2.0, which is supported in the Pack SDK. You can read more about it in the [OAuth guide][oauth_guide]. Other forms of token exchange are not currently supported.",
      "Coda API token": "Packs that connect to the Coda API should use [`CodaApiHeaderBearerToken`][CodaApiHeaderBearerToken] authentication, which works much like `HeaderBearerToken` but is optimized for the Coda API. It allows the user to easily create new Coda API tokens directly from the sign-in flow, passing them in the `Authorization` header of outgoing requests. For example:\n\n```\nGET /apis/v1/whoami\nHost: coda.io\nAuthorization: Bearer <token>\n```\n\nCan be implemented using:\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CodaApiHeaderBearerToken,\n});\n```\n\nEnabling the option `shouldAutoAuthSetup: true` further simplifies the sign-in experience, automatically creating the Coda API token with default settings.\n\n[View Sample Code][sample_coda_api]{ .md-button }",
      "AWS Signature Version 4": "Amazon Web Services (AWS) use a proprietary authentication scheme, and Coda provides built-in support for it. You can read more about it in the [AWS authentication guide][aws_guide]."
    },
    "Requiring authentication": "If a Pack includes any form of user authentication then by default all of the building blocks within that Pack are assumed to require a connected account. You can set the `connectionRequirement` property on individual formulas or sync tables to make an account optional or not used.\n\n```\npack.setUserAuthentication({\n  // ...\n});\n\npack.addFormula({\n  name: \"NeedsAuthFormula\",\n  // ...\n});\n\npack.addFormula({\n  name: \"NoAuthNeededFormula\",\n  // ...\n  connectionRequirement: coda.ConnectionRequirement.None,\n});\n```\n\nAlternatively, you can set the `defaultConnectionRequirement` field of the authentication configuration to specify a different default, and then opt-in formulas or sync tables as needed.\n\n```\npack.setUserAuthentication({\n  // ...\n  defaultConnectionRequirement: coda.ConnectionRequirement.None,\n});\n\npack.addFormula({\n  name: \"NeedsAuthFormula\",\n  // ...\n  connectionRequirement: coda.ConnectionRequirement.Required,\n  // ...\n});\n\npack.addFormula({\n  name: \"NoAuthNeededFormula\",\n  // ...\n});\n```",
    "Setting account names {: #name}": "By default the accounts that users connect to will be given the same name as their Coda account. While this works fine the majority of the time, if they are connecting to a team account or multiple accounts it is not very helpful. Therefore we strongly recommend that you implement a [`getConnectionName`][getConnectionName] function in your authentication configuration to set a more meaningful account name. This is typically done by making a Fetcher request to a user information endpoint in the API and then returning the name of the account.\n\n```\npack.setUserAuthentication({\n  // ...\n  getConnectionName: async function(context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.example.com/users/me\",\n    });\n    return response.body.username;\n  },\n});\n```\n\nThis function is run after the user has entered their credentials, and the credentials are automatically applied to the Fetcher request.\n\n[View Sample Code][sample_connection_name]{ .md-button }\n\n!!! tip \"Use detailed account names\"\nIf your service allows users to [connect to multiple endpoints](#endpoints), we recommend that you include the endpoint name as well. For example, a pattern like \"User Name (Endpoint Name)\".",
    "Account-specific endpoints {: #endpoints}": {
      "Entering manually": "To require the user to enter the endpoint URL, set the `requiresEndpointUrl` field to `true`. If you are expecting a subdomain, for additional validation set the `endpointDomain` field to the root domain that all subdomains share.\n\n```\npack.setUserAuthentication({\n  // ...\n  requiresEndpointUrl: true,\n  endpointDomain: \"example.com\",\n});\n```\n\nWhen the user connects to their account they will now also be asked to provide the endpoint URL for their account.\n\n<img src=\"../../../images/auth_endpoint.png\" srcset=\"../../../images/auth_endpoint_2x.png 2x\" class=\"screenshot\" alt=\"Setting the endpoint URL\">\n\n[View Sample Code][sample_manual_endpoint]{ .md-button }\n\n!!! warning \"Not compatible with OAuth2\"\nPacks that use OAuth2 authentication don't support a manual prompt for the endpoint URL. They should instead use one of the alternate options listed below.",
      "Extracting from token exchange": "Some APIs that use OAuth2 authentication return the endpoint URL during the token exchange, as a custom property within the JSON body:\n\n```\n{\n  \"access_token\": \"...\",\n  \"token_type\": \"bearer\",\n  \"site_url\": \"https://vandelay.example.com\"\n}\n```\n\nYou can automatically extract this value and use it as the endpoint URL by setting the `endpointKey` field of the authentication configuration.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // ...\n  endpointKey: \"site_url\",\n});\n```\n\n[View Sample Code][sample_automatic_endpoint]{ .md-button }",
      "Prompting for user selection {: #setendpoint}": "If the service allows the same user account to access multiple endpoints, and those endpoints can be determined with an API call, then you can prompt the user to select the endpoint they wish to connect to. This is accomplished using a `postSetup` step of the type `SetEndpoint`.\n\n```\npack.setUserAuthentication({\n  // After approving access, the user should select which instance they want to\n  // connect to.\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: \"SelectEndpoint\",\n    description: \"Select the site to connect to:\",\n    // Generate the list of endpoint options.\n    getOptions: async function (context) {\n      // Make a request to the API to retrieve the sites they can access.\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.example.com/my/sites\",\n      });\n      let sites = response.body.sites;\n      return sites.map(site => {\n        return { display: site.name, value: site.url };\n      });\n    },\n  }],\n});\n```\n\nThe step's `getOptions` works like [dynamic autocomplete][autocomplete_dynamic], fetching the list of available endpoints and returning a display name and value for each. Note that the returned endpoints must be an object with a `display` and `value` field. Further, the `value` must be a valid URL. After the user enters their credentials they will be prompted to select one of the endpoints in a dialog.\n\n<img src=\"../../../images/auth_setendpoint.png\" srcset=\"../../../images/auth_setendpoint_2x.png 2x\" class=\"screenshot\" alt=\"Selecting from a list of endpoints\">\n\n[View Sample Code][sample_selected_endpoint]{ .md-button }\n\n!!! warning \"Connection name generated twice\"\nWhen using this feature the [`getConnectionName` function](#setting-account-names) is run multiple times: once before the endpoint is selected and again after. Make sure your code works correctly in both cases. Before the endpoint is available you can return a generic name, which will get overwritten later.",
      "Network domains": "Typically a Pack can only make HTTP requests to the [network domains][network_domains] it declares. If the selected endpoint URL is outside of the Pack's declared domains then requests to it will fail. The `endpointDomain` field in the authentication settings can be used to validate manually entered endpoints provided by users, helping to prevent mistakes.\n\nThere are services however where each account is associated with a distinct domain, instead of a sub-domain of a common root domain. This makes it impossible to declare them ahead of time as network domains. In these cases you can omit network domain declaration from your Pack, which will allow it to make requests to the account's endpoint URL (and only that URL) regardless of domain.\n\n[samples]: ../../../samples/topic/authentication.md\n[sample_auth_header]: ../../../samples/topic/authentication.md#authorization-header\n[sample_custom_header]: ../../../samples/topic/authentication.md#custom-header\n[sample_query_param]: ../../../samples/topic/authentication.md#query-parameter\n[sample_web_basic]: ../../../samples/topic/authentication.md#username-and-password\n[sample_manual_endpoint]: ../../../samples/topic/authentication.md#manual-endpoint\n[sample_automatic_endpoint]: ../../../samples/topic/authentication.md#automatic-endpoint\n[sample_selected_endpoint]: ../../../samples/topic/authentication.md#selected-endpoint\n[sample_connection_name]: ../../../samples/topic/authentication.md#oauth2\n[sample_coda_api]: ../../../samples/topic/authentication.md#coda-api-token\n[sample_custom]: ../../../samples/topic/authentication.md#custom-tokens\n[sample_multiple_query_params]: ../../../samples/topic/authentication.md#multiple-query-parameters\n[sample_multiple_headers]: ../../../samples/topic/authentication.md#multiple-headers\n\n[hc_account_sharing]: https://help.coda.io/en/articles/4587167-what-can-coda-access-with-packs\n[account_settings]: https://coda.io/account\n[AuthenticationType]: ../../../reference/sdk/enums/core.AuthenticationType.md\n[support]: ../../../support/index.md\n[coda_api_auth]: https://coda.io/developers/apis/v1#section/Authentication\n[HeaderBearerToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#headerbearertoken\n[CustomHeaderToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#customheadertoken\n[QueryParamToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#queryparamtoken\n[QueryParamToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#custom\n[wikipedia_basic_auth]: https://en.wikipedia.org/wiki/Basic_access_authentication\n[WebBasic]: ../../../reference/sdk/enums/core.AuthenticationType.md#webbasic\n[Custom]: ../../../reference/sdk/enums/core.AuthenticationType.md#custom\n[getConnectionName]: ../../../reference/sdk/interfaces/core.BaseAuthentication.md#getconnectionname\n[network_domains]: ../fetcher.md#network-domains\n[autocomplete_dynamic]: ../../basics/parameters/autocomplete.md#dynamic-options\n[oauth_guide]: oauth2.md\n[MultiQueryParamToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#multiqueryparamtoken\n[CodaApiHeaderBearerToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#codaapiheaderbearertoken\n[AWSAccessKey]: ../../../reference/sdk/enums/core.AuthenticationType.md#awsaccesskey\n[support_network_domain]: ../../../support/index.md#approvals\n[MultiHeaderToken]: ../../../reference/sdk/enums/core.AuthenticationType.md#multiheadertoken\n[aws_guide]: aws.md\n\n[]\n\nnav: OAuth\ndescription: Configure authentication for an API that uses OAuth2.\n\n[]"
    }
  },
  "Authenticating using OAuth": {
    "Supported OAuth flows": "The OAuth2 protocol supports a variety of flows, also known as grant types, which specify how exactly credentials are exchanged. The Pack SDK currently supports two of these flows:\n\n**Authorization Code** (`grant_type=authorization_code`)\n:   This is the standard OAuth2 flow that most people are familiar with, meant for accessing a user's private data. The user at the keyboard is redirected to a screen where they login to the application, approve access, and then are redirected back.\n\nTo use this flow in the Pack SDK select the authentication type [`OAuth2`][OAuth2Authentication].\n\n\n**Client Credentials** (`grant_type=client_credentials`)\n:   This OAuth2 flow doesn't usually involve the user and the keyboard at all, but is a way for the Pack to authenticate itself with the application. It's essentially a more secure version of an API key, since it uses short-lived tokens.\n\nTo use this flow in the Pack SDK select the authentication type [`OAuth2ClientCredentials`][OAuth2ClientCredentialsAuthentication].\n\n\nOther OAuth2 flows are not currently supported. The majority of this guide will assume you are using the Authorization Code flow, but see the section [Client credentials flow](#client_credentials) for more information about that flow specifically.",
    "Setup OAuth authentication": {
      "Add configuration code": "To configure [`OAuth2`][OAuth] authentication you must specify the authorization URL and the token URL. These URLs are found in the technical documentation of the API you are connecting to, and will be different for each API.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // These URLs come from the API's developer documentation.\n  authorizationUrl: \"https://example.com/authorize\",\n  tokenUrl: \"https://api.example.com/token\",\n});\n```\n\nMany APIs also support granular scopes, allowing you to request a limited set of permissions from the user. These can be specified as an array in the `scopes` field:\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // These URLs come from the API's developer documentation.\n  authorizationUrl: \"https://example.com/authorize\",\n  tokenUrl: \"https://api.example.com/token\",\n  scopes: [\"user\", \"projects\", \"tasks\"],\n});\n```\n\nThere are many subtle variations to the OAuth2 flow, and Coda can accommodate a variety of them. You can find the additional configuration options in the [`OAuth2Authentication`][OAuth2Authentication] documentation, as well as [sample code][sample_apis] showing how to setup OAuth for the most popular APIs.\n\nHowever if the API provider deviates too far from the OAuth 2.0 specification it may not be possible to find a configuration that will work. Additionally, Coda currently only supports the [Authorization Code][oauth2_code] grant type, and others like [Client Credentials][oauth2_client] can't be used. If you get stuck please [contact support][support] to explore other options.\n\n??? note \"Flexible authentication during token exchange\"\nThe OAuth2 specification doesn't require a specific authentication schema your app must use when exchanging tokens. Coda supports the two most popular variants:\n\n1. Sending the `client_secret` in the JSON body\n1. Sending an `Authorization: Basic` header using the client ID and secret.\n\nNo configuration is required, Coda will try them both to see what works.\n",
      "Set developer credentials": {
        "Redirect URL": "When registering you application in the API provider's console you will be asked to provide a redirect URL. This is where the provider should redirect the user to after they have signed in and approved access.\n\nThe **Add OAuth credentials** dialog discussed above will show the redirect URL to use for your Pack and allow you to copy it to your clipboard. In general it follows the pattern:\n\n```\nhttps://coda.io/packsAuth/oauth2/{PACK ID}\n```\n\n!!! warning \"Legacy redirect URLs\"\nPreviously the redirect URL for a Pack didn't include the Pack ID. We still support this using the **Legacy** option in the dropdown menu, but for greater security Packs should migrate to using the newer Pack-specific URLs."
      }
    },
    "Token expiry and refresh": "Many APIs return short-lived access tokens which expire after a few hours. Coda doesn't track the expiration of these tokens, but instead waits for an API request using the token to fail before attempting to refresh it. Specifically, Coda only does a refresh when:\n\n['The Pack execution fails with a [`StatusCodeError`][statuscodeerror] with a 401 status (Unauthorized)', 'The OAuth provider returned a `refresh_token` during a previous token exchange']\n\nIf you have error handling in your Pack, make sure to re-throw these 401 errors so that the token refresh process takes place.\n\n```\ntry {\n  let response = await context.fetcher.fetch({\n    // ...\n  });\n  // ...\n} catch (error) {\n  if (error.statusCode == 401) {\n    // Perhaps the token has expired, re-throw the error to attempt a refresh.\n    throw error;\n  }\n  // Else handle or throw the error as normal.\n}\n```",
    "Additional scopes": {
      "Triggering a prompt": "Normally the user will be prompted to approve new scopes if the Pack fails with a [`StatusCodeError`][statuscodeerror] with a 403 status (Forbidden). However some APIs may fail with different status codes, or only return partial information, if scopes are missing. In those cases you can detect the problem in your code and throw a [`MissingScopesError`][missingscopeserror] to trigger the prompt.\n\n```\ntry {\n  let response = context.fetcher.fetch({\n    // ...\n  });\n} catch (error) {\n  // Determine if the error is due to missing scopes.\n  if (error.statusCode == 400 && error.body?.message.includes(\"permission\")) {\n    throw new coda.MissingScopesError();\n  }\n  // Else handle or throw the error as normal.\n}\n```",
      "Incremental authorization": {
        "For two-way sync updates {:#incremental-two-way}": "For sync tables that support [two-way sync][two_way_sync] you may want to set additional scopes that only apply when the user is making edits to the table. To do so, set the field `updateOptions.extraOAuthScopes` to the scopes needed to send edits.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // ...\n  scopes: [\"read\"],\n});\n\npack.addSyncTable({\n  name: \"Items\",\n  // ...\n  formula: {\n    // ...\n    executeUpdate: async function (args, updates, context) {\n      // Send edits ...\n    },\n    updateOptions: {\n      // Additional scopes needed to send edits (run executeUpdate).\n      extraOAuthScopes: [\"write\"],\n    },\n  },\n});\n```\n\nThe `updateOptions.extraOAuthScopes` field overrides the value of `extraOAuthScopes` if it is already set. In this case you'll want to make sure that your update scopes are inclusive of your regular sync scopes, so that the correct scopes are requested regardless of the entry point.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // ...\n  scopes: [\"user:read\"],\n});\n\npack.addSyncTable({\n  name: \"Items\",\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      // Sync the rows ...\n    },\n    executeUpdate: async function (args, updates, context) {\n      // Send edits ...\n    },\n    // Additional scopes needed to sync.\n    extraOAuthScopes: [\"items:read\"],\n    updateOptions: {\n      // Additional scopes needed to sync and send edits.\n      extraOAuthScopes: [\"items:read\", \"items:write\"],\n    },\n  },\n});\n```"
      }
    },
    "URL limitations {: #url-limitations}": "Some services host a unique domain or subdomain for each account, and require that API requests be sent there. The [account-specific endpoints][auth_endpoints] feature can be used to determine the endpoint for a given account, but it assumes that the user has already authenticated using a common set of OAuth URLs.\n\nIt currently isn't possible to change the `authorizationUrl` and `tokenUrl` dynamically or prompt the user to specify them. One workaround is to create a copy of the Pack for each domain you want to connect to, but that obviously doesn't scale well.\n\nAdditionally, in order to prevent abuse, Coda enforces the `authorizationUrl` and `tokenUrl` configured have the same domain. This is almost always true, but in rare cases an API provider may use a different URL for each. To request an exemption from this restriction fill out the [Approval request form][support_network_domains].\n\n!!! info \"OAuth domain and network domain\"\nThe domain of the OAuth configuration URLs does not need to match the [network domain][fetcher_network_domains] configured for fetcher requests. This is convenient for services where the OAuth provider is a 3rd party (Okta, Auth0, etc).",
    "Advanced settings": {
      "Proof Key for Code Exchange (PKCE)": "Some OAuth providers offer or require the use of [Proof Key for Code Exchange (PKCE)][oauth_pkce] during the OAuth flow. It is an additional flow layered on top of the standard Authorization Code flow that increases security by helping prevent against certain forms of attack. To use it in a Pack you simply need to enable the feature using the `useProofKeyForCodeExchange` field of the authentication configuration.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // ...\n  useProofKeyForCodeExchange: true,\n});\n```\n\nThe PKCE standard supports two different ways of creating a challenge from the verifier: `S256` (the default) and `plain`. Coda will use the more secure `S256` method by default, but you can override it using the `pkceChallengeMethod` field.\n\n```\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // ...\n  useProofKeyForCodeExchange: true,\n  pkceChallengeMethod: \"plain\",\n});\n```"
    },
    "Client credentials flow {: #client_credentials}": "While the Authorization Code flow discussed above is used to access private user data, the Client Credentials flow is typically just used to authenticate the integration itself. Therefore it's most commonly implemented as a system-wide form of authentication, although per-user authentication is also supported.\n\nTo setup the authentication all you need to do is set the type and provide the URL used to token exchange.\n\n```\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.OAuth2ClientCredentials,\n  // This URL comes from the API's developer documentation.\n  tokenUrl: \"https://api.example.com/token\",\n});\n```\n\nIf using system-wide authentication you'll need to set the client ID and secret in the Pack settings. If using per-user authentication the user will be prompted for their client ID and secret when connecting their account.\n\nLike with the Authorization Code flow, a variety of other advanced options are also available to support non-standard OAuth2 implementations. See the class [`OAuth2ClientCredentialsAuthentication`][OAuth2ClientCredentialsAuthentication] for more information.\n\n[oauth_definition]: https://oauth.net/2/\n[authentication]: index.md\n[OAuth]: ../../../reference/sdk/enums/core.AuthenticationType.md#oauth2\n[OAuth2Authentication]: ../../../reference/sdk/interfaces/core.OAuth2Authentication.md\n[OAuth2ClientCredentialsAuthentication]: ../../../reference/sdk/interfaces/core.OAuth2ClientCredentialsAuthentication.md\n[oauth2_code]: https://www.oauth.com/oauth2-servers/server-side-apps/authorization-code/\n[oauth2_client]: https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/\n[extraOAuthScopes]: ../../../reference/sdk/interfaces/core.BaseFormulaDef.md#extraoauthscopes\n[support]: ../../../support/index.md\n[support_network_domains]: ../../../support/index.md#approvals\n[sample_oauth2]: ../../../samples/topic/authentication.md#oauth2\n[sample_apis]: ../../../samples/topic/apis.md\n[tutorial_oauth2]: ../../../tutorials/build/oauth.md\n[statuscodeerror]: ../../../reference/sdk/classes/core.StatusCodeError.md\n[missingscopeserror]: ../../../reference/sdk/classes/core.MissingScopesError.md\n[auth_endpoints]: index.md#endpoints\n[fetcher_network_domains]: ../fetcher.md#network-domains\n[oauth_pkce]: https://www.oauth.com/oauth2-servers/pkce/\n[two_way_sync]: ../../blocks/sync-tables/two-way.md\n\n[]\n\nnav: Data types\ndescription: Use semantic types to accurately represent data in the document.\n\n[]"
  },
  "Return data with meaningful types": {
    "Value types": {
      "Strings": "Text values can be returned as [JavaScript strings][mdn_string] using the [`String`][String] value type.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  execute: async function ([], context) {\n    return \"Hello World!\";\n  },\n});\n```",
      "Numbers": "Number values can be returned as [JavaScript numbers][mdn_number] using the [`Number`][Number] value type.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Number,\n  execute: async function ([], context) {\n    return 42;\n  },\n});\n```",
      "Booleans": "True or false values can be returned as [JavaScript booleans][mdn_boolean] using the [`Boolean`][Boolean] value type.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([], context) {\n    return true;\n  },\n});\n```",
      "Objects": "Structured data can be returned as [JavaScript objects][mdn_object] using the [`Object`][Object] value type. These objects must conform to an defined schema, as specified in the `schema` property. See the [Schemas guide][schemas] for more information about defining and using schemas.\n\n```\nconst MySchema = coda.makeObjectSchema({\n  properties: {\n    property1: { type: coda.ValueType.String },\n    property2: { type: coda.ValueType.Number },\n    // ...\n  },\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: MySchema,\n  execute: async function ([], context) {\n    return {\n      property1: \"This is a string\",\n      property2: 42,\n      // ...\n    };\n  },\n});\n```\n\nObjects are displayed in the doc as a \"chip\", a small rectangle with rounded corners. The display value is shown within the chip, with additional properties of object shown on hover.\n\n<img src=\"../../../images/data_types_object_hover.png\" srcset=\"../../../images/data_types_object_hover_2x.png 2x\" class=\"screenshot\" alt=\"Hovering over an object chip\">\n\nLike Coda tables, the fields within an object can be accessed using dot notation.\n\n<img src=\"../../../images/data_types_object_dot.png\" srcset=\"../../../images/data_types_object_dot_2x.png 2x\" class=\"screenshot\" alt=\"Using dot notation to access the properties of the object\">",
      "Arrays": "Lists of data can be returned as [JavaScript arrays][mdn_array] using the [`Array`][Array] value type. The resulting array is represented as a [`List`][formula_list] in the Coda formula language.\n\nYou must also specify the [schema][schemas] of the items in the array, using the `items` property. For arrays of simple data you can define the schema inline, supplying only the `type` key.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Array,\n  items: { type: coda.ValueType.String },\n  execute: async function ([], context) {\n    return [\"This\", \"is\", \"a\", \"string\", \"array\"];\n  },\n});\n```\n\nFor arrays of objects, set `items` to the full object schema.\n\n```\nconst MySchema = coda.makeObjectSchema({\n  properties: {\n    property1: { type: coda.ValueType.String },\n    property2: { type: coda.ValueType.Number },\n  },\n  // ...\n});\n\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Array,\n  items: MySchema,\n  execute: async function ([], context) {\n    return [\n      { property1: \"This is a string\", property2: 42 },\n      { property1: \"Another string\", property2: 100 },\n    ];\n  },\n});\n```"
    },
    "Value hints": {
      "Markdown {. #markdown}": "The [`Markdown`][hint_markdown] value hint indicates that Coda should parse the returned string as markdown and render it as rich text. The value can contain [basic markdown syntax][markdown], but extensions used by other applications (like tables, emoji, etc) are not supported.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Markdown,\n  execute: async function ([], context) {\n    return \"This is _so_ **cool**!\";\n  },\n});\n```\n\n??? example \"Rendering examples\"\n<iframe src=\"https://coda.io/embed/Yh3vyeakVr/_subS4\" width=900 height=500 style=\"max-width: 100%;\" allow=\"fullscreen\" loading=\"lazy\"></iframe>",
      "HTML": "The [`Html`][hint_html] value hint indicates that Coda should parse the returned string as HTML and render it as rich text. Code only supports a small subset of HTML markup, limited to the basic formatting you can accomplish in [markdown](#markdown).\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Html,\n  execute: async function ([], context) {\n    return \"This is <i>so</i> <b>cool</b>!\";\n  },\n});\n```\n\n??? example \"Rendering examples\"\n<iframe src=\"https://coda.io/embed/Yh3vyeakVr/_sudor\" width=900 height=500 style=\"max-width: 100%;\" allow=\"fullscreen\" loading=\"lazy\"></iframe>",
      "Dates and times {: #dates}": "The [`Date`][Date], [`Time`][Time], and [`DateTime`][DateTime] value hints can be applied to either `String` or `Number` values.\n\nWhen used with a string value, Coda attempts to parse the value, and is able to parse a wide variety of date and time formats. For maximum compatibility however use the [ISO 8601][ISO_8601] format. When using a JavaScript `Date` object this can be obtained by calling `toISOString()`. If the string doesn't include a timezone identifier or offset then Coda will assume it's already in the timezone of the document. See the [Timezones guide][timezones] for more information about how timezones affect return values.\n\nWhen used with a number value, the number should contain the number of seconds since the [Unix epoch][unix_epoch] (00:00:00 UTC on 1 January 1970). When using a JavaScript `Date` object this can be obtained by calling `getTime()` and dividing by 1000.\n\n=== \"From String\"\n\n```ts\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.DateTime,\n  execute: async function ([], context) {\n    let now = new Date();\n    return now.toISOString();\n  },\n});\n```\n\n\n=== \"From Number\"\n\n```ts\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.DateTime,\n  execute: async function ([], context) {\n    let now = new Date();\n    return now.getTime() / 1000;\n  },\n});\n```\n\n\n!!! warning\nThe `Date` and `Time` value hints currently only work correctly within a sync table. When used outside of a sync table both the date and time parts of the returned date will be visible, as if `DateTime` was used.",
      "Durations {: #durations}": "The [`Duration`][Duration] value hint represents an amount of time, rather than a specific time. It can be applied to `Number` or `String` values. For numbers, the value represents the number of days (fractional amounts allowed). For strings, the value must match one of a few formats:\n\n| Example                     | Result              | Notes                           |\n| --------------------------- | ------------------- | ------------------------------- |\n| 6 hours 1 minute 15 seconds | 6 hrs 1 min 15 secs | Full units.                     |\n| 6 hrs 1 min 15 secs         | 6 hrs 1 min 15 secs | Abbreviated units.              |\n| 6 hrs, 1 min, 15 secs       | 6 hrs 1 min 15 secs | Commas allowed.                 |\n| 0.25 days, 1 min, 15 secs   | 6 hrs 1 min 15 secs | Fractional amounts allowed.     |\n| 72000 minutes               | 50 days             | Don't use thousands separators. |\n\nAny duration value your Pack returns will be automatically converted into its most user-friendly form by Coda. For example, `3600 seconds` will be shown to the user as **1 hr**.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Duration,\n  execute: async function ([], context) {\n    return \"525600 minutes\";\n  },\n});\n```",
      "Percentages": "Formulas that return a result as a percentage can use the value type `Number` and the value hint [`Percent`][Percent]. Return a fraction in your code and the doc will display the equivalent percentage.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Percent,\n  execute: async function ([], context) {\n    return 0.5; // Displayed as \"50%\" in the doc.\n  },\n});\n```",
      "Images {: #images}": "There are two different value hints for image: [`ImageReference`][ImageReference] and [`ImageAttachment`][ImageAttachment]. Both of these are applied to string values, where the string contains the URL of the image. For image references, the image is always loaded from the source URL. For image attachments, Coda copies the image from the source URL into the document and shows that local copy.\n\nImage attachments should be used in most cases. An image reference may make more sense if you expect the image to be updated often and want to ensure the doc is always using the latest copy, or when contractually obligated to hotlink to the image.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([], context) {\n    return \"https://via.placeholder.com/150\";\n  },\n});\n```\n\n!!! bug\nImage attachments currently only work correctly within a sync table. When used outside of a sync table they behave like image references and load the image from the source URL.",
      "Files {: #files}": "Similar to `ImageAttachment` mentioned above, you can return other file types using the value hint `Attachment`. This hint is also applied to string values, where the string contains the URL of the file. Coda copies the file from the source URL into the document and uses that local copy.\n\n```\nconst DealSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    contract: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Attachment,\n    },\n  },\n  // ...\n});\n```\n\n!!! bug\nAttachments currently only work within a sync table.\n<!-- https://golinks.io/bug/21522 -->\nAdditionally, file attachments may be shown with the wrong file name.\n<!-- https://golinks.io/bug/21523 -->",
      "Select lists": "The [`SelectList`][hint_selectlist] value hint can be used to render the property as a select list. It is only supported in sync tables, and is most useful in those that support [two-way sync][two_way].\n\nIt can be applied to properties of type `String` or `Object`. The possible options of the select list are set in the `options` field, which can contain an array of values or a function that generates them.\n\n```\nconst ShirtSchema = coda.makeObjectSchema({\n  properties: {\n    size: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      options: [\"S\", \"M\", \"L\", \"XL\"],\n    },\n    // ...\n  },\n  // ...\n});\n```\n\nTo allow multiple selections, wrap the schema in an outer `Array` schema.\n\n```\nconst OrderSchema = coda.makeObjectSchema({\n  properties: {\n    sizes: {\n      type: coda.ValueType.Array,\n      items: {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.SelectList,\n        options: [\"S\", \"M\", \"L\", \"XL\"],\n      },\n    },\n    // ...\n  },\n  // ...\n});\n```\n\nSee the [Two-way Sync guide][two_way_options] for more information about property options.",
      "Embedded content": "The [`Embed`][Embed] value hint can be used to embed external content in the Coda doc. This value hint can be applied to `String` values, where the string contains the URL to the external content.\n\n```\npack.addFormula({\n  // ...\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Embed,\n  execute: async function ([], context) {\n    return \"https://www.youtube.com/watch?v=oLYZv68M3Kg\";\n  },\n});\n```\n\nRead the [Embedding content][embeds] guide to learn more.",
      "People": "The [`Person`][Person] value hint can be used to @-reference a Coda user account. This hint can be applied to `Object` values, where the object has a property that specifies the user's email address. The email address must be contained within the property of the object that is listed as its `idProperty` within the schema definition, and that property must be marked as `required`.\n\n```\nconst MyPersonSchema = coda.makeObjectSchema({\n  codaType: coda.ValueHintType.Person,\n  properties: {\n    name: {type: coda.ValueType.String},\n    email: { type: coda.ValueType.String, required: true },\n  },\n  displayProperty: \"name\",\n  idProperty: \"email\",\n});\n```\n\nWhen no Coda user with the given email address is found the object will render as a normal object chip.\n\n!!! warning\nThis value hint currently only work correctly within a sync table. When used outside of a sync table it will render as a normal object chip, as if no value hint was applied.",
      "Row reference": "The [`Reference`][Reference] value hint can be used to reference a row in a sync table. See the [Schemas guide][schemas_references] for more information about defining and using schema references.\n\n!!! warning\nThis value hint currently only work correctly within a sync table. When used outside of a sync table it will render as a normal object chip, as if no value hint was applied."
    },
    "Corresponding column types {:#column-types}": "The columns of a Coda table are strongly typed, and the data types in the Pack SDK roughly correspond to those same types. The table below indicates the value type and value hint that corresponds to a each column type.\n\n| Column type   | Supported  | Value type               | Value hint        | Options                                                                                                       |\n| ------------- | ---------- | ------------------------ | ----------------- | ------------------------------------------------------------------------------------------------------------- |\n| Text          |  Yes     | `String`                 |                   |                                                                                                               |\n| Link          |  Yes     | `String`                 | `Url`             | [`LinkSchema`][LinkSchema]                                                                                    |\n| Embed[^1]     |  Yes     | `String`                 | `Embed`           | [`StringEmbedSchema`][StringEmbedSchema]                                                                      |\n| Canvas        |  No      |                          |                   |                                                                                                               |\n| Select list   |  Yes     | `String` or<br>`Object`  | `SelectList`      | [`StringWithOptionsSchema`][StringWithOptionsSchema] or<br>[`ObjectSchemaDefinition`][ObjectSchemaDefinition] |\n| Number        |  Yes     | `Number`                 |                   | [`NumericSchema`][NumericSchema]                                                                              |\n| Percent       |  Yes     | `Number`                 | `Percent`         | [`NumericSchema`][NumericSchema]                                                                              |\n| Currency      |  Yes     | `Number`                 | `Currency`        | [`CurrencySchema`][CurrencySchema]                                                                            |\n| Slider        |  Yes[^2] | `Number`                 | `Slider`          | [`SliderSchema`][SliderSchema]                                                                                |\n| Progress      |  Yes[^2] | `Number`                 | `ProgressBar`     | [`ProgressBarSchema`][ProgressBarSchema]                                                                      |\n| Scale         |  Yes[^2] | `Number`                 | `Scale`           | [`Scalechema`][SliderSchema]                                                                                  |\n| Date          |  Yes     | `String` or<br>`Number`  | `Date`            | [`StringDateSchema`][StringDateSchema] or<br>[`NumericDateSchema`][NumericDateSchema]                         |\n| Time          |  Yes     | `String` or<br> `Number` | `Time`            | [`StringTimeSchema`][StringDateSchema] or<br>[`NumericTimeSchema`][NumericDateSchema]                         |\n| Date and time |  Yes     | `String` or<br> `Number` | `DateTime`        | [`StringDateTimeSchema`][StringDateSchema] or<br>[`NumericDateTimeSchema`][NumericDateSchema]                 |\n| Duration      |  Yes     | `String` or<br>`Number`  | `Duration`        | [`DurationSchema`][DurationSchema] or<br>[`NumericDurationSchema`][NumericDurationSchema]                     |\n| Checkbox      |  Yes[^2] | `Boolean`                |                   |                                                                                                               |\n| Toggle        |  Yes[^2] | `Boolean`                | `Toggle`          |                                                                                                               |\n| People        |  Yes     | `Object`                 | `Person`          |                                                                                                               |\n| Email         |  Yes     | `String`                 | `Email`           | [`EmailSchema`][EmailSchema]                                                                                  |\n| Reaction      |  No      |                          |                   |                                                                                                               |\n| Button        |  No[^3]  |                          |                   |                                                                                                               |\n| Image         |  Yes     | `String`                 | `ImageAttachment` | [`ImageSchema`][ImageSchema]                                                                                  |\n| Image URL     |  Yes     | `String`                 | `ImageReference`  | [`ImageSchema`][ImageSchema]                                                                                  |\n| File          |  Yes     | `String`                 | `Attachment`      |                                                                                                               |\n| Relation      |  Yes     | `Object`                 | `Reference`       |                                                                                                               |\n\n[^1]: Embed isn't a column type in Coda, but it can be used in a table or on the canvas to embed content.\n[^2]: Control column types will only render correctly in a sync table, and will not be interactive.\n[^3]: While a Pack can't return a button directly, it can provide [actions][actions] that a user can use to power their buttons.",
    "Formatting options": "Some value types and hints support additional formatting options. For example, `Number` types support a [`precision`][precision] option that controls how many decimal places to show, and `Currency` supports a [`currencyCode`][currencyCode] option that determine the currency symbol to show. These options are set in a schema, and for a formula result this may meaning adding a `schema` property to the formula definition.\n\n=== \"Formula\"\n\n```ts\npack.addFormula({\n  name: \"GetPrice\",\n  // ...\n  resultType: coda.ValueType.Number,\n  schema: {\n    type: coda.ValueType.Number,\n    codaType: coda.ValueHintType.Currency,\n    currencyCode: \"EUR\",\n    precision: 2,\n  },\n  // ...\n});\n```\n\n\n=== \"Schema\"\n\n```ts\nconst PriceSchema = coda.makeSchema({\n  type: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  currencyCode: \"EUR\",\n  precision: 2,\n});\n```\n\n\nThe full set of formatting options for a given value type and hint can be found in the **Options** column of the [table above](#column-types).\n\n[samples]: ../../samples/topic/data-type.md\n[formulas]: ../blocks/formulas.md\n[schemas]: ../advanced/schemas.md\n[schemas_references]: ../advanced/schemas.md#references\n[ValueType]: ../../reference/sdk/enums/core.ValueType.md\n[String]: ../../reference/sdk/enums/core.ValueType.md#string\n[Number]: ../../reference/sdk/enums/core.ValueType.md#number\n[Boolean]: ../../reference/sdk/enums/core.ValueType.md#boolean\n[Array]: ../../reference/sdk/enums/core.ValueType.md#array\n[Object]: ../../reference/sdk/enums/core.ValueType.md#object\n[ValueHintType]: ../../reference/sdk/enums/core.ValueHintType.md\n[Date]: ../../reference/sdk/enums/core.ValueHintType.md#date\n[Percent]: ../../reference/sdk/enums/core.ValueHintType.md#percent\n[Time]: ../../reference/sdk/enums/core.ValueHintType.md#time\n[DateTime]: ../../reference/sdk/enums/core.ValueHintType.md#datetime\n[Duration]: ../../reference/sdk/enums/core.ValueHintType.md#duration\n[ImageAttachment]: ../../reference/sdk/enums/core.ValueHintType.md#imageattachment\n[ImageReference]: ../../reference/sdk/enums/core.ValueHintType.md#imagereference\n[Embed]: ../../reference/sdk/enums/core.ValueHintType.md#embed\n[Person]: ../../reference/sdk/enums/core.ValueHintType.md#person\n[Reference]: ../../reference/sdk/enums/core.ValueHintType.md#reference\n[markdown]: https://www.markdownguide.org/basic-syntax/\n[markdown_code_fenced]: https://www.markdownguide.org/extended-syntax/#fenced-code-blocks\n[markdown_code_indent]: https://www.markdownguide.org/basic-syntax/#code-blocks\n[markdown_checkbox_list]: https://www.markdownguide.org/extended-syntax/#task-lists\n[markdown_strikethrough]: https://www.markdownguide.org/extended-syntax/#strikethrough\n[markdown_automatic_links]: https://www.markdownguide.org/extended-syntax/#automatic-url-linking\n[hint_markdown]: ../../reference/sdk/enums/core.ValueHintType.md#markdown\n[hint_html]: ../../reference/sdk/enums/core.ValueHintType.md#html\n[hint_selectlist]: ../../reference/sdk/enums/core.ValueHintType.md#selectlist\n[ISO_8601]: https://en.wikipedia.org/wiki/ISO_8601\n[unix_epoch]: https://en.wikipedia.org/wiki/Unix_time\n[iframely]: https://iframely.com/\n[oEmbed]: https://oembed.com/\n[embed_force]: https://help.coda.io/en/articles/1211364-embedding-content-in-your-doc#using-the-force-parameter\n[column_formats]: https://help.coda.io/en/articles/1235680-overview-of-column-formats\n[actions]: ../blocks/actions.md\n[precision]: ../../reference/sdk/interfaces/core.NumericSchema.md#precision\n[currencyCode]: ../../reference/sdk/interfaces/core.CurrencySchema.md#currencycode\n[NumericSchema]: ../../reference/sdk/interfaces/core.NumericSchema.md\n[CurrencySchema]: ../../reference/sdk/interfaces/core.CurrencySchema.md\n[SliderSchema]: ../../reference/sdk/interfaces/core.SliderSchema.md\n[ScaleSchema]: ../../reference/sdk/interfaces/core.ScaleSchema.md\n[NumericDateSchema]: ../../reference/sdk/interfaces/core.NumericDateSchema.md\n[NumericTimeSchema]: ../../reference/sdk/interfaces/core.NumericTimeSchema.md\n[NumericDateTimeSchema]: ../../reference/sdk/interfaces/core.NumericDateTimeSchema.md\n[StringDateSchema]: ../../reference/sdk/interfaces/core.StringDateSchema.md\n[StringTimeSchema]: ../../reference/sdk/interfaces/core.StringTimeSchema.md\n[StringDateTimeSchema]: ../../reference/sdk/interfaces/core.StringDateTimeSchema.md\n[DurationSchema]: ../../reference/sdk/interfaces/core.DurationSchema.md\n[StringEmbedSchema]: ../../reference/sdk/interfaces/core.StringEmbedSchema.md\n[ImageSchema]: ../../reference/sdk/interfaces/core.ImageSchema.md\n[NumericDurationSchema]: ../../reference/sdk/interfaces/core.NumericDurationSchema.md\n[LinkSchema]: ../../reference/sdk/interfaces/core.LinkSchema.md\n[ProgressBarSchema]: ../../reference/sdk/interfaces/core.ProgressBarSchema.md\n[EmailSchema]: ../../reference/sdk/interfaces/core.EmailSchema.md\n[StringWithOptionsSchema]: ../../reference/sdk/interfaces/core.StringWithOptionsSchema.md\n[ObjectSchemaDefinition]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md\n[formula_list]: https://coda.io/formulas#List\n[embeds]: ../advanced/embeds.md\n[timezones]: ../advanced/timezones.md\n[mdn_string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n[mdn_number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\n[mdn_boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean\n[mdn_array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n[mdn_object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n[two_way]: ../blocks/sync-tables/two-way.md\n[two_way_options]: ../blocks/sync-tables/two-way.md#options\n\n[]\n\ndescription: Make HTTP requests to external APIs and services using the custom Fetcher interface."
  },
  "Fetching remote data": {
    "Network domains {: #network-domains}": "Before you can start making any requests using the fetcher, your Pack must declare which domain names it is going to communicate with. This can be done using the [`addNetworkDomain()`][addNetworkDomain] method of the pack:\n\n```\npack.addNetworkDomain(\"example.com\");\n```\n\nThe fetcher can to communicate with URLs on that domain and all sub-domains. It's usually best select the root domain of the service you are working with. For example, if you want to make requests to `api.example.com`, add the network domain `example.com`, in case you later determine you need to access related content on `images.example.com`, etc.\n\nBy default a Pack is only allowed to register a single domain. This is done to limit abuse potential and provide transparency to users. If you want to combine data from multiple sources we recommend building multiple Packs and using the features of a Coda doc to bring them together. If however your use case requires making requests to multiple domains from a single Pack you may request approval by [contacting support][support_network_domains].\n\nThe following domains don't need to be declared as a network domain in your Pack:\n\n['`codahosted.io` (used to host image and file attachments in Coda docs)', '`coda-us-west-2-prod-blobs-upload.s3.us-west-2.amazonaws.com` (used by [temporary blob storage][temporaryblobstorage])']\n\n!!! info \"Multiple domains and authentication\"\nIf you make requests to multiple network domains and utilize [per-user authentication][auth_user], you'll need to set the [`networkDomain`][baseauthentication_networkdomain] field of the authentication configuration to specify which domain it should be applied to. Authentication credentials can only be applied to a single domain.",
    "Accessing the fetcher": "The fetcher is made available in the `execute` function of a formula through the [`context`][ExecutionContext] object. This object is the second parameter of the `execute` function, after the array of formula parameters set by the user:\n\n```\npack.addFormula({\n  // ...\n  execute: async ([foo, bar], context) => {\n    let fetcher = context.fetcher;\n    // ...\n  },\n});\n```\n\nIn metadata formulas, such as those that determine autocomplete choices or connection names, the context is the only parameter:\n\n```\ncoda.makeParameter({\n  // ...\n  autocomplete: async (context) => {\n    let fetcher = context.fetcher;\n    // ...\n  },\n}),\n```",
    "Making requests": {
      "In parallel": "If you want to make multiple requests in parallel you can instead kick off all of your requests, wait for them all to finish, and then look at the results. This requires some understanding of [Promises][promises], but basically follows a pattern like:\n\n```\npack.addFormula({\n  // ...\n  execute: async ([], context) => {\n    let urls = [\n      // The URLs to fetch in parallel.\n    ];\n    let requests = [];\n    for (let url of urls) {\n      // Kick off the request.\n      let request = context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      requests.push(request);\n    }\n    // Wait for all the requests to finish.\n    let responses = await Promise.all(requests);\n\n    for (let response of responses) {\n      // Do something with the response.\n    }\n  },\n});\n```"
    },
    "Sending data": {
      "URL query parameters {:#query-parameters}": "To send data in the URL query parameters, simply append those parameters to the URL passed to the fetcher. For example, `https://www.example.com?foo=bar&thing=true`. The SDK provides a helper function, [`coda.withQueryParams()`][withQueryParams] that simplifies the process of encoding and appending query parameters to a URL.\n\n```\nlet url = coda.withQueryParams(\"https://www.example.com\", {\n  foo: \"bar\",\n  thing: true,\n});\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: url,\n});\n```",
      "JSON {:#json-body}": "Sending JSON is just like sending text above, except you typically define the payload as a JavaScript object first and then convert it into a string using [`JSON.stringify()`][stringify]. In addition, you'll need to set the `Content-Type` header to `application/json`.\n\n```\nlet payload = {\n  foo: \"bar\",\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://httpbin.org/post\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(payload),\n});\n```",
      "GraphQL": "[GraphQL][graphql] is a modern query language used by APIs to allow you to retrieve the data you want with fewer requests and smaller responses. There are two primary ways to pass a query, either in a URL query parameter named `query` or in the `query` key of a JSON payload. Refer to your API's documentation for which of these methods it supports.\n\nBoth of these options are compatible with Packs, as described in [URL query parameters](#query-parameters) and [JSON](#json-body) sections above. The GraphQL query itself is just plain text in either case.\n\n=== \"URL query parameters\"\n\n```ts\nlet query = `\n  {\n    human(id: \"1000\") {\n      name\n      height\n    }\n  }\n`;\nlet url = coda.withQueryParams(\"https://api.example.com\", {\n  query: query,\n});\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: url,\n});\n```\n\n\n=== \"JSON\"\n\n```ts\nlet query = `\n  {\n    human(id: \"1000\") {\n      name\n      height\n    }\n  }\n`;\nlet payload = {\n  query: query,\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://api.example.com\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(payload),\n});\n```\n\n\n!!! info \"POST caching\"\nThe responses from `POST` requests aren't cached by default, but you can enable caching for them using the [`forceCache` option][forceCache].",
      "Form data": "To send data to a server that expects form input (`application/x-www-form-urlencoded`) use the `form` property of the request. Pass a set of key-value pairs representing the form fields, ensuring that all of the values are strings. The fetcher will format and encode the data, pass it in the body, and set the correct `Content-Type` header.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://httpbin.org/post\",\n  form: {\n    name: \"Alice\",\n    active: String(true),\n    days: String(15),\n  },\n});\n```\n\nSending attachments (`multipart/form-data`) is not supported natively in the SDK. When building locally with the Pack CLI you can use the [`form-data` NPM library][npm_form_data] to send mixed content, as demonstrated in the [Box example Pack][example_box].",
      "Binary {: #binary-body}": "You can send binary data in the body of a request by passing a [Node.js `Buffer`][buffer] in the `body` field of the request. These buffers can be constructed manually, but are most often are the result of [downloading binary content](#binary-response) from another endpoint.\n\n```\nlet data = \"SGVsbG8gV29ybGQh\";\nlet buffer = Buffer.from(data, \"base64\");\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://www.example.com/upload\",\n  headers: {\n    \"Content-Type\": \"text/plain\",\n  },\n  body: buffer,\n});\n```\n\nSending binary data along with other types of content (`multipart/form-data`) is not supported natively in the SDK. When building locally with the Pack CLI you can use the [`form-data` NPM library][npm_form_data] to send mixed content, as demonstrated in the [Box example Pack][example_box]."
    },
    "Working with responses": {
      "Text": "Except for the special content types described below, the response body will be returned as plain text.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://www.example.com\", // Returns an HTML page.\n});\nlet html = response.body;\nlet bodyStart = html.indexOf('<body>');\n```",
      "JSON": "Responses with the content type `application/json` will be automatically parsed into a JavaScript object. This allows you to start accessing the data without needing to first call `JSON.parse()`.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://api.exchangerate.host/latest?format=json\",\n});\nlet parsed = response.body;\n// How you access data in the parsed JSON object depends on the contents.\nlet rate = parsed.rates[\"USD\"];\n```",
      "XML": "Responses with the content type `application/xml` or `text/xml` will be automatically parsed into a JavaScript object, using the library [xml2js][xml2js]. Specifically, every XML element is converted into a JavaScript object, where the keys are the name of child elements and the values are the contents of those elements. Even when an element only contains a single value it is always returned within an array. The special key `$` reserved for attributes on the element. For example:\n\n=== \"Original XML\"\n```xml\n<basket pending=\"true\">\n<item quantity=\"1\">\n<name>Bread</name>\n<cost>$5</cost>\n</item>\n<item quantity=\"5\">\n<name>Apple</name>\n<cost>$1</cost>\n</item>\n</basket>\n```\n=== \"Parsed JSON\"\n```json\n{\n\"$\": {\n\"pending\": \"true\"\n},\n\"item\": [\n{\n\"$\": {\n\"quantity\": \"1\"\n},\n\"name\": [ \"Bread\" ],\n\"cost\": [ \"$5\" ]\n},\n{\n\"$\": {\n\"quantity\": \"5\"\n},\n\"name\": [ \"Apple\" ],\n\"cost\": [ \"$1\" ]\n}\n]\n}\n```\n\nDuring development it is a good idea to log the parsed JavaScript object, so that you can more clearly understand the structure of the parsed XML.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  // Open this URL in your browser to see what the data looks like.\n  url: \"https://api.exchangerate.host/latest?format=xml\",\n});\nlet parsed = response.body;\n\n// Log the parsed XML, for reference when developing.\nconsole.log(parsed);\n\nlet usd = parsed.data.find(item => item.code[0] === \"USD\")\nlet rate = usd.rate[0];\n```",
      "Binary {: #binary-response}": "When fetching binary data, enable the request option `isBinaryResponse` to let the fetcher know that it shouldn't try to parse the server response. When binary responses are enabled the `body` field of the response object will contain a [Node.js `Buffer`][buffer].\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://cataas.com/cat\", // Returns a random cat image.\n  isBinaryResponse: true,\n});\nlet buffer = response.body;\nlet byteLength = buffer.length;\n```",
      "Errors": "When a request fails (a response code of 300 or higher) the fetch will fail with a [`StatusCodeError`][status_code_error] exception. This exception contains useful information about the failed request, including the full response body.\n\n```\nlet response;\ntry {\n  response = await context.fetcher.fetch({\n    method: \"GET\",\n    // Open this URL in your browser to see what the data looks like.\n    url: \"https://api.artic.edu/api/v1/artworks/123\",\n  });\n} catch (error) {\n  // If the request failed because the server returned a 300+ status code.\n  if (coda.StatusCodeError.isStatusCodeError(error)) {\n    // Cast the error as a StatusCodeError, for better intellisense.\n    let statusError = error as coda.StatusCodeError;\n    // If the API returned an error message in the body, show it to the user.\n    let message = statusError.body?.detail;\n    if (message) {\n      throw new coda.UserVisibleError(message);\n    }\n  }\n  // The request failed for some other reason. Re-throw the error so that it\n  // bubbles up.\n  throw error;\n}\n```",
      "Headers {: #headers}": "The HTTP headers returned can be accessed using the `headers` field of the response. The header names are normalized (changed to lowercase) for convenience, so you can access them consistently regardless of how they are sent by the server.\n\n```\nlet contentType = response.headers[\"content-type\"].toString();\n```\n\nUnless it's a known safe header, all the header values will be redacted by Coda (contain the value `<<<REDACTED by Coda>>>` instead of the actual value). To request that a specific header be unredacted you will need to [contact support][support].\n\n!!! info \"Multiple header values\"\nA server may return multiple headers with the same name. In this case, the header value will be a string array instead of a single string. As per [the spec][spec_headers], this should only happen for headers that return comma-separated values. Adding a `.toString()` call after retrieving the header value is an easy way to collapse both cases down to a single string."
    },
    "Authentication": "The [authentication][authentication] you configure for your Pack is automatically applied to fetcher requests, with no extra code needed. For example, if you have set up `HeaderBearer` authentication, an `Authorization` header with the user's token will be automatically added to your fetcher requests. This is only done for formulas that use a connected account: those that have a `connectionRequirement` of `REQUIRED`, or `OPTIONAL` and the user opted to selected an account.\n\nTo disable this behavior for a specific request within a formula, set the `fetch` option `disableAuthentication: true`.\n\n```\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: `https://www.example.com`,\n  disableAuthentication: true, // No auth will be applied to this request.\n});\n```\n\n??? warning \"Mixed credentials not allowed\"\n\nPacks that include per-user authentication are not allowed to pass hard-coded credentials in the same location as user credentials. For example, a Pack using `HeaderBearerToken` authentication is not allowed to pass any value in the `Authorization` header, even when `disableAuthentication: true` is set on the request. This behavior exists to help prevent abuse, specifically when the Pack tries to fetch user data and then send a copy to another account on the same service.\n\n",
    "Caching": "For performance reasons responses for HTTP `GET` requests are cached by default. See the [caching guide][caching] for more information.",
    "Rate limits {: #rate-limits}": "Making a request to an external API can be expensive, either due to quotas, computing resources, or monetary cost. To help prevent your code from making too many expensive API calls you can set up rate limits for your Pack. To configure these, open the Pack editor and click on **Settings** > **Add rate limits**.\n\n<img src=\"../../../images/rate_limits.png\" srcset=\"../../../images/rate_limits_2x.png 2x\" class=\"screenshot\" alt=\"Rate limit dialog.\">\n\nYou can set a total rate limit across all users of your Pack, or if your Pack uses [authentication][authentication] you can also set a per-user rate limit. When the limit is reached your formula will pause for a bit to see if more quota becomes available, and if not eventually fail with an error.",
    "Identifying requests": "HTTP requests originating from Packs can come from a few different IP addresses. You can query the current set of IP addresses by doing a DNS lookup on the domain `egress.coda.io`.\n\n```\ndig +short egress.coda.io\n```\n\nWhile we strive to keep the set of addresses consistent, they may be subject to change over time. As of {{today()}} they are:\n\n```\n{{ \"\\n\".join(resolveIps(\"egress.coda.io\")) }}\n```\n\nYou can also identify HTTP requests originating from Packs by the `User-Agent` header on the request, which will be set to `Coda-Server-Fetcher`.\n\n[Fetcher]: ../../reference/sdk/interfaces/core.Fetcher.md\n[samples]: ../../samples/topic/fetcher.md\n[addNetworkDomain]: ../../reference/sdk/classes/core.PackDefinitionBuilder.md#addnetworkdomain\n[support]: ../../support/index.md\n[support_network_domains]: ../../support/index.md#approvals\n[ExecutionContext]: ../../reference/sdk/interfaces/core.ExecutionContext.md\n[fetch]: ../../reference/sdk/interfaces/core.Fetcher.md#fetch\n[FetchRequest]: ../../reference/sdk/interfaces/core.FetchRequest.md\n[async_await]: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await\n[promises]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\n[fetchresponse]: ../../reference/sdk/interfaces/core.FetchResponse.md\n[xml2js]: https://www.npmjs.com/package/xml2js\n[status_code_error]: ../../reference/sdk/classes/core.StatusCodeError.md\n[buffer]: https://nodejs.org/api/buffer.html#buffer\n[withQueryParams]: ../../reference/sdk/functions/core.withQueryParams.md\n[stringify]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n[formula_cache]: ../blocks/formulas.md#caching\n[authentication]: ../basics/authentication/index.md\n[spec_headers]: https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n[baseauthentication_networkdomain]: ../../reference/sdk/interfaces/core.BaseAuthentication.md#networkdomain\n[auth_user]: ../basics/authentication/index.md#user\n[temporaryblobstorage]: ../../reference/sdk/interfaces/core.TemporaryBlobStorage.md\n[caching]: ../advanced/caching.md\n[npm_form_data]: https://www.npmjs.com/package/form-data\n[example_box]: https://github.com/coda/packs-examples/tree/main/examples/box\n[graphql]: https://graphql.org/\n[forceCache]: ../advanced/caching.md#forcecache\n\n[]\n\nnav: Autocomplete\ndescription: Simplify entering parameters by providing choices users can select from.\n\n[]"
  },
  "Autocomplete parameter options": {
    "Using autocomplete": "In the formula editor, parameter options show up in a the same pane used for the autocompletion of built-in elements of the Coda Formula Language. In the actions builder and sync table settings options are presented in a drop down.\n\n=== \"In the formula editor\"\n<img src=\"../../../../images/autocomplete_formula.png\" srcset=\"../../../../images/autocomplete_formula_2x.png 2x\" class=\"screenshot\" alt=\"Autocomplete in the formula editor\">\n=== \"In the action builder\"\n<img src=\"../../../../images/autocomplete_action.png\" srcset=\"../../../../images/autocomplete_action_2x.png 2x\" class=\"screenshot\" alt=\"Autocomplete in the action builder\">\n=== \"In the sync table settings\"\n<img src=\"../../../../images/autocomplete_sync.png\" srcset=\"../../../../images/autocomplete_sync_2x.png 2x\" class=\"screenshot\" alt=\"Autocomplete in the sync table settings\">",
    "Simple options": "The simplest way to set this up is to set the `autocomplete` property of the parameter to an array of valid options.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"animal\",\n  description: \"The selected animal.\",\n  autocomplete: [\"cow\", \"pig\", \"sheep\"]\n})\n```",
    "Custom labels": "If you want the options to have a different label you can provide an array of [`SimpleAutocompleteOption`][SimpleAutocompleteOption] objects, each containing a `display` and `value` property. The `display` label will be what's shown in the list of choices, but once they select a choice it will be replaced by the `value` which is what is passed into your `execute` function.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"animal\",\n  description: \"The selected animal.\",\n  autocomplete: [\n    { display: \"Friendly Cow\", value: \"cow\" },\n    { display: \"Messy Pig\", value: \"pig\" },\n    { display: \"Quiet Sheep\", value: \"sheep\" },\n  ],\n})\n```\n\nThe values can be either strings or numbers, and should match the type of the parameter.",
    "Dynamic options": "When the autocomplete options can't be known upfront you can instead use a function to generate them dynamically. Define an `autocomplete` function that returns an array of autocomplete objects, usually generated from the results of an API call. The function has access to the formula context (and fetcher) as well as the user's current input for the parameter, which you can use to filter the results. The helper function [`coda.autocompleteSearchObjects`][autocompleteSearchObjects] is useful for converting an API response into an array of [`SimpleAutocompleteOption`][SimpleAutocompleteOption] objects.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"gameId\",\n  description: \"The ID of the game on boardgameatlas.com\",\n  autocomplete: async function (context, search) {\n    let url = coda.withQueryParams(\n      \"https://api.boardgameatlas.com/api/search\",\n      { fuzzy_match: true, name: search });\n    let response = await context.fetcher.fetch({ method: \"GET\", url: url });\n    let results = response.body.games;\n    // Generate an array of autocomplete objects, using the game's name as the\n    // label and its ID for the value.\n    return coda.autocompleteSearchObjects(search, results, \"name\", \"id\");\n  },\n}),\n```",
    "Accessing previous parameter values {: #parameters}": "The `autocomplete` function also has access to the values entered for previous parameters. Unlike in the `execute` function where these are passed in as an array and accessed by position, in `autocomplete` functions they are passed as an object of key/value pairs and accessed by name.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"language\",\n  description: \"The language to use.\",\n  autocomplete: [\n    { display: \"English\", value: \"en\" },\n    { display: \"Spanish\", value: \"es\" },\n  ],\n}),\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"greeting\",\n  description: \"The greeting to use.\",\n  autocomplete: async function (context, search, {language}) {\n    let options;\n    if (language === \"es\") {\n      options = [\"Hola\", \"Buenos das\"];\n    } else {\n      options = [\"Hello\", \"Howdy\"];\n    }\n    return coda.simpleAutocomplete(search, options);\n  },\n}),\n```\n\n??? info \"Object destructuring\"\nIn the code above we used [object destructuring][destructuring_assignment] to pull values out of the parameters object and assign them to variables. You could alternatively do that within the body of the `autocomplete` function.\n\n```ts\nautocomplete: async function (context, search, parameters) {\n  let language = parameters.language;\n  // ...\n},\n```\n\n\n!!! warning \"Manual refresh required for `StringArray` parameters\"\nWhen using `StringArray` parameters in the builder UIs, the autocomplete values are only fetched once when the parameter UI is loaded. The autocomplete options can be manually refreshed by the user with a menu item, but this limitation doesn't make them a great fit for use cases where the options depend on the values of previous parameters. <!-- o/bug/25402 -->\n\n<img src=\"../../../../images/autocomplete_list_refresh.png\" srcset=\"../../../../images/autocomplete_list_refresh_2x.png 2x\" class=\"screenshot\" alt=\"Autocomplete of list parameters requires manual refresh\">\n\n\n!!! bug \"Previous vararg values not available\"\nWhen using [vararg parameters][parameters_vararg] in the builder UIs, the autocomplete function will not be able to access the values of previous vararg parameters. This means it isn't possible to build a set of key/value vararg parameters where the possible values depend on the key selected. <!-- o/bug/25373 -->",
    "Validation": "Users are not forced to select one of the provided autocomplete options and may instead enter their own custom value. If your formula logic requires that the user only select from the autocomplete options you will need to add code to validate the parameter value.\n\n```\nconst AnimalOptions = [\"cow\", \"pig\", \"sheep\"];\n\npack.addFormula({\n  // ...\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"animal\",\n      description: \"The selected animal.\",\n      autocomplete: AnimalOptions,\n    }),\n  ],\n  // ...\n  execute: async function([animal], context) {\n    if (!AnimalOptions.includes(animal)) {\n      throw new coda.UserVisibleError(\"Unknown animal: \" + animal);\n    }\n  }\n});\n```\n\n[samples]: ../../../samples/topic/autocomplete.md\n[destructuring_assignment]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n[SimpleAutocompleteOption]: ../../../reference/sdk/interfaces/core.SimpleAutocompleteOption.md\n[autocompleteSearchObjects]: ../../../reference/sdk/functions/core.autocompleteSearchObjects.md\n[parameters_vararg]: index.md#vararg\n\n[]\n\nnav: Parameters\ndescription: Define parameters on formulas and sync tables to accept values from the user.\n\n[]"
  },
  "Accept input with parameters": {
    "Using parameters": "In the formula editor parameters are entered as comma-separated values, while in the action dialog or sync table side panel they presented as input boxes.\n\n=== \"In the formula editor\"\n<img src=\"../../../images/parameter_formula.png\" srcset=\"../../../images/parameter_formula_2x.png 2x\" class=\"screenshot\" alt=\"Parameters in the formula editor\">\n=== \"In the action builder\"\n<img src=\"../../../images/parameter_action.png\" srcset=\"../../../images/parameter_action_2x.png 2x\" class=\"screenshot\" alt=\"Parameters in the action builder\">\n=== \"In the sync table settings\"\n<img src=\"../../../images/parameter_sync.png\" srcset=\"../../../images/parameter_sync_2x.png 2x\" class=\"screenshot\" alt=\"Parameters in the sync table settings\">",
    "Defining parameters": "The [`parameters`][parameters] property of a formula contains the array of parameter definitions, each one containing information about the parameter. The helper function [`makeParameter()`][makeParameter] is used to create these definitions, and a `type`, `name`, and `description` are required.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"type\",\n  description: \"The type of cookie.\",\n})\n```\n\nSee [`ParamDef`][ParamDef] for the full set of properties you can define for a parameter.",
    "Accessing parameter values": "At runtime, the values set by the user are passed to the formula's `execute` function as the first argument, bundled up as an array.\n\n```\npack.addFormula({\n  // ...\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"type\",\n      description: \"The type of cookie.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"num\",\n      description: \"How many cookies.\",\n    }),\n  ],\n  // ...\n  execute: async function ([type, num], context) {\n    // ...\n  },\n});\n```\n\nThe order that you define the parameters determines the order they are passed into the `execute` function. The names of the parameters don't need to match the variable names you use for them in the `execute` function, but it's usually more readable to keep them the same.\n\n??? \"Array destructuring\"\nIn the code above, and across our other samples, we typically use [array destructuring][destructuring_assignment] to pull values out of the parameter array and assign them to variables. You could alternatively do that within the body of the `execute` function:\n\n```ts\nexecute: async function (parameters, context) {\n  let word = parameters[0];\n  let count = parameters[1];\n},\n```\n\n",
    "Parameter types {: #types}": {
      "Plain text": "Use the `String` parameter to pass a plain text value to your formula. Coda will automatically apply the [`ToText()`][ToText] formula to the input and pass it to the `execute` function as a [JavaScript String][mdn_string].\n\nString parameters are compatible with almost every column type in Coda, as most have a text representation. At times a string parameter may be better than a more semantically accurate type, as it allows you to access the value as shown to the user.\n\n??? example \"Example: Hello world formula\"\n```ts\n--8<-- \"samples/packs/hello_world/minimal.ts\"\n```",
      "Rich text {: #rich}": "Use the `Html` or `Markdown` parameter type to pass text values with formatting included. Coda will convert the formatting to an equivalent block of HTML or Markdown markup, and pass it to the `execute` function as a [JavaScript String][mdn_string].\n\nThese parameter types don't provide perfect fidelity, and the converted HTML or Markdown may be quite different than how the value displays in Coda. Often it is closer to what you'd get if you pasted that value into another rich text editor.\n\n!!! warning \"HTML markup may change\"\nThe generated HTML for a given value is not a stable API surface that you should rely on. We may change it at any time without warning, so we don't recommend that you parse it to extract information. Use it for display purposes only.",
      "Numbers": "Use the `Number` parameter type to pass a number to your formula. Coda will automatically apply the [`ToNumber()`][ToNumber] formula to the input and pass it to the `execute` function as a [JavaScript Number][mdn_number].\n\nThe number equivalent for some column types may not be obvious. Specifically:\n\n['**Percent** values will be converted into the equivalent fraction. For example, \"75%\" will be passed as `0.75`.', '**Date** and **Date and time** values will be converted into the number of days since 1899-12-30[^1]. For example, \"1955-11-12\" will be passed as `20405`.', '**Time** and **Duration** values will be converted into a number of days. For example, \"12 hrs\" will be passed as `0.5`.']\n\n??? example \"Example: Pizza eaten formula\"\n```ts\n--8<-- \"samples/packs/data-type/pizza_eaten.ts\"\n```",
      "Booleans": "Use the `Boolean` parameter type to pass a boolean (true/false) to your formula. Coda will pass the value to the `execute` function as a [JavaScript Boolean][mdn_boolean].",
      "Dates {: #dates}": "Use the `Date` parameter type to pass a date value to your formula. Coda will automatically apply the [`ToDateTime()`][ToDateTime] formula to the input and pass it to the `execute` function as a [JavaScript Date][mdn_date].\n\nJavaScript Date objects can only represent a specific moment in time. This means that they can't easily represent less specific concepts like a day (regardless of time), a time (regardless of day), or duration. Coda handles those column types using the following logic:\n\n[\"**Date** values will be converted into a datetime representing midnight on that day in the document's timezone.\", '**Time** and **Duration** values will be converted a datetime that is that much time past midnight on 1899-12-30[^1], in the document\\'s timezone. For example, the duration \"12 hours\" in a document set to \"America/New York\" will be passed as `Sat Dec 30 1899 12:00:00 GMT-0500 (Eastern Standard Time)`.']\n\n!!! warning \"Timezone shifting\"\nBecause of how timezones work in Coda and JavaScript, the date passed into the parameter may appear different in your Pack code. See the [Timezones guide][timezones] for more information.\n\n??? example \"Example: Good New Years Eve glasses formula\"\n```ts\n--8<-- \"samples/packs/dates/nye_glasses.ts\"\n```",
      "Images and files {: #images}": "Use the `Image` parameter type to pass an image to your formula, and the `File` type for files. The value passed to the `execute` function will be the URL of that image or file.\n\nImages and files that the user uploaded to the doc will be hosted on the `codahosted.io` domain and don't require authentication to access. These URLs are temporary, and you should not rely on them being accessible after the Pack execution has completed.\n\nIf you need access to the binary content of the image or file you'll need to use the [fetcher][fetcher_binary_response] to retrieve it. The fetcher is automatically allowed access to the `codahosted.io` domain, so no need to declare it as a [network domain][network_domains]. It's not possible to access the binary content of images coming from an **Image URL** column, since they can come from any domain.\n\n??? example \"Example: Image file size formula\"\n```ts\n--8<-- \"samples/packs/image/file_size.ts\"\n```\n\n??? tip \"Get the original filename\"\n\nThe original filename of an uploaded image or file can be obtained from the `Content-Disposition` header returned when fetching its `codahosted.io` URL.\n\n```\nContent-Disposition: attachment; filename=\"cat1.png\"\n```\n\nThis filename is not populated in all cases, for instance when an image was pasted into a table from the clipboard. You can see an example of how to parse this header, and fallback in cases where the filename isn't present, in the [Box sample Pack][examples_box_filename].\n\n",
      "Lists": "Each of the parameter types described above has an array variant that allows you to pass a list of values of that type. For example, `StringArray` and `NumberArray`. All of the values in the list must be of the same type and not blank.\n\n??? example \"Example: Longest string formula\"\n```ts\n--8<-- \"samples/packs/parameter/longest.ts\"\n```",
      "Table column": "Passing a table column into an array parameter can be error prone, because if the column contains blank cells the formula will fail to run. To accept a list that may include blank values use the sparse variant of the array parameter (`SparseStringArray`, `SparseNumberArray`, etc). Blank cells will be represented as `null`, and you'll need to make sure your code can handle those values.\n\n??? example \"Example: Total cost formula\"\n```ts\n--8<-- \"samples/packs/parameter/total_cost.ts\"\n```",
      "Pages": "Coda documents can contain many pages, and it's possible to pass the contents of a page to a Coda formula using the `Html` parameter type. Users will be presented with the pages they can select from in the autocomplete options, and once selected the formula will receive an HTML version of that page's content. Some features of the page may not be included in the HTML markup, and it should not be considered a complete or stable API surface.\n\n!!! warning \"Formulas not recalculated when page content changes\"\nUnlike with other data sources, when passing a page as a parameter the formula will not be automatically recalculated when the content of the page changes. For this reason we recommend only passing pages for action formulas, which are calculated on each button press or automation run.",
      "Objects": "Pack formulas can return structured data as [Objects][data_types_objects], but it's not possible to pass them as parameters. Users can't construct objects in the Coda formula language, so in general they don't make for a great input type.\n\nIf your Pack returns an object in one formula that you'd like to use an input to another formula, instead of passing the entire object you can just pass its unique ID. For example, the [Todoist Pack][samples_todoist] contains a `Tasks` sync table which returns `Task` objects. The `MarkAsComplete()` formula only takes the task's ID as input instead of the entire object."
    },
    "Optional parameters": "By default all parameters you define are required. To make a parameter optional simply add `optional: true` to your parameter definition. Optional parameters are shown to the user but not required in order for the formula to execute.  Optional parameters must be defined after all of the required parameters, and like required parameters their order is reflected in the Coda formula editor and the array of values passed to the `execute` function.\n\n```\npack.addFormula({\n  name: \"TotalCost\",\n  // ...\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"cost\",\n      description: \"The cost of the item.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many items.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"taxRate\",\n      description: \"The tax rate for the item.\",\n      optional: true,\n    }),\n  ],\n  // ...\n  execute: async function ([cost, quantity, taxRate], context) {\n    // ...\n  },\n});\n```\n\nOptional parameters that have not been set by the user will default to the JavaScript value `undefined` in your `execute` function. When you initialize your parameter variables in the `execute` function you can assign a default value that will get used when the parameter has not been explicitly set by the user.\n\n```\npack.addFormula({\n  // ...\n  execute: async function ([cost, quantity = 1, taxRate = 0], context) {\n    // ...\n  },\n});\n```\n\nWhen using a formula with optional parameters, the user may choose to set those parameters by name, instead of by position. This can be useful when they want to skip over some optional parameters that appear earlier in the list.\n\n```\nTotalCost(10, taxRate: 0.15)\n```\n\nIn this case the `cost` and `taxRate` parameters would be set, but the `quantity` parameter would be undefined, and therefore use its default value of `1`.\n\n??? example \"Example: Scream text formula\"\n```ts\n--8<-- \"samples/packs/parameter/scream.ts\"\n```",
    "Suggested values {: #suggested}": "As a convenience to users of your Pack, you can provide a suggested value for a parameter. When they use your formula the default will be pre-populated in the formula editor, action dialog, etc. The user is then free to edit or replace it this value.\n\nTo add a suggested value to a parameter set the field `suggestedValue` to the value you'd like to use. The suggested value must be of the same type as the parameter, for example a number parameter must have a number as its suggested default value.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.Number,\n  name: \"days\",\n  description: \"How many days of data to fetch.\",\n  suggestedValue: 30,\n})\n```\n\nCurrently suggested values are only used for required parameters, and setting them for optional parameters has no effect.\n\n??? example \"Example: Random dice roll action\"\n```ts\n--8<-- \"samples/packs/action/dice.ts\"\n```",
    "Accepting multiple values {: #vararg}": "For some formulas you may want to allow the user to enter multiple values for a parameter. You could use an array parameter for this case but a more user-friendly approach may be to use variable argument (vararg) parameters. These are parameters that you allow the user to repeat as many times as needed.\n\n```\nFoo(List(\"A\", \"B\", \"C\"))  # A string array parameter.\nFoo(\"A\", \"B\", \"C\")        # A string variable argument parameter.\n```\n\nThey are defined using the `varargParameters` property and accept the same parameter objects. The values set by the user are passed in to the `execute` just like normal parameters, only there is an unknown number of them. The easiest way to access them is by using [JavaScript's \"rest\" syntax][mdn_rest], which captures the remaining values into an array.\n\n```\npack.addFormula({\n  // ...\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The person's name.\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"nickname\",\n      description: \"A nickname for the person.\",\n    }),\n  ],\n  // ...\n  execute: async function ([name, ...nicknames], context) {\n    // ...\n  },\n});\n```\n\nThere are some important differences between vararg parameters and standard parameters:\n\n['They appear at the end of the formula, after all standard parameters.', 'Unlike standard parameters they are optional by default, and cannot by made required.', \"You can't provide a default value, since the user must always enter an explicit value.\", 'You can have more than one, but if so the user is required to enter complete sets of values. For example, if you have two vararg parameters `a` and `b`, the user can\\'t provide a value for `a` without also providing a value for `b`. These pairs of parameters can then be repeated multiple times: `Foo(\"a1\", \"b1\", \"a2\", \"b2\")`.']\n\n??? info \"Partially supported in actions builder or sync table settings\"\n\nWhile vararg parameters always work in the formula editor, they are only partially supported in the builder UIs. A single vararg parameter will be shown as if it was a single array parameter, and a pair of vararg parameters will be shown with a nice UI similar to that used by built-in actions. Three or more vararg parameters wont show up in the builder UIs at all, and the user will need to visit the formula editor to set their values. <!-- go/bug/20828 -->\n\n\n??? example \"Example: Step diagram formula\"\n```ts\n--8<-- \"samples/packs/parameter/steps.ts\"\n```",
    "Autocomplete": "If you have a parameter that accepts a limited set of values it's usually best to provide those options using autocomplete. See the [Autocomplete guide][autocomplete] for more information.",
    "Reusing parameters": "It's often the case that many formulas in a Pack use the same parameter. For example, the [Google Calendar Pack][calendar_pack] has many formulas have a parameter for the calendar to operate on. Rather than redefine the same parameter for each formula, it can be more efficient to define the shared parameter once outside of a formula and then reuse it multiple times.\n\n```\nconst ProjectParam = coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"projectId\",\n  description: \"The ID of the project.\",\n});\n\npack.addFormula({\n  name: \"Project\",\n  description: \"Get a project.\",\n  parameters: [\n    ProjectParam,\n  ],\n  // ...\n});\n\npack.addFormula({\n  name: \"Task\",\n  description: \"Get a task within a project.\",\n  parameters: [\n    ProjectParam,\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task.\",\n    }),\n  ],\n  // ...\n});\n```\n\n??? example \"Example: Math formulas\"\n```ts\n--8<-- \"samples/packs/math/math.ts\"\n```",
    "Date range parameters": "Parameters of the type `DateArray` are often used for date ranges, with the first date representing the start of the range and the second date representing the end. When a `DateArray` parameter is used in an action or sync table the the input box displays a date range picker to make it easier for the user to select a range.\n\n<img src=\"../../../images/parameter_daterange.png\" srcset=\"../../../images/parameter_daterange_2x.png 2x\" class=\"screenshot\" alt=\"Date array parameters displayed as a date range picker\">\n\nThese parameters also support a special set of [suggested values](#suggested) that represent date ranges relative to the current date. These are available in the [`PrecannedDateRange`][PrecannedDateRange] enumeration.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.DateArray,\n  name: \"dateRange\",\n  description: \"The date range over which data should be fetched.\",\n  suggestedValue: coda.PrecannedDateRange.Last30Days,\n})\n```",
    "Recommended parameter types": "The table below shows the recommended parameter type to use with various types of Coda columns and values.\n\n| Type          | Supported | Recommended   | Notes                                                            |\n| ------------- | --------- | ------------- | ---------------------------------------------------------------- |\n| Text          |  Yes    | `String`      | Use `Html` or `Markdown` if the formatting is important.         |\n| Link          |  Yes    | `String`      |                                                                  |\n| Canvas        |  Yes    | `Html`        | Use `String` to discard formatting.                              |\n| Select list   |  Yes    | `StringArray` | Works for both single and multi-value select lists.              |\n| Number        |  Yes    | `Number`      |                                                                  |\n| Percent       |  Yes    | `Number`      | Passed as a fraction.                                            |\n| Currency      |  Yes    | `Number`      | Use `String` to get currency symbol.                             |\n| Slider        |  Yes    | `Number`      |                                                                  |\n| Scale         |  Yes    | `Number`      |                                                                  |\n| Date          |  Yes    | `Date`        |                                                                  |\n| Time          |  Yes    | `Date`        |                                                                  |\n| Date and time |  Yes    | `Date`        |                                                                  |\n| Duration      |  Yes    | `Number`      |                                                                  |\n| Checkbox      |  Yes    | `Boolean`     |                                                                  |\n| People        |  No     |               | Use `String` to get the person's name.                           |\n| Email         |  Yes    | `String`      |                                                                  |\n| Reaction      |  No     |               | Use `StringArray` to get the names of the people that reacted.   |\n| Button        |  No     |               |                                                                  |\n| Image         |  Yes    | `ImageArray`  | Image column can contain multiple images.                        |\n| Image URL     |  Yes    | `Image`       |                                                                  |\n| File          |  Yes    | `FileArray`   | File columns can contain multiple files.                         |\n| Relation      |  No     |               | Use `StringArray` to get the display name of the row(s).         |\n| Table         |  No     |               | You can't pass an entire table, pass individual columns instead. |\n| Page          |  Yes    | `Html`        |                                                                  |\n\n[^1]: The representation is known as [\"serial number\"][serial_number] and is common to all major spreadsheet applications.\n\n[samples]: ../../../samples/topic/parameter.md\n[parameters]: ../../../reference/sdk/interfaces/core.PackFormulaDef.md#parameters\n[makeParameter]: ../../../reference/sdk/functions/core.makeParameter.md\n[ParamDef]: ../../../reference/sdk/interfaces/core.ParamDef.md\n[destructuring_assignment]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n[mdn_rest]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#assigning_the_rest_of_an_array_to_a_variable\n[autocomplete]: autocomplete.md\n[PrecannedDateRange]: ../../../reference/sdk/enums/core.PrecannedDateRange.md\n[calendar_pack]: https://coda.io/packs/google-calendar-1003/documentation\n[ParameterType]: ../../../reference/sdk/enums/core.ParameterType.md\n[ToText]: https://coda.io/formulas#ToText\n[ToNumber]: https://coda.io/formulas#ToNumber\n[ToDateTime]: https://coda.io/formulas#ToDateTime\n[mdn_string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n[mdn_number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\n[mdn_boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean\n[mdn_date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n[serial_number]: http://www.cpearson.com/excel/datetime.htm\n[unix_epoch]: https://en.wikipedia.org/wiki/Unix_time\n[timezones]: ../../advanced/timezones.md\n[data_types_objects]: ../../basics/data-types.md#objects\n[samples_todoist]: ../../../samples/full/todoist.md\n[fetcher_binary_response]: ../../basics/fetcher.md#binary-response\n[network_domains]: ../../basics/fetcher.md#network-domains\n[examples_box_filename]: https://github.com/coda/packs-examples/blob/c565981293f14a4ca82bc2ddcf385ea9c7bbbad6/examples/box/helpers.ts#L31-L52\n\n[]\n\ndescription: Tips and checklists on how to create high quality Packs."
  },
  "Best practices": {
    "Formulas": [
      "[x] Follow the guidance on [formula naming][formulas_naming].",
      "[x] Ensure each formula has a few [examples defined][formulas_examples]. These show up in the generated documentation for the formula.",
      "[x] Set a [suggested value][parameter_suggested_value] for required parameters. This allows users to drag the formula from the side panel and see a result immediately.",
      "[x] For each formula that has only a single required parameter, consider exposing it as a [column format][column_formats]. This makes it easier for users to use the functionality in a table.",
      "[x] Consider the [caching behavior][formulas_caching] of your formulas. Use longer cache times for formulas where the results are deterministic, and shorter cache times for ones that fetch external data."
    ],
    "Actions": [
      "[x] Follow the guidance on [action naming][actions_naming].",
      "[x] Ensure each action formula [returns a result][actions_result]. This allows the doc to react to the action being completed."
    ],
    "Column formats": [
      "[x] Follow the guidance on [column format naming][column_formats_naming].",
      "[x] For column formats that use a URL as input, [add a matcher pattern][column_formats_matchers]. This allows Coda to apply the format automatically when a user adds a compatible URL to a table."
    ],
    "Sync tables": [
      "[x] Follow the guidance on [sync table naming][sync_tables_naming].",
      "[x] Set the [`description`][SyncTableOptions.description] field for each sync table. The description is shown on the Pack's listing page and helps a user understand what data it retrieves.",
      "[x] [Add parameters][sync_tables_parameters] to sync tables to allow for filtering. Filtering is particularly important when a table can return a large number of rows.",
      "[x] Consider the [caching behavior][sync_tables_caching] of your sync tables. Most fetcher requests should have their caching reduced or disabled to ensure the latest results are synced.",
      "[x] Set a few [featured columns][schemas_featured_columns] on your schema, for the most commonly used properties."
    ],
    "Dynamic sync tables": [
      "[x] Add a [`searchDynamicUrls`][dyanmic_sync_tables_search] function to allow users to search for their desired dataset, if the underlying API supports it."
    ],
    "Authentication": [
      "[x] Set a meaningful [account name][auth_name] by implementing the `getConnectionName` function. This helps users that connect to multiple accounts distinguish them.",
      "[x] Make sure to set the [`instructionsUrl`][instructionsUrl] field. Direct user to a help center article that provides information about where they can find the required tokens or credentials."
    ],
    "General": [
      "[x] Throw a [`UserVisibleError`][UserVisibleError] for bad input or when an expected type of error occurs. This allows you to provide a more informative error message to the user.",
      "[x] If accepting or returning an index value, start counting at 1. Although JavaScript is 0-based, Coda formula language is 1-based."
    ],
    "Launching": [
      "[x] Follow the recommendations in the [Best Practices for Launching your Pack][launching] guide.",
      "[x] Learn about [Promotion Best Practices][promotion]."
    ]
  },
  "Add custom actions for buttons and automations": {
    "Using actions": "Actions provided by Packs appear as choices in the button and automation dialogs along-side built-in actions. Actions can also be used in the formula editor for those buttons and automations.\n\n=== \"In a button\"\n<img src=\"../../../images/actions_button.png\" srcset=\"../../../images/actions_button_2x.png 2x\" class=\"screenshot\" alt=\"Selecting an action for a button\">\n=== \"In an automation\"\n<img src=\"../../../images/actions_automation.png\" srcset=\"../../../images/actions_automation_2x.png 2x\" class=\"screenshot\" alt=\"Selecting an action for an automation\">\n=== \"In the formula editor\"\n<img src=\"../../../images/actions_formula.png\" srcset=\"../../../images/actions_formula_2x.png 2x\" class=\"screenshot\" alt=\"Using actions in the formula editor.\">",
    "Creating actions": "Actions are just a special type of formula, and to create an action simply add a formula to your Pack with the property `isAction: true`.\n\n```\npack.addFormula({\n  name: \"DoSomething\",\n  description: \"Does something neat.\",\n  isAction: true,\n  execute: async function ([], context) {\n    // ...\n  },\n});\n```\n\nIf you aren't already familiar with creating formulas, read the [Formulas guide][formulas] first. The rest of this guide will clarify how action formulas differ from calculation formulas.",
    "Naming": "Like all formulas, action formula names can only contain letters, numbers, and underscores. We also recommend following these conventions:\n\n['Select a verb-noun pair that corresponds to the corresponding action and target of the action. For example, `DeleteFile` or `AddTask`.<br>\\n{: .yes}', 'If you Pack primarily works with a single type of item, you may omit the noun. For example, `Tweet` or `MarkComplete`.<br>\\n{: .yes}', 'For multiple words, use upper camel case. For example, `SendEmail` or `CreateBugReport`.\\n{: .yes}', \"Don't include the Pack name in the name of the column format. For example, use `CreateTask` instead of `CreateTodoistTask`.\\n{: .no}\"]\n\n!!! warning\nChanging the name of an action formula will break any existing docs that use it. When creating your Pack select your names carefully.",
    "Parameters": "Parameters in actions work the same as they do in other formulas, but may appear differently depending on the context. The button and automation configuration dialogs by default will present the parameters as input boxes, although the user has the option to switch the formula editor as well. See the [Parameters guide][parameters] for more information and examples.",
    "Results": "Although actions are typically used to send data rather than calculate a value, like all formulas they are required to return a result. When the action is used by a button in a table column, the result can be stored in another column of the same table. This allows other formulas or conditional formatting to check that column and know when the action is complete.\n\nIf your action is creating an item in an external API you could return the URL or ID of the new item.\n\n```\npack.addFormula({\n  name: \"AddThing\",\n  description: \"Add a new thing.\",\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([], context) {\n    let response = await context.fetcher.fetch({ method: \"POST\", url: \"...\" });\n    // Return values are optional but recommended. Returning a URL or other\n    // unique identifier is recommended when creating a new entity.\n    return response.body.url;\n  },\n});\n```\n\nIn some cases there is no meaningful result, in which case the convention is to return the string \"OK\". See the [Data types guide][data-types] for more information on the type of values that can be returned.",
    "Authentication": "Actions can use authentication to access private resources, but unlike other formulas they aren't required to always use a specific user account. For actions, the account parameter will include the special option \"User's private account\". When this option is selected, each user that presses the button will take the action using one of their connected accounts, or be prompted to create an account if they don't have one set up already.\n\n<img src=\"../../../images/actions_private_account.png\" srcset=\"../../../images/actions_private_account_2x.png 2x\" class=\"screenshot\" alt=\"Private account option for actions\">",
    "Caching & recalculation": "Unlike other formulas, actions are never cached or automatically recalculated. The action is only run when the button is pressed or automation triggered, and the code is run each time, even if the inputs haven't changed.",
    "Update sync table rows {:#sync}": {
      "Handling dynamic schemas {: #dynamic-schemas}": "Action formulas must declare the schema of the object they return, which presents a challenge when trying to update rows in sync tables that use the `getSchema` method to [dynamically generate their schemas][getSchema]. It's possible to work around this incompatibility however, as long as there is a predictable `idProperty` for the dynamic schema.\n\nCreate a \"base schema\" for your action formula to use, which at a minimum includes an `idProperty` (and the corresponding property definition). Additionally, set the schema field [`includeUnknownProperties`][includeUnknownProperties] to true. This tells Coda not to strip out extra data in the response that doesn't match a defined property, allowing it to flow through to the sync table.\n\n```\nconst BaseTaskSchema = coda.makeObjectSchema({\n  properties: {\n    id: { type: coda.ValueType.String },\n  },\n  idProperty: \"id\",\n  includeUnknownProperties: true,\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: BaseTaskSchema,\n  identityName: \"Task\",\n  dynamicOptions: {\n    getSchema: async function (context) {\n      // Extend BaseTaskSchema with additional properties.\n    },\n  },\n  // ...\n});\n\npack.addFormula({\n  name: \"UpdateTask\",\n  // ...\n  resultType: coda.ValueType.Object,\n  schema: coda.withIdentity(BaseTaskSchema, \"Task\"),\n  isAction: true,\n  execute: async function ([taskId, name], context) {\n    let task = updateTask(taskId, name, context);\n    // Return the updated task, which can include values corresponding to the\n    // dynamic properties.\n    return task;\n  },\n});\n```\n\n!!! warning \"Remove unused fields\"\nWhen you enable the `includeUnknownProperties` feature, all of the data returned by the formula or sync table ends up in the object chip, even when it doesn't match any schema property in the sync table. Only the fields corresponding to properties will be available to \"dot\" into in the Coda formula language however. You should therefore remove any data from the API response that you don't intend the user to see.",
      "Handling dynamic URLs": "Dynamic sync tables have dynamic schemas, and therefore need to use the technique [described above](#dynamic-schemas) to update their rows from an action. However they have the additional complication that they are not uniquely identified by an `identityName` alone, but in combination with their specific dynamic URL. While it is possible to set the `identity.dynamicUrl` field of the schema, hardcoding it to a specific URL isn't likely to be useful.\n\nWhile there is no solution for the general case, there is for the common case where a button appears in a column of the same table. As long as the `identity.name` of the schema matches that of the dynamic sync table containing the button, the dynamic URL will be automatically populated and the row update will work. Using that same action elsewhere in the doc however will not update the existing row.\n\n[help_buttons]: https://help.coda.io/en/articles/2033889-overview-of-buttons\n[help_automations]: https://help.coda.io/en/articles/2423860-automations-in-coda\n[fetcher]: ../basics/fetcher.md\n[samples]: ../../samples/topic/action.md\n[formulas]: formulas.md\n[parameters]: ../basics/parameters/index.md\n[data-types]: ../basics/data-types.md\n[sync_table]: sync-tables/index.md\n[schemas]: ../advanced/schemas.md\n[two_way_sync]: ../advanced/two-way-sync.md\n[data_type_object]: ../basics/data-types.md#objects\n[getSchema]: ../blocks/sync-tables/dynamic.md#get-schema\n[includeUnknownProperties]: ../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#includeunknownproperties\n[samples_action_todoist]: ../../samples/topic/action.md#update-row-in-sync-table\n\n[]\n\nnav: Cards\ndescription: Display structured information as rich cards.\n\n[]"
    }
  },
  "Preview content with rich cards": {
    "Using cards": "Cards are shown as distinct type of building block, but any formula returning a compatible object can be displayed as a card. It will also be shown as an option for [matching links](#display).\n\n=== \"Pack side panel\"\n<img src=\"../../../images/cards_use_side_panel.png\" srcset=\"../../../images/cards_use_side_panel_2x.png 2x\" class=\"screenshot\" alt=\"Cards shown in the Pack side panel\">\n=== \"Object menu\"\n<img src=\"../../../images/cards_use_display_as.png\" srcset=\"../../../images/cards_use_display_as_2x.png 2x\" class=\"screenshot\" alt=\"Changing a mention to show as a card in the display as menu\">\n=== \"Link menu\"\n<img src=\"../../../images/cards_link_installed.png\" srcset=\"../../../images/cards_link_installed_2x.png 2x\" class=\"screenshot\" alt=\"Changing a mention to show as a card in the display as menu\">\n=== \"Link menu (Pack not installed)\"\n<img src=\"../../../images/cards_link_prompt.png\" srcset=\"../../../images/cards_link_prompt_2x.png 2x\" class=\"screenshot\" alt=\"Changing a mention to show as a card in the display as menu\">",
    "Creating cards": {
      "Title": "The card's title appears at the top of the card, and is required.\n\n<img src=\"../../../images/cards_parts_title.png\" srcset=\"../../../images/cards_parts_title_2x.png 2x\" alt=\"The card's title\">\n\nMany object schemas already define a [display value][schemas_display_value] (via `displayProperty`) which determines which property value is shown in the mention chip for the object. The same display value will be shown as the title of the card, but can be overridden by defining a `titleProperty`. This is useful if you want to use a different property specifically for cards, for example that is longer.\n\n```\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    sku: { type: coda.ValueType.String },\n    name: { type: coda.ValueType.String },\n    // ...\n  },\n  // Use the SKU in mention chips, to save space.\n  displayProperty: \"sku\",\n  // Display the full product name in cards.\n  titleProperty: \"name\",\n  // ...\n});\n```",
      "Subtitles": "The card can include a subtitle that highlights key properties, which appears under the title.\n\n<img src=\"../../../images/cards_parts_subtitle.png\" srcset=\"../../../images/cards_parts_subtitle_2x.png 2x\" alt=\"The card's subtitle\">\n\nThe properties displayed in the subtitle are determined via the `subtitleProperties` field of the schema, which lists the subset of properties to show and the order to show them.\n\n```\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    quantity: { type: coda.ValueType.Number },\n    price: {\n      type: coda.ValueType.Number,\n      codaType: coda.ValueHintType.Currency,\n    },\n  },\n  // ...\n  subtitleProperties: [\"quantity\", \"price\"],\n});\n```\n\nIf `subtitleProperties` are not defined the card will fall back to using the `featuredProperties` configured on the schema, if any. Featured properties are also used to determine the initial columns to show in a sync table. If you want a schema to include `featuredProperties` but not display a subtitle, set `subtitleProperties` to an empty array.\n\nThe subtitle shows a label for each property, which defaults to `{Name}: {Value}`. You can customize the label for a property, such as removing the property name, in the property definition. See the [Schemas guide][schemas_property_labels] for more information.",
      "Body": "The card body can include a snippet of content, which appears under the title (and subtitle if defined).\n\n<img src=\"../../../images/cards_parts_snippet.png\" srcset=\"../../../images/cards_parts_snippet_2x.png 2x\" alt=\"The card's body\">\n\nThe snippet is meant to contain a limited amount of text, although there is no size limit enforced. Which property's content to use for the snippet is defined by the field `snippetProperty`, and it can only refer to properties of type `String` or `Array` of `String`. These properties can contain rich text, such as [Markdown][data_types_markdown] and [HTML][data_types_html].\n\n```\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    description: { type: coda.ValueType.String },\n  },\n  // ...\n  snippetProperty: \"description\",\n});\n```",
      "Image": "The card can include an image, which appears to the left of the other content.\n\n<img src=\"../../../images/cards_parts_image.png\" srcset=\"../../../images/cards_parts_image_2x.png 2x\" alt=\"The card's image\">\n\nWhich property's content to use for the image is defined by the field `imageProperty`, and it can only refer to properties of type `String` with a hint of  `ImageReference`.\n\n<!-- TODO(spencer): Include ImageAttachment above once the post-processing work is complete. -->\n\n```\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    photo: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n  },\n  // ...\n  imageProperty: \"photo\",\n});\n```\n\n!!! info \"Creating custom images\"\nImages can make cards much more appealing, but sometimes the API you are calling does not include a relevant image for the resource. In those cases you can add a custom image to the object, for example a generic icon. [SVG data URIs][images_svg] can be a simple way to serve those images without needing a separate server to host them.",
      "Link": "The card can include a link, which will be opened when the card is clicked. The domain of the link is also shown at the bottom of the card.\n\n<img src=\"../../../images/cards_parts_link.png\" srcset=\"../../../images/cards_parts_link_2x.png 2x\" alt=\"The card's link\">\n\nWhich property's content to use for the link is defined by the field `linkProperty`, and it can only refer to properties of type `String` with a hint of `Url`.\n\n```\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    websiteLink: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n  },\n  // ...\n  linkProperty: \"websiteLink\",\n});\n```"
    },
    "Display a link as a card {: #display}": "One of the most common uses for cards is to display information about an item from an external application, usually identified by a URL. For example, the Slack Pack's contains a `Message` card takes in a message URL and displays the text, author, etc.\n\nTo make it easier to discover these cards, when a user pastes a link into a doc Coda will show a list of compatible Packs. Clicking one of these will install the Pack and display the link as a card.\n\n<img src=\"../../../images/cards_link_prompt.png\" srcset=\"../../../images/cards_link_prompt_2x.png 2x\" class=\"screenshot\" alt=\"Dialog showing cards that can be used to display a link\">\n\n!!! info \"Built-in card option\"\nThe link \"Display as\" menu may include an option for \"Card\", which displays a fix set of metadata for public URLs. This is distinct from Pack cards, which are shown as additional options below that.\n\nCoda will automatically display a link as a card if it matches a Pack already installed in the doc, or for certain Coda-made Packs.\n\nTo enable this feature for your Pack, add a [column format][column_format] pointing to a formula that accepts a URL and returns a card. Then add [`matchers`][column_format_matchers] (regular expressions) to the column format that determine which URLs the the prompt should appear on.\n\n```\npack.addFormula({\n  name: \"Product\",\n  description: \"...\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"...\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProductSchema,\n  // ...\n});\n\npack.addColumnFormat({\n  name: \"Product\",\n  formulaName: \"Product\",\n  matchers: [\n    new RegExp(\"^https://example.com/products/[A-Z0-9]+$\"),\n  ],\n});\n```\n\n!!! info \"Table behavior\"\nFormulas and column formats that return a card can be used in a table, but currently the resulting object can only be shown as a mention.\n\n??? example \"Example: Todoist task card\"\n```ts\n--8<-- \"samples/packs/todoist/card.ts\"\n```\n\n[formulas]: formulas.md\n[schemas_object]: ../advanced/schemas.md#object\n[schemas_display_value]: ../advanced/schemas.md#display-value\n[schemas_featured_columns]: ../advanced/schemas.md#featured-columns\n[schemas_property_labels]: ../advanced/schemas.md#property-labels\n[data_types_markdown]: ../basics/data-types.md#markdown\n[data_types_html]: ../basics/data-types.md#html\n[column_format]: column-formats.md\n[column_format_matchers]: column-formats.md#matchers\n[data_types_objects]: ../basics/data-types.md#objects\n[samples]: ../../samples/topic/card.md\n[images_svg]: ../advanced/images.md#svg-images\n\n[]\n\nnav: Column formats\ndescription: Automatically apply a formula to a user's input to display it in a different format.\n\n[]"
  },
  "Add custom column formats": {
    "Using column formats": "Column formats provided by Packs appear as choices in the **Column type** menu.\n\n<img src=\"../../../images/column_format_menu.png\" srcset=\"../../../images/column_format_menu_2x.png 2x\" class=\"screenshot\" alt=\"Pack column formats in the column type menu\">",
    "Creating column formats": "A column format is just a thin wrapper around an existing formula in your Pack, instructing Coda to run that formula on the column values before rendering them. The column format itself is just metadata, deferring the actual work of calculating the column value to the formula.\n\n```\npack.addColumnFormat({\n  name: \"Reversed Text\",\n  instructions: \"Whatever text you enter into this column will be reversed.\",\n  // The formula specified below will be run on the content of the column to\n  // determine it's display value. The formula must be defined within the same\n  // Pack.\n  formulaName: \"Reverse\",\n});\n\npack.addFormula({\n  name: \"Reverse\",\n  // ...\n});\n```\n\nIf you aren't already familiar with creating formulas, read the [Formulas guide][formulas] first.\n\n!!! warning\nChanging the formula used by the column format will break any existing docs that use it.",
    "Naming": "Unlike other building blocks, column format names can include spaces and special characters. We recommend following these conventions:\n\n['Select a singular noun corresponding the output in the cell. For example, `Task` or `Event`.\\n{: .yes}', 'For multiple words, use spaces and title case. For example, `Progress Bar` or `Reversed Text`.\\n{: .yes}', \"Don't include the Pack name in the name of the column format. For example, use `Task` instead of `TodoistTask`.\\n{: .no}\"]\n\n!!! info\nYou can change the name of the column format without breaking existing docs that use it.",
    "Parameters": "When the column format is applied to a cell, the value of the cell will be passed as the first parameter to the specified formula. The formula can have additional parameters defined, but they must be optional as they won't have a value passed.\n\nUsers can only enter text into the cell, but Coda will attempt to coerce them into the type of the first parameter. For example, if your column format formula accepts a `Date` parameter, the user can enter the date as a string and Coda will parse that string into a `Date` object and pass that to your formula.",
    "Results": "Column formats can return any supported data type, and it will become the effective type for that column. When the cell is being edited, or if there is an error applying the column format, the underlying string value will be shown instead. See the [Data types guide][data-types] for more information on the type of values that can be returned.",
    "Authentication": "Column formats can use authentication to access private resources. The account used by the column format is configured within the options menu of the column.\n\n<img src=\"../../../images/column_format_options.png\" srcset=\"../../../images/column_format_options_2x.png 2x\" class=\"screenshot\" alt=\"Selecting the account in the column format options\">",
    "Automatic formatting {: #matchers}": "When creating a new column, Coda tries to guess the type of the column based on the first data entered. Column formats from Packs can be included in this process by declaring matchers. Matchers are [regular expressions][mdn_regex] that define which cell values the column format should be applied to. If one of the regular expressions matches the cell value the column format will be applied automatically.\n\n```\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"Task\",\n  // If the first values entered into a new column match these patterns then\n  // this column format will be automatically applied.\n  matchers: [\n    new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n    new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n  ],\n});\n```\n\nCurrently only URL patterns are fully supported, and the Pack must declare a corresponding [network domain][fetcher_network_domain].\n\nOnly Packs already installed in the document will have their matchers used. If multiple column formats both match the cell input then Coda will choose one arbitrarily. If the user doesn't want to use the column format they can manually change it afterwords.",
    "Link formatting": "If your column format has [matchers](#matchers) defined it can also affect how links are displayed on the canvas. When editing the display settings for a link, if it matches a column format there will be a new option to display it using the Pack.\n\n<img src=\"../../../images/column_format_canvas.png\" srcset=\"../../../images/column_format_canvas_2x.png 2x\" class=\"screenshot\" alt=\"Selecting the account in the column format options\">\n\nWhen selected, this will wrap the link in a call to the formula that backs the column format. For example, using the Todoist column format above, a Todoist URL would be wrapped in a `=Task()` formula.\n\n[samples]: ../../samples/topic/column-format.md\n[formulas]: formulas.md\n[parameters]: ../basics/parameters/index.md\n[data-types]: ../basics/data-types.md\n[mdn_regex]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n[fetcher_network_domain]: ../basics/fetcher.md#network-domains\n\n[]\n\nnav: Formulas\ndescription: Formulas are one of the most basic building blocks in Coda, and using Packs you can add your own custom ones.\n\n[]"
  },
  "Add custom formulas": {
    "Structure of a formula": "A formula definition consists of a set of key-value pairs, which specify the various settings for the formula. Most of these settings are metadata, such as the name, description, parameters and result type. The actual code that is run each time the formula recalculated is specified using in the `execute` key.\n\n<img src=\"../../../images/formula_structure.png\" srcset=\"../../../images/formula_structure_2x.png 2x\" class=\"screenshot\" alt=\"Mapping of formula coda to formula editor.\">",
    "Naming": "The name of a formula can only contain letters, numbers, and underscores. This restriction exists to ensure that custom formulas are compatible with the Coda Formula Language. We also recommend following these conventions:\n\n['For formulas that fetch or generate data, select a noun that corresponds to the output, using a plural if multiple can be returned. For example, `Chart` or `Tasks`.\\n{: .yes}', 'For formulas that transform data, select a verb that corresponds to the transformation. For example, `Reverse` or `Truncate`.\\n{: .yes}', 'For multiple words, use upper camel case. For example, `BugReport` or `DeletedFiles`.\\n{: .yes}', \"Don't include the Pack name in the name of the formula. For example, use `Task` instead of `TodoistTask`.\\n{: .no}\", 'Avoid prefixes like `Get`, `Lookup`, or `Query`. For example, use `Tasks` instead of `GetTasks`.\\n{: .no}']\n\nFormula names must be unique within a Pack, but can be the same as built-in formulas or those in other Packs. When a doc has access to multiple formulas with the same name the Pack's icon is used to distinguish them.\n\n<img src=\"../../../images/formula_disambiguation.png\" srcset=\"../../../images/formula_disambiguation_2x.png 2x\" class=\"screenshot\" alt=\"Icons used to disambiguate formulas\">\n\n!!! warning\nChanging the name of a formula will break any existing docs that use it. When creating your Pack select your names carefully.",
    "Parameters": "Formulas can accept parameters, which is the primary way for them to access data from the document. See the [Parameters guide][parameters] for more information and examples.",
    "Results": "All formulas must return a result, which is a single value matching the type specified in the `resultType` property of the formula definition. See the [Data types guide][data-types] for more information on the type of values that can be returned.",
    "Authentication": "Formulas can use [authentication][authentication] to fetch private data. When using [system authentication][system_auth] there is no change to the user experience, but when you use [user authentication][user_auth] the formula editor will be automatically updated to prompt for a connected account. The connected account will appear as the first parameter of the formula, but its value is not passed to your formula's `execute` function.\n\n=== \"Formula editor\"\n<img src=\"../../../images/formula_account.png\" srcset=\"../../../images/formula_account_2x.png 2x\" class=\"screenshot\" alt=\"Account parameter in formula editor\">\n\n=== \"Code\"\n```ts\npack.setUserAuthentication({\ntype: coda.AuthenticationType.HeaderBearerToken,\ninstructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  // ...\n  execute: async function ([url], context) {\n    // ...\n  },\n});\n```\n\n\nBy default if a Pack defines an authentication method then all formulas will require a connected account. You can change this behavior using the [`connectionRequirement`][connectionRequirement] property of the formula definition. Setting it to `Optional` makes the user account optional, and `None` removes the account parameter completely.\n\nWhile it's possible to use multiple accounts within a document, each instance of the formula must use a specific account. It isn't possible to have a formula that uses the account of whichever user is currently viewing the document. It's important for collaboration that all users in a Coda doc have access to the same data.",
    "Caching": "For performance reasons formula results are cached by default. See the [caching guide][caching] for more information.",
    "Recalculation": "After a formula is run its value is stored in the Coda document model. Reloading the document will not cause the formula to be run again. Instead Coda's formula engine monitors for changes to the formula inputs and determines if the result needs to be recalculated.\n\nBuilding or releasing a new version of your Pack doesn't automatically cause existing formulas to recalculate, so users may still see old results for a while. In the **Settings** tab of the Pack's side panel there is a \"Refresh now\" button (****) that allows users to recalculate all formulas using the Pack, as well as options to cause them to recalculate on a regular schedule.\n\n<img src=\"../../../images/settings_recalc.png\" srcset=\"../../../images/settings_recalc_2x.png 2x\" class=\"screenshot\" alt=\"Recalculation settings in the Pack side panel\">\n\nPack makers also have access to additional options in the Pack Maker Tools:\n\n['In the three dots menu at the top right of the Pack Maker Tools panel, click the option **Refresh Pack formulas and tables**. [Learn more][pmt_options].', 'In the settings of the Pack Maker tools, toggle on the setting **Auto-refresh formulas & tables**. [Learn more][pmt_settings].']\n\nCoda has complex logic that determines when formula results need to be recalculated. Formulas will always recalculate when the parameter values change, but it will also happen periodically for other reasons including routine maintenance. In general you shouldn't make any assumptions about how often your formula will be run. If running your formula is expensive in some way (API cost, etc) make sure to use [caching](#caching) and [rate limits][fetcher_rate_limits] to limit the impact of recalculation.",
    "Examples": "Coda automatically generates user documentation for your formulas based on the names and descriptions you assign. To demonstrate how the formula should be used you can add entries to the `examples` array. Each example is a structured object containing a set of parameters and the corresponding result, with the types matching those defined in your formula.\n\n=== \"Formula documentation\"\n\n<img src=\"../../../images/formula_examples.png\" srcset=\"../../../images/formula_examples_2x.png 2x\" class=\"screenshot\" alt=\"Formula examples in the generated documentation\">\n\n\n=== \"Code\"\n\n```ts\npack.addFormula({\n  name: \"ToUSD\",\n  description: \"Convert from a different currency to US dollars.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"amount\",\n      description: \"The amount to convert.\"\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The currency to convert from.\"\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  examples: [\n    { params: [10, \"EUR\"], result: 11.44 },\n    { params: [12.25, \"CAD\"], result: 9.80 },\n  ],\n  // ...\n});\n```\n\n\nThe parameter values are passed in the order they are defined in the formula, and all required parameters must be included. Pass the value `undefined` for any optional parameters you want to skip over.\n\n```\nexamples: [\n  // Set only the first parameter.\n  { params: [\"Hello\"], result: \"HELLO!!!\" },\n  // Set the first and third parameter.\n  { params: [\"Hello\", undefined, \"?\"], result: \"HELLO???\" },\n],\n```\n\n[samples]: ../../samples/topic/formula.md\n[formulas]: https://coda.io/formulas\n[parameters]: ../basics/parameters/index.md\n[actions]: actions.md\n[data-types]: ../basics/data-types.md\n[fetcher_cache]: ../basics/fetcher.md#caching\n[fetcher_rate_limits]: ../basics/fetcher.md#ratelimits\n[authentication]: ../basics/authentication/index.md\n[system_auth]: ../../reference/sdk/classes/core.PackDefinitionBuilder.md#setsystemauthentication\n[user_auth]: ../../reference/sdk/classes/core.PackDefinitionBuilder.md#setuserauthentication\n[connectionRequirement]: ../../reference/sdk/interfaces/core.PackFormulaDef.md#connectionrequirement\n[sync_formula]: sync-tables/index.md#formula\n[pmt_settings]: ../development/pack-maker-tools.md#settings\n[pmt_options]: ../development/pack-maker-tools.md#options\n[caching]: ../advanced/caching.md\n\n[]\n\nnav: Dynamic sync tables\ndescription: Build advanced sync tables that adapt to dynamic data sources.\n\n[]"
  },
  "Creating sync tables with dynamic schemas": {
    "Using dynamic sync tables": "Adding a dynamic sync table to a doc is similar to adding a regular sync table, but with an additional step of selecting the specific dataset to sync from. Start by navigating to {{ coda.pack_panel_clicks }} and clicking on the the table in the side panel. This will expand a section below the table that displays the specific datasets that the user has access to. Then drag one of these datasets onto the page.\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of adding a dynamic sync table.\" class=\"screenshot\"><source src=\"../../../../images/dynamic_sync_table_usage.mp4\" type=\"video/mp4\"></source></video>",
    "Creating a dynamic sync table": {
      "Define the table": "The dynamic sync table is defined using the [`addDynamicSyncTable()`][addDynamicSyncTable] method. The `name` is user visible and should follow the [naming conventions][sync_tables_naming] of regular sync tables. The `description` is not required but recommended. An `identityName` is required, and defines the [identity][sync_tables_identity] of the table.\n\n```\npack.addDynamicSyncTable({\n  name: \"Tasks\",\n  description: \"The tasks in the selected project.\",\n  identityName: \"Task\",\n  listDynamicUrls: async function (context) {\n    // Return the datasets the user has access to.\n    // ...\n  },\n  getName: async function (context) {\n    // Return the name of the selected dataset.\n    // ...\n  },\n  getDisplayUrl: async function (context) {\n    // Return a display URL for the selected dataset.\n    // ...\n  },\n  getSchema: async function (context) {\n    // Return a schema for the selected dataset.\n    // ...\n  },\n  formula: {\n    // Sync the rows from the dataset.\n    // ...\n  },\n});\n```\n\nMore information the the various components of the dynamic sync table are described in the sections below.",
      "Generate the list of datasets": "The [`listDynamicUrls`][listDynamicUrls] function is responsible for generating the list of datasets that the user can select from. Each dataset is represented by a unique URL, known as the dynamic URL. This list is typically generated by querying an external API using a connected account.\n\nThe function should return an array of [`MetadataFormulaObjectResultType`][MetadataFormulaObjectResultType] objects. The `display` field should be set to the user-facing name of the dataset, and the `value` field to its URL.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  listDynamicUrls: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.example.com/projects\",\n    });\n    let projects = response.body.items;\n    let results = [];\n    for (let project of projects) {\n      results.push({\n        display: project.name,\n        value: project.links.self,\n      });\n    }\n    return results;\n  },\n  // ...\n});\n```\n\nYou can choose any URL to represent the dataset, and is not directly exposed to the user. Most Packs choose an API endpoint URL for ease of development, but you could also select a more user-friendly URL. The URL shown to users is generated using the [`getDisplayUrl`](#display-url) method.\n\nThe selected URL is made available to all further methods via [`context.sync.dynamicUrl`][dynamicUrl].",
      "Generate the table name": "The [`getName`][getName] function is responsible for generating the user-visible name of the sync table based on the dataset selected. The resulting value is used as the title shown above the sync table after it is added to the document.  This differs from the `name` field of the dynamic sync table definition, which is shown in the Pack side panel to identify the type of table.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  getName: async function (context) {\n    let projectUrl = context.sync.dynamicUrl;\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: projectUrl,\n    });\n    let project = response.body;\n    return project.name + \" Tasks\";\n  },\n  // ...\n});\n```",
      "Generate the display URL {: #display-url}": "The [`getDisplayUrl`][getDisplayUrl] function is responsible for generating the user-facing version of the dynamic URL. If the URL you selected to represent the dataset is already user friendly (it will open in their browser) then you can return it as-is. However if you chose to use an API-specific URL as the dynamic URL, this function should translate that into something more useful. This is typically done by making an API request to retrieve a user-facing URL.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  getDisplayUrl: async function (context) {\n    let projectUrl = context.sync.dynamicUrl;\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: projectUrl,\n    });\n    let project = response.body;\n    return project.links.web;\n  },\n  // ...\n});\n```",
      "Generate the row schema {:. #get-schema}": "The [`getSchema`][getSchema] function is responsible for generating the schema that represents each row of the sync table. Unlike regular sync tables that can define their sync table at build time, the schema for a dynamic sync table must be generated at run-time based on the dataset selected. The function is first run when the user drags the sync table into the document, and then again before every sync.\n\nIn order to generate the schema you must have a way of determining the shape of the data for the selected dataset. Some APIs provide endpoints that allow you to query metadata about a dataset, such as which fields are available and what type of data they contain. Alternatively you can query the first row of data and infer this information based on the results.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  getSchema: async function (context) {\n    let projectUrl = context.sync.dynamicUrl;\n\n    // Fetch information about the custom fields available for the selected\n    // project.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: projectUrl + \"/metadata\",\n    });\n    let projectMetadata = response.body;\n\n    // Start with the properties are the same regardless of the which project\n    // was selected.\n    let properties: coda.ObjectSchemaProperties = {\n      name: { type: coda.ValueType.String },\n      id: { type: coda.ValueType.String },\n    };\n    // Use them as the display value and ID of the rows.\n    let displayProperty = \"name\";\n    let idProperty = \"id\";\n\n    // For each custom field defined in the project, add a property to the\n    // schema.\n    let featuredProperties = [];\n    for (let customField of projectMetadata.customFields) {\n      // Generate a property name for the custom field.\n      let name = getPropertyName(customField);\n      // Generate a schema for the field and add it to the set of properties.\n      properties[name] = getPropertySchema(customField);\n      // Mark the property as featured (included in the table by default).\n      featuredProperties.push(name);\n    }\n\n    // Return the schema for each row.\n    return coda.makeObjectSchema({\n      properties: properties,\n      displayProperty: displayProperty,\n      idProperty: idProperty,\n      featuredProperties: featuredProperties,\n    });\n  },\n  // ...\n});\n```\n\nThe schema you generate must have all of the same fields as those used in a regular sync table, such as `properties`, `idProperty`, and `displayProperty`. More information about generating the property names and schemas are covered below.",
      "Write the sync formula": "All of the code discussed in the previous steps are used to generate metadata about the sync table, but in order to populate it with data you must also include a sync formula. Like regular sync tables, this formula's `execute` function is responsible for fetching rows from the dataset and transforming them to match the schema.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks in a project.\",\n    parameters: [],\n    execute: async function ([], context) {\n      let projectUrl = context.sync.dynamicUrl;\n\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: projectUrl + \"/tasks\",\n      });\n      let tasks = response.body.items;\n\n      // Reformat each response to match the schema.\n      let rows = [];\n      for (let task of tasks) {\n        // Include the metadata common to all projects.\n        let row = {\n          name: task.name,\n          id: task.id,\n        };\n\n        // For each custom field, add it to the row.\n        for (let customField of task.customFields) {\n          let key = getPropertyKey(customField);\n          let value = getPropertyValue(customField);\n          row[key] = value;\n        }\n        rows.push(row);\n      }\n\n      return {\n        result: rows,\n      };\n    },\n  },\n});\n```\n\nSince the schema itself is dynamically generated, getting the rows to match that schema becomes more challenging. More information on this topic is [discussed below](#fromKey)."
    },
    "Property names": "When generating the schema for the table you need to determine the name of each property. Usually this is based on the name or title of the corresponding field or column in the dataset. Although the convention for manually defined schemas is to use lower camel case, there are no limitations to the characters you can use in a property name. This means that you don't need to sanitize or convert the names as you build the schema.\n\nIt's worth remembering though that Coda will [normalize your property names][schemas_normalization] before exposing them in the Coda formula language. When you click the **Add Column** button for a property in the sync table, that normalized name is then transformed again into a column title. This process can sometimes lead to unexpected results.\n\nFor example, if you define a property with the name `GitHub (Beta)`, it will be normalized to `GitHubBeta` in the Coda formula language, and then transformed to `Git Hub Beta` as a column name. Currently it's not possible to override this behavior and manually specify the column name.",
    "Property schemas": "Similar to property names, you must also determine the schema for each property. In many cases this involves a large `switch` statement that translates from the type descriptors in the dataset to the equivalent schemas in Coda. If a given field type doesn't have an equivalent schema in Coda it usually makes sense to fallback to a string.\n\n```\nfunction getPropertySchema(customField): coda.Schema & coda.ObjectSchemaProperty {\n  // Select the schema type depending on the custom field type.\n  switch (customField.type) {\n    case \"yes_no\":\n      return { type: coda.ValueType.Boolean };\n    case \"number\":\n      return { type: coda.ValueType.Number };\n    case \"date\":\n      return {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.Date,\n      };\n    default:\n      // Default to strings.\n      return { type: coda.ValueType.String };\n  }\n}\n```",
    "Mapping values to the schema {: #fromKey}": "Like with all sync tables, the sync formula has the job of fetching the rows from the dataset and formatting them to match the schema. With a dynamic sync table this can be more difficult, since the schema itself was generated dynamically and at an earlier phases of the execution. The row responses may not include the name of each custom field, requiring you to make additional requests to the metadata endpoint and join the data.\n\nAn approach that works with some APIs is to leverage the [`fromKey`][fromKey] feature of property schemas. When generating the schema for a property, set `fromKey` to the ID or position of the custom field. Then in the sync formula you can return the data keyed off of that ID or position, without needing to refetch the metadata about the custom field.\n\nHere is a demonstration of this approach, showing some dummy values.\n\n=== \"Metadata from API\"\n```json\n{\n\"title\": \"Total Cost\",\n\"id\": \"abc123\",\n\"type\": \"currency\"\n}\n```\n=== \"Generated Schema\"\n```ts\nproperties: {\n\"Total Cost\": {\ntype: coda.ValueType.Number,\ncodaType: coda.ValueHintType.Currency,\nfromKey: \"abc123\",\n},\n// ...\n},\n```\n=== \"Value from API\"\n```json\n{\n\"id\": \"abc123\",\n\"value\": 525,\n}\n```\n=== \"Sync Formula Result\"\n```ts\n{\n\"abc123\": 525,\n// ...\n}\n```",
    "Stable identifiers": "A sync table schema requires that you set both the `displayProperty` and `idProperty` fields, which determine the display name and unique ID for a row respectively. Some APIs provide predictable values that can serve these roles, like a task object with a consistent `name` and `id` field in addition to a variable number of custom fields. However other datasets may contain only custom fields, and it's not clear which if any of them can be used this way.\n\nThere currently isn't a good solution for dealing with datasets without stable, unique IDs for each row. It's possible to use a generated row number, hash, or random string to act as the unique ID, but those aren't guaranteed to remain stable across syncs. Without a stable identifier some of the features of a sync table, such as companion columns and @-references, won't work correctly.",
    "Parameter access": "The `getSchema` function can access the values of the parameters defined in the sync formula, making it possible to adjust the schema based on user input beyond the selection of the dynamic URL. This is done in a using the third parameter to the function, which is a key-value map of parameter names to values. This is similar to the pattern used by [autocomplete functions][autocomplete_parameter].\n\n```\npack.addDynamicSyncTable({\n  // ...\n  getSchema: async function (context, _, {query}) {\n    // ...\n  },\n  formula: {\n    // ...\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"query\",\n        description: \"A filter query.\",\n      }),\n    ],\n    execute: async function ([query], context) {\n      // ...\n    },\n  }\n  // ...\n});\n```\n\nThe `getSchema` function is first run when the table is initially dragged into the document, before any parameter values have been set. Make sure your function can handle the absence of parameter values, even required ones.",
    "Organize the dataset list {: #folders}": "Instead of returning a flat list of datasets in the `listDynamicUrls` function, you can instead organize them into folders.\n\n<img src=\"../../../../images/dynamic_sync_table_folder.png\" srcset=\"../../../../images/dynamic_sync_table_folder_2x.png 2x\" class=\"screenshot\" alt=\"Organize the URL list into folders\">\n\nTo create a folder, return a [`MetadataFormulaObjectResultType`][MetadataFormulaObjectResultType] with `hasChildren: true`. When a user clicks on a folder, the `listDynamicUrls` function will be re-run, passing in the URL of the parent folder as the second parameter.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  listDynamicUrls: async function (context, folderUrl) {\n    if (folderUrl) {\n      // Return the items in the selected folder.\n    } else {\n      // Get the items at the root.\n    }\n  },\n  // ...\n});\n```\n\nFolders can be nested inside of other folders, allowing you to represent complex hierarchies.",
    "Search for datasets {: #search}": "Finding the desired dataset, even when [organized into folders](#folders), can be difficult when the there are many options to select from. If the underlying API supports it you can allow users to search for the dataset instead.\n\n<img src=\"../../../../images/dynamic_sync_table_search.png\" srcset=\"../../../../images/dynamic_sync_table_search_2x.png 2x\" class=\"screenshot\" alt=\"Searching for a dataset.\">\n\nTo enable this search feature, add a `searchDynamicUrls` function to your sync table definition. This function works identically to `listDynamicUrls`, except that the 2nd parameter contains the user-entered search term instead of the folder URL.\n\n```\npack.addDynamicSyncTable({\n  // ...\n  searchDynamicUrls: async function (context, search) {\n    let url = coda.withQueryParams(\"https://api.example.com/projects\", {\n      q: search,\n    });\n    // Fetch and return the matching projects...\n  },\n  // ...\n});\n```",
    "Manually entered URLs": "In some cases it's not feasible to generate a list of all possible datasets the user can select from. In these cases you can omit the `listDynamicUrls` function and instead have your users directly enter the URL of the dataset.\n\n<img src=\"../../../../images/dynamic_sync_table_url.png\" srcset=\"../../../../images/dynamic_sync_table_url_2x.png 2x\" class=\"screenshot\" alt=\"Manually entering the dynamic URL\">\n\nWhen using this approach you should use a user-facing URL as the dynamic URL, as that is what users will have access to. You'll need some way to translate those URLs into something you can use with the API, typically by extracting an ID.\n\nDynamic sync tables created this way differ from the ones using a list of URLs in a few notable ways:\n\n['The same dynamic URL can be used to create multiple tables.', \"The rows in these tables can't be [referenced][sync_tables_reference] by other sync tables.\"]",
    "Dynamic schema only {: #schema-only }": "Dynamic sync tables are built around the idea that the external data source has a list of datasets, each with their own unique set of fields. Sometimes though there aren't different datasets to select from, but the fields available to sync do vary slightly based on the connected account. In these cases you can use a somewhat simpler approach: a regular sync table with a dynamic schema.\n\nTo implement this, create a regular sync table using `addSyncTable` and define the function `dynamicOptions.getSchema`. You'll still need to specify a static schema in the `schema` field of the sync table, but it will be overridden during the sync with the output of `getSchema`.\n\n```\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  dynamicOptions: {\n    getSchema: async function (context) {\n      // Generate the dynamic schema.\n    },\n  },\n  identityName: \"Task\",\n  formula: {\n    // ...\n  },\n});\n```",
    "Lifecycle": "Dynamic sync tables include a lot of individual functions, but they are run at different times and with different frequencies. Below is an outline of the typical lifecycle of a dynamic sync table.\n\n[\"**The table is expanded in the Pack's side panel**[^1]\", ['The `listDynamicUrls` function is called to populate the list of data sources.'], '**The table is added to the page**', ['The `getDisplayUrl` function is called to calculate the display URL for the table.', 'The `getName` function is called to calculate the initial name for the table (the user can later change it).', 'The `getSchema` function is called to calculate the initial set of featured columns for the table.'], '**The table is synced (or re-synced)**', ['The `getSchema` function is called to calculate the structure of the table.', 'The `formula.execute` function is called to populate the table.']]\n\n[^1]: Using a slash command to insert the dynamic sync table into the page will invoke the same code path, in order to populate a dropdown of data sources.\n\n[samples]: ../../../samples/topic/dynamic-sync-table.md\n[sync_tables_naming]: index.md#naming\n[MetadataFormulaObjectResultType]: ../../../reference/sdk/interfaces/core.MetadataFormulaObjectResultType.md\n[schemas_identity]: ../../advanced/schemas.md#schema-identity\n[schemas_normalization]: ../../advanced/schemas.md#normalization\n[schemas_sync_table]: ../../advanced/schemas.md#schemas-in-sync-tables\n[fromKey]: ../../../reference/sdk/interfaces/core.ObjectSchemaProperty.md#fromkey\n[addDynamicSyncTable]: ../../../reference/sdk/classes/core.PackDefinitionBuilder.md#adddynamicsynctable\n[listDynamicUrls]: ../../../reference/sdk/interfaces/core.DynamicSyncTableOptions.md#listdynamicurls\n[getName]: ../../../reference/sdk/interfaces/core.DynamicSyncTableOptions.md#getname\n[getDisplayUrl]: ../../../reference/sdk/interfaces/core.DynamicSyncTableOptions.md#getdisplayurl\n[getSchema]: ../../../reference/sdk/interfaces/core.DynamicSyncTableOptions.md#getschema\n[dynamicUrl]: ../../../reference/sdk/interfaces/core.SyncBase.md#dynamicurl\n[sync_tables_identity]: index.md#identity\n[autocomplete_parameter]: ../../basics/parameters/autocomplete.md#parameters\n[sync_tables_reference]: index.md#references\n\n[]\n\nnav: Sync tables\ndescription: Create tables of data that automatically sync in records from an external data source.\n\n[]"
  },
  "Add sync tables": {
    "Using sync tables": "Sync tables are added directly to the document, usually by dragging them in from the side panel. Navigate to {{ coda.pack_panel_clicks }} and drag the table into the canvas.\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of adding a sync table.\" class=\"screenshot\"><source src=\"../../../images/sync_table_use.mp4\" type=\"video/mp4\"></source></video>\n\nIf the sync table doesn't have any required parameters it will start syncing immediately, otherwise you'll have to configure it first. The data in the table can be synced manually or set up to sync automatically at regular intervals.\n\n!!! info \"Multiple syncs\"\nEach sync table can only be added once to a document. If you want to sync data from multiple accounts or with different parameters you can add additional syncs to the table. In the table options pane click the **Add another sync** button and configure the settings. The results from all syncs will be appended to the same table, but you can use views and filters on that table to display them separately.\n\nThe data in the table is synced with the external source automatically on a schedule (at most hourly). In the table's **Options** pane users can set the sync frequency or start a manual sync. It is not possible to configure a button or automation to start a sync.",
    "Creating a sync table": {
      "Define the schema": "Each row in a sync table corresponds to an item in an external data source. For example, the [Todoist sample][sample_todoist] has one sync table for tasks and another for projects. For each table you must define a schema that represents the data you'll be syncing for that item. See the [Schemas guide][schemas] for more information about defining and using schemas.\n\nThe item is displayed as a chip in the first column of the sync table, and it contains the complete set of synced data. Properties of the schema designated as [`featuredProperties`][featured] are automatically broken out into their own columns, but these can be removed or added to by the user later.\n\nThe schema used in a sync table can be shared by other building blocks in your Pack, like a formula or column format. Even when the schema is only used by the sync table, we recommend you define it as a separate variable in your code for readability and future reuse.\n\n```\nconst TaskSchema = coda.makeObjectSchema({\n  // ...\n});\n```\n\n!!! info \"Dynamic schemas\"\nFor some data sources it isn't possible to know the shape of the data upfront, and it can only be determined at runtime. In these cases instead of defining your schema upfront you can generate it dynamically. See the [Dynamic sync tables][dynamic_sync_tables] guide for more information.",
      "Define the sync table": "The sync table itself is defined using the `addSyncTable()` method:\n\n```\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    // ...\n  },\n});\n```\n\nIt includes the name of the sync table, the schema for each row, and other metadata. The `identityName` property will be explained in the [Identity](#identity) section below.",
      "Write the sync formula {: #formula}": "Inside each sync table definition is a formula definition, detailing the hidden formula used to sync data into the sync table. If you aren't already familiar with creating formulas, read the [Formulas guide][formulas] first.\n\n```\npack.addSyncTable({\n  // ...\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync the user's tasks.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // ...\n    }\n  },\n});\n```\n\nThis formula fetches items from the external data source, adjust them to fit the schema, and returns them. The return value must be a [`SyncFormulaResult`][SyncFormulaResult], which is an object where the `result` property contains the array of item objects.\n\n```\npack.addSyncTable({\n  // ...\n  formula: {\n    // ...\n    execute: async function ([], context) {\n      let url = \"<URL to pull data from>\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let items = response.body.items;\n      // Adjust the items to fit the schema if required.\n      return {\n        result: items,\n      }\n    }\n  },\n});\n```\n\nOn each sync your code must return the full set of items, and Coda will determine how to update existing rows, remove old rows, etc. This could take a long time for large datasets or slow APIs, and the [Long-running syncs](#longrunning) section has more information on how to handle this."
    },
    "Naming": "The name of a sync table is visible to the user, and can only contain letters, numbers, and underscores. We recommend following these conventions:\n\n['Select a plural noun corresponding to the item represented by each row. For example, `Products` or `Sales`.\\n{: .yes}', 'For multiple words, use upper camel case. For example, `BugReports`.\\n{: .yes}', \"Don't include the Pack name in the name of the table. For example, use `Tasks` instead of `TodoistTasks`.\\n{: .no}\", \"Don't use adjectives in sync table names. For example, `ActiveProducts` or `RecentSales`.<br>\\nIn these cases it is better to have a single sync table for all items of the same type, and then add parameters that allow users to filter by certain criteria.\\n{: .no}\"]\n\nIn some areas of the UI, such as the settings pane, the name will be rewritten to add spaces (\"BugReports\" => \"Bug Reports\") for readability.\n\n!!! warning\nChanging the name of a sync table will break any existing docs that use it. When creating your Pack select your names carefully.",
    "Identity {: #identity}": "Every sync table is required to specify an [`identityName`][identityName], which is a unique identifier for the table. By convention this is usually the singular form of the name of the item being synced. For instance, a \"Tasks\" table would use an identity name of \"Task\". This identity name is used to reference the table when [creating row references](#references) or [updating rows with actions][actions_sync].\n\nBy default the identity name is also used as the column name for the first column of the sync table, which contains the synced item as a chip. You can use a different name for the column by setting [`dynamicOptions.entityName`][dynamicOptions] on the sync table.",
    "Parameters": "The parameters defined on the sync formula are exposed to users as criteria in the sync table options. See the [parameters guide][parameters] for more information about how parameters are defined and displayed.\n\nIn most sync tables, parameters are used to allow users to filter the results in the sync table. Although users can always add filters to the resulting table to hide certain rows, it's faster and simpler to do that filtering in the sync formula itself.",
    "Row limits": "Each sync table has a user-defined maximum number of rows, which defaults to 1000 but can be set as high as 10,000. Once a sync table reaches the limit Coda will stop the sync (even if the code returned a [continuation](#longrunning)) and truncate the resulting rows to fit within the limit.",
    "Long-running syncs {: #longrunning}": "The sync formula that populates a sync table will timeout after a minute, but for some data sources it may take longer to retrieve all the results. In these cases you can utilize the continuation mechanism of sync tables to break your sync up into multiple executions. A continuation is like a save point, allowing you to record where you left off and then pick up again later.\n\nIf at the end of an execution there are more items left to sync, return a custom continuation object along with the synced items. Coda will then re-run your sync formula, passing in the previous continuation object. The synced items from each execution will be appended to the table. This process will continue until no continuation object is returned or the table reaches the row limit.\n\n```\nflowchart TD\n\nsubgraph coda [ ]\n  run(Run sync formula)\n  table(Sync table)\n  exists{Exists?}\n  subgraph pack [Pack]\n    request(Fetcher request)\n    response(Response)\n    results(Results)\n    continuation(Continuation?)\n  end\nend\n\nstart(Start sync)\ncomplete(Sync complete)\n\nstart --> run\nrun --> pack\nrequest --> response\nresponse --> results -- Append --> table\nresponse --> continuation --> exists\nexists -- No --> complete\nexists -- Yes\\nSet as context.sync.continuation --> run\n```\n\nThe contents of the continuation are flexible and will depend on the API to the external data source, but usually involve offsets or page tokens. The continuation must be an object of type [`Continuation`][Continuation], which allows for storing string and number values. Continuations are not designed for persisting large amounts of data between executions, so we recommend against using a task queue pattern.\n\n```\npack.addSyncTable({\n  // ...\n  formula: {\n    // ...\n    execute: async function ([], context) {\n      let previousContinuation = context.sync.continuation;\n      // If there is a previous continuation, pick up where you left off.\n      // Otherwise start from the beginning.\n\n      // Sync some items...\n\n      let nextContinuation = undefined;\n      // Determine if there are more items left to sync...\n      if (moreItemsLeft) {\n        nextContinuation = {\n          // Save your place...\n        };\n      }\n      return {\n        result: items,\n        continuation: nextContinuation,\n      }\n    }\n  },\n});\n```\n\n[View Sample Code][sample_continuation]{ .md-button }",
    "Two-way sync": "By default the sync process used by sync tables is one-way only; data is pulled in from an external source and is displayed in a read-only column. However, if the external API supports it you can utilize the two-way sync feature to allow users to edit column values directly in the sync table and then push those changes back to the original data source.\n\nLearn more about this approach in the [two-way sync guide][two_way_sync].",
    "Referencing rows from other sync tables {: #references}": "It's often the case that the different synced items in a Pack are related to each other. For example, a Pack may have sync tables for projects and tasks, where each task belongs to a single project. Using references you can connect these two tables together. References in sync tables work like [relation columns][hc_relations] in regular tables.\n\nA reference must specify the identity of the target table as well as the ID of the target row. If that row has already been synced to the doc, then the reference is replaced with the data from that row. Otherwise a grayed out chip is displayed, indicating that the referenced row hasn't been synced yet.\n\n<img src=\"../../../images/sync_table_reference.png\" srcset=\"../../../images/sync_table_reference_2x.png 2x\" class=\"screenshot\" alt=\"How sync table references look in the doc\">\n\nSee the [Schemas guide][schema_references] for more information on how to create references in your table schema.\n\n[View Sample Code][sample_reference]{ .md-button }",
    "Account-specific fields": "Some APIs vary the shape of the data returned based on the account being accessed. For example, an issue tracker may allow users to define custom fields for their bug reports, which the API also returns. A sync table must have a defined schema that represents the data for each item, but it is possible to expand that schema to accommodate these variations by using a dynamic schema. See the [Dynamic sync tables guide][dynamic_sync_tables_schema_only] for more information on how to use this feature.",
    "Caching & recalculation {: #caching}": "A sync table is not a live view into an external data source, but rather a snapshot of the data stored at the time of the last sync. Unlike formulas which are recalculated automatically when the parameters change, changes to sync table parameters will only be reflected during the next sync.\n\nIt's recommended that you reduce or disable [HTTP caching][fetcher_caching] of the fetcher requests used to populate your sync table. When users manually resync a table they expect the latest results, and HTTP caching can interfere with that. Caching may still be appropriate for requests that retrieve the same data during each sync formula execution.",
    "Columns selection": "Although only [featured columns][schemas_featured_columns] are shown in the table by default, all of the schema properties are synced and stored in the table as their own columns. Additionally, the object chip in the first column of the sync table provides quick access to view and formulaically access the value of all properties.\n\nFor very large schemas all of these unused properties can come with a performance cost however, so users have the option to choose the exact set of columns they want to sync. This can be done by clicking the **Sync more properties** button in the sync table settings, and is launched automatically when creating the sync table with a very large schema.\n\n<img src=\"../../../images/sync_table_select_columns.png\" srcset=\"../../../images/sync_table_select_columns_2x.png 2x\" class=\"screenshot\" alt=\"Selecting columns of a sync table\">\n\nUsers can choose from top-level properties in the schema, and only those they select will be persisted in the document during the sync.\n\nWhile there is no harm in your Pack retrieving properties that won't be persisted, in some cases you can optimize your sync if you know the exact set of fields the user is requesting. This can be determined by inspecting the value of `context.sync.schema`. This will be a copy of the original schema, but with only properties that the user selected.\n\nSince the properties themselves may use the [`fromKey`][fromKey] option to load their value from a different field in the row objects, it can be somewhat involved to map the properties back to API fields. To assist with this there is a helper function [`coda.getEffectivePropertyKeysFromSchema()`][getEffectivePropertyKeysFromSchema] that will do the conversion for you.\n\n??? example \"Example: Open Data NY sync table\"\n```ts\n--8<-- \"samples/packs/dynamic-sync-table/open_data_ny.ts\"\n```\n\n[samples]: ../../../samples/topic/sync-table.md\n[help_center]: https://help.coda.io/en/articles/3213629-using-packs-tables-to-sync-your-data-into-coda\n[sample_todoist]: ../../../samples/full/todoist.md\n[schemas]: ../../advanced/schemas.md\n[featured]: ../../../reference/sdk/interfaces/core.ObjectSchemaDefinition.md#featuredproperties\n[formulas]: ../formulas.md\n[SyncFormulaResult]: ../../../reference/sdk/interfaces/core.SyncFormulaResult.md\n[Continuation]: ../../../reference/sdk/interfaces/core.Continuation.md\n[identityName]: ../../../reference/sdk/interfaces/core.SyncTableOptions.md#identityname\n[schema_references]: ../../advanced/schemas.md#references\n[dynamicOptions]: ../../../reference/sdk/interfaces/core.SyncTableOptions.md#dynamicoptions\n[actions]: ../actions.md\n[dynamic_sync_tables]: dynamic.md\n[dynamic_sync_tables_schema_only]: dynamic.md#schema-only\n[hc_relations]: https://help.coda.io/en/articles/1385997-connect-tables-with-relation-columns\n[sample_continuation]: ../../../samples/topic/sync-table.md#with-continuation\n[sample_reference]: ../../../samples/topic/sync-table.md#with-row-references\n[parmeters]: ../../basics/parameters/index.md\n[fetcher_caching]: ../../basics/fetcher.md#caching\n[parameters]: ../../basics/parameters/index.md\n[two_way_sync]: two-way.md\n[schemas_featured_columns]: ../../advanced/schemas.md#featured-columns\n[getEffectivePropertyKeysFromSchema]: ../../../reference/sdk/functions/core.getEffectivePropertyKeysFromSchema.md\n[fromKey]: ../../../reference/sdk/interfaces/core.ObjectSchemaProperty.md#fromkey\n[actions_sync]: ../actions.md#sync\n\n[]\n\nnav: Two-way sync\ndescription: Allow users to edit the contents of a sync table and push those changes back to the source.\n\n[]"
  },
  "Enable edits on sync tables": {
    "Using two-way sync": "To enable two-way sync on a sync table that supports it you need to toggle on the option **Enable Edits** in the sync table settings. Doing so reveals additional options that control when updates are sent and which account is used.\n\n<img src=\"../../../../images/two_way_enable.png\" srcset=\"../../../../images/two_way_enable_2x.png 2x\" class=\"screenshot\" alt=\"Enabling edits on a sync table.\">\n\nCertain columns of the table will now be editable, and you can change cell values them as you would for a normal Coda table. Use the **Update rows** link to push the changes back to the data source.\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of editing a sync table.\" class=\"screenshot\"><source src=\"../../../../images/two_way.mp4\" type=\"video/mp4\"></source></video>",
    "Adding two-way sync": {
      "Annotate the schema": "Not every field that you sync from the external data source can be changed. To indicate which columns should be editable you need to annotate your schema by adding `mutable: true` to the corresponding properties.\n\n```\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      mutable: true,\n    },\n    // ...\n  },\n  // ...\n});\n```\n\nOnly top-level properties in the schema are eligible to be editable, since they are stored in distinct columns. Properties in nested objects, even if marked as mutable, will not be editable in the sync table. You can however still make a column containing an nested object editable, but you'll need to provide [an options function](#options) to generate a list of compatible objects.\n\n??? tip \"Annotating a shared schema\"\n\nIf the property's schema is reused in multiple columns, and only some of those are editable, you can use the [object spread operator][mdn_spread_object] to duplicate the schema and merge in the `mutable` field.\n\n```{.ts hl_lines=\"10-13\"}\nconst UserSchema = coda.makeObjectSchema({\n  // ...\n});\n\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    // The creator cannot be edited.\n    creator: UserSchema,\n    // The assignee can be edited.\n    assignee: {\n      ...UserSchema,\n      mutable: true,\n    },\n    // ...\n  },\n  // ...\n});\n```\n\n",
      "Write the update function": "Once the user has made their edits you'll need to figure out how to push them back to the external data source. This code is implemented in the `executeUpdate` function, which lives alongside the `execute` function in the sync formula.\n\n```\npack.addSyncTable({\n  name: \"Tasks\",\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      // Pull down the data ...\n    },\n    executeUpdate: async function (args, updates, context) {\n      // Push up the changes and return the updated data...\n    },\n  },\n});\n```\n\nMuch like the `execute` function, the `executeUpdate` function receives the sync table's parameter values and the execution context. However it is also provided an array of `updates` which contain information about the rows being updated.\n\nEach [`SyncUpdate`][reference_sync_update] object in the array contains the previous value for that row, the new value, and the list of fields that were updated. By default the `executeUpdate` function only receives one row at a time, but this can be increased for APIs that support [batching](#batching).\n\nUse those values to make the API requests needed to update the external data source, and then return the final value for the updated row. This may differ from what the user entered if the update had side effects, for example increasing the last updated timestamp of the record.\n\n```\nexecuteUpdate: async function (args, updates, context) {\n  let update = updates[0];  // Only one row at a time, by default.\n  let task = update.newValue;\n\n  // Update the task in Todoist.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: `https://api.todoist.com/rest/v2/tasks/${task.id}`,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(task),\n  });\n\n  // Return the final state of the task.\n  let updated = response.body;\n  return {\n    result: [updated],\n  };\n},\n```\n\n??? tip \"Getting the final row value\"\n\nFor many APIs getting the final row value is easy, as the updated record is returned in the API response. In cases where the updated record isn't returned in the response you can immediately fetch it to get the final state.\n\n```ts\nlet task = update.newValue;\nawait updateTask(task);\nlet updated = await getTask(task.id);\nreturn {\n  result: [updated],\n};\n```\n\nThis may not always be feasible however, as some APIs have a delay between when the update is made and when it's reflected in the API responses. In those cases you may have to return the value that the user entered, understanding that any side effects from the update won't be reflected.\n\n```ts\nlet task = update.newValue;\nawait updateTask(task);\nreturn {\n  result: [task],\n};\n```\n\n"
    },
    "Transforming row values": "While needed for all sync tables, when implementing two-way sync you need to pay extra attention to how you transform row values between the form used by the API and that used by the table. This is not an issue if your sync table schema exactly matches the items returned by the API, but often you want or need a different representation of the data in Coda.\n\nWhen possible, utilize the `fromKey` field of property schemas to allow Coda to automatically map between the API results and the table columns. This works not only when syncing in rows in the `execute` function, but also in reverse when sending updates in the `executeUpdate` function. Specifically, the [`SyncUpdate`][reference_sync_update] object's `newValue`, `previousValue`, and `updatedFields` will all be keyed using the `fromKey` value if set.\n\n??? example \"Using fromKey to transform automatically\"\n```ts\nconst TaskSchema = coda.makeObjectSchema({\nproperties: {\nid: { type: coda.ValueType.String },\n// Map the API's \"content\" field to the property \"name\".\nname: { type: coda.ValueType.String, fromKey: \"content\", mutable: true },\n},\n// ...\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      let tasks = await getTasks(context);\n      // Each task looks like: {\"id\": \"123\", \"content\": \"Foo\"}\n      // Coda will automatically map the \"content\" field to the \"name\" property.\n      return {\n        result: tasks,\n      };\n    },\n    executeUpdate: async function (args, updates, context) {\n      let update = updates[0];\n      let task = update.newValue;\n      // The new value looks like: {\"id\": \"123\", \"content\": \"Bar\"}\n      // Coda automatically mapped \"name\" property back to \"content\".\n      task = await updateTask(context, task);\n      // The final value will look like: {\"id\": \"123\", \"content\": \"Bar\"}\n      // Once again, Coda will automatically map \"content\" to \"name\".\n      return {\n        result: [task],\n      };\n    },\n  },\n});\n```\n\n\nIn cases where `fromKey` is not sufficient and you must manually transform API results to row values and back, we recommend using helper functions with clear names to handle the convert between the different representations.\n\n??? example \"Using helper functions to transform manually\"\n```ts\nconst TaskSchema = coda.makeObjectSchema({\nproperties: {\nid: { type: coda.ValueType.String },\nname: { type: coda.ValueType.String, mutable: true },\n},\n// ...\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      let tasks = await getTasks(context);\n      // Each task looks like: {\"id\": \"123\", \"content\": \"Foo\"}\n      // Manually map the \"content\" field to the \"name\" property before returning it.\n      let rows = tasks.map(task => formatTaskForSchema(task))\n      return {\n        result: rows,\n      };\n    },\n    executeUpdate: async function (args, updates, context) {\n      let update = updates[0];\n      let row = update.newValue;\n      // The new value looks like: {\"id\": \"123\", \"name\": \"Bar\"}\n      // Manually map the \"name\" property back to \"content\" before sending it to the API.\n      let task = formatTaskForApi(row);\n      task = await updateTask(context, task);\n      // The final value will look like: {\"id\": \"123\", \"content\": \"Bar\"}\n      // Once again, manually map \"content\" to \"name\" before returning it.\n      row = formatTaskForSchema(task);\n      return {\n        result: [row],\n      };\n    },\n  },\n});\n\nfunction formatTaskForSchema(task) {\n  return {\n    ...task,\n    name: task.content,\n  };\n}\n\nfunction formatTaskForApi(row) {\n  return {\n    ...row,\n    content: row.name,\n  };\n}\n```\n\n",
    "Batching updates {: #batching}": "By default row updates are processed one at a time, which makes the coding simple but can impact performance when many rows are being updated at once. You can greatly improve performance by batching multiple updates into a single `executeUpdate` call and processing them in parallel.\n\nThe batch size can be adjusted by setting the `maxUpdateBatchSize` field of the sync formula. You'll also need to adjust your `executeUpdate` function to be able to handle multiple updates at once. Use a batch update endpoint if your API provides one, or if not make fetch requests [in parallel][fetcher_parallel] to realize performance gains.\n\n??? tip \"Selecting a batch size\"\n\nA single execution of the `executeUpdate` function can run for at most 60 seconds, after which it will be killed and the update will fail. To allow for variability in network and server conditions it's best to set a target of 30 seconds or less for each batch. How many rows that equates to depends heavily on the API being used and the number of requests it takes to update a row, and some experimentation may be required to find an ideal size.\n\n\n```\npack.addSyncTable({\n  // ...\n  formula: {\n    // ...\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Create an async job for each update.\n      let jobs = updates.map(async update => {\n        let response = await context.fetcher.fetch({\n          // Update request details ...\n        });\n        return response.body;\n      });\n      // Wait for all of the jobs to finish .\n      let completed = await Promise.allSettled(jobs);\n\n      // For each update, return either the updated row or an error if the\n      // update failed.\n      let results = completed.map(job => {\n        if (job.status === \"fulfilled\") {\n          return job.value;\n        } else {\n          return job.reason;\n        }\n      });\n      return {\n        result: results,\n      };\n    }\n  },\n});\n```\n\nWhen processing updates in batches be sure to return the same number of results as there were updates, in the same order. If an individual update fails, catch the exception and return it in the results array to indicate that the row update failed. Unhandled exceptions will prevent the entire batch from completing and won't give the user a clear indication of which row was the cause. See the [Handling errors](#handling-errors) section below for more information.",
    "Property options {: #options}": {
      "In dynamic schemas": "For sync tables with dynamic schemas, you aren't able to define the options function directly on the property itself. Instead use the special value `OptionsType.Dynamic`, which tells Coda to call the sync table's `propertyOptions` function. This is a single function that handles the option generating for all dynamic properties. It's defined directly on a dynamic sync table, or within the `dynamicOptions` of a regular sync table. The function can determine which property to provide options for by inspecting `context.propertyName`.\n\n<!-- TODO: Document exactly what propertyName contains (original, normalized, fromKey). -->\n\n=== \"Dynamic sync table\"\n\n```ts\npack.addDynamicSyncTable({\n  // ...\n  getSchema: async function (context) {\n    let attributes = await getCustomAttributes(context);\n    for (let attr of attributes) {\n      properties[attr] = {\n        // ...\n        codaType: coda.ValueHintType.SelectList,\n        mutable: true,\n        options: coda.OptionsType.Dynamic,\n      }\n    }\n    // ...\n  },\n  propertyOptions: async function (context) {\n    let attr = context.propertyName;\n    let options = await getCustomAttributeOptions(context, attr);\n    return options;\n  },\n});\n```\n\n\n=== \"Regular sync table\"\n\n```ts\npack.addSyncTable({\n  // ...\n  dynamicOptions: {\n    getSchema: async function (context) {\n      // ...\n      let attributes = await getCustomAttributes(context);\n      for (let attr of attriutes) {\n        properties[attr] = {\n          // ...\n          codaType: coda.ValueHintType.SelectList,\n          mutable: true,\n          options: coda.OptionsType.Dynamic,\n        }\n      }\n      // ...\n    },\n    propertyOptions: async function (context) {\n      let attr = context.propertyName;\n      let options = await getCustomAttributeOptions(context, attr);\n      return options;\n    },\n  },\n});\n```\n",
      "Allow new values": "The default behavior is to only allow users to select from the set of options provided. However there are times where you may want to also allow users to create new values from within the sync table. For example, a schema property that represents a set of user-defined tags. This can be controlled using the schema field `allowNewValues`.\n\n```\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    // ...\n    tags: {\n      type: coda.ValueType.Array,\n      items: {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.SelectList,\n        options: async function (context) {\n          let tags = await getTags(context);\n          return tags;\n        },\n        allowNewValues: true,\n      },\n      mutable: true,\n    },\n  },\n});\n```\n\nThe `allowNewValues` setting can only be enabled for `String` properties, as there is no way to the user to define new `Object` values on the fly."
    },
    "Handling errors": "When a row fails to update Coda will show an error message attached to that row. The pending edits will be retained, so that users can adjust them and try again.\n\n<img src=\"../../../../images/two_way_error.png\" srcset=\"../../../../images/two_way_error_2x.png 2x\" class=\"screenshot\" alt=\"Error attached to a row.\">\n\nTo associate an error with a row return it at the corresponding index in the `result` array. For tables that use single row updates (`maxUpdateBatchSize == 1`) if you throw a `UserVisibleError` it will be associated with the row automatically. In all other cases a thrown error will be treated as a failure of the entire sync and cancel any remaining row updates.",
    "Requiring additional OAuth scopes": "If your Pack uses [OAuth authentication][oauth] it may require that the user to approve additional permissions (scopes) in order to make the edits. Users can be hesitant to allow Packs to made changes to their data, so it can be useful to only request these scopes when the user begins making edits using two-way sync. This can be done by using incremental authorization, and you can learn more in the [OAuth guide][incremental_two_way].\n\n[sync_tables]: index.md\n[samples]: ../../../samples/topic/two-way.md\n[mdn_spread_object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals\n[reference_sync_update]: ../../../reference/sdk/interfaces/core.SyncUpdate.md\n[fetcher_parallel]: ../../basics/fetcher.md#in-parallel\n[parameters_autocomplete]: ../../basics/parameters/autocomplete.md\n[oauth]: ../../basics/authentication/oauth2.md\n[incremental_two_way]: ../../basics/authentication/oauth2.md#incremental-two-way\n\n[]\n\nnav: Design guidance\ndescription: How to design your Pack so that it's easy to use and support.\n\n[]"
  },
  "Design your Pack": {
    "General guidance": {
      "Build building blocks": "Unlike other types of integrations, a Coda Pack doesnt prescribe an exact end-to-end experience. Instead it provides a new set of building blocks, like formulas or buttons, that a user can deploy to improve their docs. These building blocks need to provide sufficient flexibility so that they can be combined in novel and bespoke ways.\n\n['Prefer parameters over hard-coding specific patterns.\\n{: .yes}', 'Return [structured data][data_types], so users can chain formulas together.\\n{: .yes}']\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n!!! failure \"Don't\"\n    ```\n    TasksDueWithin7Days() =>\n\n<ul>\n  <li>Send out TPS report - Monday</li>\n  <li>Complete training - Wednesday</li>\n  <li>Organize team lunch - Friday</li>\n</ul>\n```\n\n</div>\n<div markdown>\n!!! success \"Do\"\n    ```\n    Tasks(dueWithin: Duration(7)) =>\n\n[\n  {\n    description: \"Send out TPS report\",\n    due: \"2023-02-20\",\n  }\n  // etc...\n]\n```\n\n\n</div>\n</section>\n\nWhile building blocks offer great flexibility, you'll still want to show users how to apply them. When you publish, make sure to create a [featured doc][best_practices_featured_doc] that includes some key use cases and demonstrates how your Pack can address them.",
      "Build for users": "The target user for your Pack is akin to a skilled spreadsheet user: they know how to use formulas and think about data, but they likely arent developers. When designing your Pack make sure its approachable to someone with this level of technical fluency.\n\nWhen building a Pack that integrates with another application, the simplest approach is to create a thin wrapper on their API. However this may introduce terms and patterns not familiar to non-developers. Instead think of the Pack as an extension of the user experience, but translated from pixels to formulas.\n\n['Avoid using technical jargon when naming build blocks, parameters, or outputs.\\n{: .no}', 'Hide implementation details from the user, like API versions.\\n{: .no}', 'Dont require users to understand technical formats like JSON, XML, etc.\\n{: .no}']\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n!!! failure \"Don't\"\n    ```\n    InsertNewProjectRecord(\"v5\",\n      \"{\\\"name\\\": \\\"My project\\\"}\")\n    ```\n</div>\n<div markdown>\n!!! success \"Do\"\n    ```\n    CreateProject(\"My project\")\n    ```\n</div>\n</section>",
      "Less is more": "Developers love to have expansive APIs that provide complete access to all features, but too much choice can be overwhelming for a Pack user. When designing a Pack, focus on the 20% of functionality that will meet the needs of 80% of your users. Omit more advanced options or features at first, addressing them if/when there is sufficient demand.\n\n['Omit obscure advanced options, preferring instead sensible defaults that work well in the majority of cases.\\n{: .no}', 'Put the most important parameters first, and use [optional parameters][parameters_optional] when a value is not strictly required.\\n{: .yes}']\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n!!! failure \"Don't\"\n    ```\n    AddTask(project, task, labels, reccurence,\n      workflow, dueDate)\n    ```\n</div>\n<div markdown>\n!!! success \"Do\"\n    ```\n    AddTask(task, project, [dueDate])\n    ```\n</div>\n</section>",
      "Use simple names": "When building a Pack you dont need to worry about name collisions, and accessibility to users is more important than completeness or accuracy. When choosing a name, prefer simple nouns or verbs and remove any extraneous detail.\n\n['Dont include the Pack or company name.\\n{: .no}', 'Avoid unnecessary detail in names, unless required to distinguish them.\\n{: .no}', 'Use names that sound more like ordinary speech.\\n{: .yes}', 'Prefer single nouns or verbs when feasible.\\n{: .yes}']\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n!!! failure \"Don't\"\n    ```\n    AcmeTasksListAllTasks()\n    AcmeTasksCreateFromScannedImageUpload()\n    AcmeTasksSetAssignee()\n    ```\n</div>\n<div markdown>\n!!! success \"Do\"\n    ```\n    Tasks()\n    AddFromPhoto()\n    Reassign()\n    ```\n</div>\n</section>\n\nYou can find more best practices for naming building blocks in the guides for [formulas][formulas_naming], [actions][actions_naming], and [sync tables][sync_tables_naming]."
    },
    "API Integration": {
      "Select collections": "Most REST APIs are organized into collections, usually corresponding specific types of items in the application. An API can contain dozens of collections, but as per the general guidance above it's best to start with the handful of core ones that are most valuable to users.\n\n??? example \"Example: Todoist\"\n\nThe [Todoist API][todoist_reference] includes collections for Projects, Sections, Tasks, Comments, and Labels. While a power user may want to leverage all of that information, for most users Projects and Tasks are the core entities they'll want to work with.\n\n",
      "Design the schema": "Examine the data returned for each item in the collection and determine what to expose to users in Coda. Select the fields most important to users and start there. You can always add more fields later without breaking anything.\n\nWhen designing your schema, select user-friendly names for your properties. The field in the API may use technical terminology or refer to an older name no longer in use by the product.\n\n??? example \"Example: Todoist task schema\"\n\nThe Todoist API returns up to 20 fields for a task, but for most use cases only a few are required. Additionally the name \"content\" is replaced with \"name\".\n\n=== \"API response\"\n    ```json\n    --8<-- \"samples/packs/todoist/simple.ts:json\"\n    ```\n=== \"Schema\"\n    ```ts\n    --8<-- \"samples/packs/todoist/simple.ts:schema\"\n    ```\n\n",
      "Add building blocks": "For each collection, add a set of building blocks that allow users to work with them. The exact set of building blocks may vary from collection to collection, and use the guidance below as a starting point.\n\n=== \":material-numeric-1-circle: Sync table\"\n\n!!! abstract \"Requirements\"\n    - [x] The API has an endpoint for retrieving all the items in the collection (ex: `GET /tasks`).\n\nA [sync table][sync_tables] exposes a collection as a special Coda table, allowing users to work with large sets of data using familiar conventions.\n\n- If the API endpoint support filtering the results, consider exposing those as parameters on the sync table to allow for faster, more targeted syncs.\n- If the API paginates the results, use [continuations][sync_table_continuations] to spread the requests over multiple executions and avoid timeouts.\n\n??? example \"Example: Todoist `Tasks` sync table\"\n\n    ```\n    GET https://api.todoist.com/rest/v2/tasks?\n        project_id=<project ID>&\n        section_id=<section ID>&\n        label=<label name>&\n        filter=<filter string>&\n        lang=<language code>&\n        ids=<list of IDs>\n    ```\n\n    ```ts\n    --8<-- \"samples/packs/todoist/simple.ts:sync\"\n    ```\n\n\n=== \":material-numeric-2-circle: Formula\"\n\n!!! abstract \"Requirements\"\n    - [x] The API has an endpoint for retrieving a specific item by ID (ex: `GET /tasks/123`).\n    - [x] The ID of an item is user-visible (or can be obtained from a user-visible URL).\n\nA \"getter\" [formula][formulas] allows users to retrieve the details of a specific item, which can then be composed with other formulas or tables.\n\n- The formula should take the ID and/or URL as a parameter, and return an object matching the defined schema.\n\n??? example \"Example: Todoist `Task()` formula\"\n\n    ```\n    GET https://api.todoist.com/rest/v2/tasks/<taskId>\n    ```\n\n    ```ts\n    --8<-- \"samples/packs/todoist/simple.ts:sync\"\n    ```\n\n\n=== \":material-numeric-3-circle: Column format\"\n\n!!! abstract \"Requirements\"\n    - [x] The Pack has a \"getter\" formula (previous section) that only requires a single parameter.\n\nA [column format][column_formats] makes it easier for users to work with items in tables, enriching simple values with rich data.\n\n- If the formula accepts a URL, add a matcher for the URL pattern so the column format can be automatically applied.\n\n??? example \"Example: Todoist `Task` column format\"\n\n    ```ts\n    --8<-- \"samples/packs/todoist/simple.ts:format\"\n    ```\n\n\n=== \":material-numeric-4-circle: Action formulas\"\n\n!!! abstract \"Requirements\"\n    - [x] The API has a endpoints for manipulating the collection, for instance:\n        - Creating an item (ex: `POST /tasks`)\n        - Updating an item (ex: `PUT /tasks/123`)\n        - Deleting an item (ex: `DELETE /tasks/123`)\n        - Performing a custom action (ex: `POST /tasks/123:notify`)\n\nAn [action formula][actions] allows users to update the items from within their Coda doc, either in buttons or automations. Any API calls that have side effects (change the state of the app being integrated with) should be exposed as action formulas, as regular formulas can be executed at any time by the formula engine.\n\n- When creating or updating items, use optional parameters to capture the values for individual fields.\n- In addition to a generic update action, consider adding streamlined action formulas for common tasks (ex: `Reassign`, `ChangeAddress`, etc.).\n\n??? example \"Example: Todoist `AddTask()` action formula\"\n\n    ```\n    POST https://api.todoist.com/rest/v2/tasks\n    {\n      \"content\": \"Buy milk\"\n    }\n    ```\n\n    ```ts\n    --8<-- \"samples/packs/todoist/simple.ts:action\"\n    ```\n\n\n\n[data_types]: ./basics/data-types.md\n[parameters_optional]: ./basics/parameters/index.md#optional-parameters\n[sync_tables]: ./blocks/sync-tables/index.md\n[sync_table_continuations]: ./blocks/sync-tables/index.md#longrunning\n[formulas]: ./blocks/formulas.md\n[column_formats]: ./blocks/column-formats.md\n[actions]: ./blocks/actions.md\n[todoist_reference]: https://developer.todoist.com/rest/v2/#overview\n[best_practices_featured_doc]: https://coda.io/@joebauer/best-practices-for-launching-your-pack/building-a-great-doc-for-your-pack-15\n[formulas_naming]: ./blocks/formulas.md#naming\n[actions_naming]: ./blocks/actions.md#naming\n[sync_tables_naming]: ./blocks/sync-tables/index.md#naming\n\n[]\n\nnav: Using the CLI\ndescription: The CLI allows for local development, using libraries, and more.\n\n[]"
    }
  },
  "Using the command line interface": {
    "Getting started": {
      "Requirements {: #requirements}": "The CLI requires that you have `node` and `npm` installed. We also recommend developing with TypeScript, in which case, make sure that you have TypeScript and `ts-node` installed.\n\nThe CLI makes use of the NPM package `isolated-vm` to provide emulation of the Packs execution environment. This package has its [own requirements][isolated_vm_requirements] that you may also need to install. If these requirements aren't met the SDK will still install, but `coda execute` will run Packs directly in Node instead of the emulated runtime.",
      "Installing {: #install}": {
        "Single-project install (recommended)": "Its easier to manage dependencies and avoid version conflicts across projects if you create an npm project for your Pack and install the SDK and other dependencies locally.\n\nCreate a new project directory if you havent already and initialize your project:\n\n```\n# Initialize npm and follow prompts.\nnpm init\n\n# Install the Coda Packs SDK locally in your project\nnpm install --save @codahq/packs-sdk\n```\n\nYou can now access the CLI within this directory, using the command `npx coda`.",
        "Global install": "Alternatively you can install the SDK globally and access the CLI everywhere:\n\n```\nnpm install --global @codahq/packs-sdk\n```\n\nYou can now access the CLI in any directory by typing the command `coda`."
      },
      "Create Pack definition": "Run `npx coda init` to initialize an empty project with the recommended settings and dependencies."
    },
    "Running code locally": {
      "Running formulas": "The `coda` CLI utility helps you execute formulas, via the `coda execute` sub-command. You can run `coda execute --help` at any time to refresh yourself on usage. The syntax is:\n\n```\nnpx coda execute path/to/pack.ts <formula> [params..]\n```\n\nSo for example, if your Pack definition was in `src/pack.ts` and you wanted to call a function named \"Hello\" that takes one argument, youd run:\n\n```\nnpx coda execute src/pack.ts Hello \"World\"\n```\n\nThis will execute the formula and print the output to the terminal.",
      "Passing parameters": "To pass parameters to a formula when using `coda execute`, include them as separate arguments after the formula name. Like with all Coda formulas, parameters are passed positionally.\n\n```\nnpx coda execute src/pack.ts MyFormula \"one\" \"two\" \"three\"\n```\n\n!!! note \"Wrap arguments in quotes\"\nIf your arguments have spaces or special characters in them, make sure to put them in quotation marks when specifying them on the command line.\n\nThe CLI will look at your Pack definition to determine the types of your parameters and will interpret your arguments accordingly. For example, if your formula takes a string and you pass `123` as an argument on the command line, it will know to interpret that as a string. But if your formula takes a number, it will interpret `123` as a number before executing the formula.\n\n```\n# String\nnpx coda execute src/pack.ts MyFormula \"Hello\"\n# Number\nnpx coda execute src/pack.ts MyFormula \"42\"\n# Boolean\nnpx coda execute src/pack.ts MyFormula \"true\"\n# Date\nnpx coda execute src/pack.ts MyFormula \"1955-11-12T22:04:00-08:00\"\n# Image\nnpx coda execute src/pack.ts MyFormula \"https://codahosted.io/...\"\n# HTML\nnpx coda execute src/pack.ts MyFormula \"Hello <b>World</b>\"\n```\n\nTo pass array parameters, use a single argument for the parameter separating the values by a comma. For example, the argument `[1, 2, 3]` should be passed as `\"1,2,3\"`.\n\n```\n# StringArray\nnpx coda execute src/pack.ts MyFormula \"apple,banana,carrot\"\n# NumberArray\nnpx coda execute src/pack.ts MyFormula \"1,1,2,3,5,8\"\n# BooleanArray\nnpx coda execute src/pack.ts MyFormula \"true,false,true\"\n# DateArray\nnpx coda execute src/pack.ts MyFormula \"1985-10-26,1955-11-12\"\n```\n\n!!! warning \"Can't escape commas\"\nIt currently isn't possible to escape commas in `StringArray` parameter values. To test your formula with arrays of strings containing commas you'll need to either [write a test case][testing] or [upload](#upload) it to Coda's servers and try it in a real doc.",
      "Running syncs": {
        "Two-way sync": "For sync tables that support two-way sync, you can run the `executeUpdate` function by appending `:update` to the name of the sync table.\n\n```\nnpx coda execute path/to/pack.ts <sync name>:update [params..] [updates json]\n```\n\nIn addition to passing parameter values you must also include the value of the `updates` array as a JSON string.\n\n```\nnpx coda execute src/pack.ts Items:update \"2020-12-15\" \\\n  '[{\"previousValue\":{}, \"newValue\": {}, \"updatedFields\": []}]'\n```\n\nWriting JSON on the command line can be a bit tricky however, so we recommend you author it in a file instead. The example below loads the value from `updates.json`, making sure to remove line breaks.\n\n```\nnpx coda execute src/pack.ts Items:update \"2020-12-15\" \\\n  \"$(cat updates.json | tr '\\n' ' ')\"\n```"
      },
      "Running metadata functions": "More complicated Packs may have a lot of code outside of the core `execute` function, used to generate metadata like parameter autocomplete values. You can run those functions using the CLI as well, using the same `execute` command and including additional information after the name of the formula or sync table.\n\nFor example, to execute the autocomplete function for the parameter \"language\" in the formula \"Hello\" you could run the following:\n\n```\nnpx coda execute src/pack.ts Hello:autocomplete:language\n```\n\nYou can pass a value for the search string as the first argument after the formula name.\n\n```\nnpx coda execute src/pack.ts Hello:autocomplete:language \"Eng\"\n```\n\nIn some cases the autocomplete function depends on the value of previous parameters. You can pass those parameter values as a JSON string in the second argument after the formula name. In this example, the parameter \"greeting\" depends on the value of the \"language\" parameter.\n\n```\nnpx coda execute src/pack.ts Hello:autocomplete:greeting \"\" '{\"language\": \"en\"}'\n```\n\nA similar pattern is used to call a variety of metadata functions, as shown in the list below.\n\n```\n# Parameter autocomplete\nnpx coda execute path/to/pack.ts <formula name>:autocomplete:<paramName> [query] [params JSON]\nnpx coda execute path/to/pack.ts <sync name>:autocomplete:<paramName> [query] [params JSON]\n\n# Dynamic sync tables\nnpx coda execute path/to/pack.ts <sync name>:listDynamicUrls [parentUrl]\nnpx coda execute path/to/pack.ts <sync name>:searchDynamicUrls [query]\nnpx coda execute path/to/pack.ts <sync name>:getName\nnpx coda execute path/to/pack.ts <sync name>:getDisplayUrl\nnpx coda execute path/to/pack.ts <sync name>:getSchema [unused] [params JSON]\n\n# Authentication\nnpx coda execute path/to/pack.ts Auth:getConnectionName\nnpx coda execute path/to/pack.ts Auth:postSetup:setEndpoint:<stepName>\n```"
    },
    "Authentication {: #authentication}": "The SDK will help you set up authentication in your development environment so that you can execute Pack formulas with authentication applied to them. This allows you to run your code end-to-end including making fetcher requests to external APIs.\n\nThe `coda auth` utility is used to set up authentication for a Pack. Run `coda auth --help` at any time for a refresher on how to use the utility. Mostly, its as simple as running\n\n```\nnpx coda auth path/to/pack.ts\n```\n\nThe utility will inspect your Pack definition to see what kind of authentication you have defined, and then it will prompt you to provide in the console the necessary token(s) or other parameters required by your authorization type. The resulting credentials you provide will be stored in a file `.coda-credentials.json` in the same directory as your Pack definition.\n\n!!! info \"Local OAuth2 flow\"\nIf you are using `OAuth2` authentication, after you provide the client ID and secret it will launch an OAuth flow in your browser. This flow runs a temporary, local server at `http://localhost:3000/oauth` to handle the redirect. You will need to ensure that your client ID is configured to allow this redirect URL.\n\nThe credentials will be automatically applied to your fetch requests when you execute a Pack from the CLI or a test. For more information on using the fetcher in tests, see the [Integration tests][integration] section.",
    "Uploading Packs {: #upload}": {
      "Registering an API token {: #register}": "All of the Pack upload commands work with the Coda API to upload your Pack, and hence require an API token to identify you as the user. Simply run this command, and youll be given a link to the Coda Account page to create an API token, which you can then paste in the terminal. You API token will be saved in a hidden local file named `.coda.json` in your current directory, to be used with future commands.\n\n```\nnpx coda register\n```",
      "Creating a new Pack": "When youve implemented your Pack and are ready to upload it to Coda for the first time, youll need to create new Pack on Codas servers to get assigned a Pack ID. Run this command just once for each Pack you create:\n\n```\nnpx coda create path/to/pack.ts\n```\n\nThis will create a new empty Pack on Codas servers. It will print out the url of the Pack Studio page in the Coda UI, and store the newly-assigned Pack ID in a hidden file `.coda-pack.json` in the same directory as your Pack definition. (This allows you to put multiple Pack definitions in the same repo, as long as theyre in different directories.) The ID in this file will be used in subsequent CLI commands for managing your Pack.\n\nThis command accepts optional flags for specifying a name and description for the Pack. You can always set or update the name and description in the Pack management UI later.\n\n```\nnpx coda create src/pack.ts --name \"My Pack\" --description \"My pack description.\"\n```",
      "Uploading a Pack version": "As you make changes to your Pack, when youre ready to upload them to Coda so that you can try them in a real doc, use this command to upload a new version of your Pack based on your latest code.\n\n```\nnpx coda upload path/to/pack.ts\n```\n\nOnce uploaded, as an editor of the Pack, youll be able to install this specific version of your Pack in any of your docs, without affecting the live release version of your Pack that other users may be using, giving you an opportunity to test out your latest changes in your docs before making them live to users.\n\n<!-- TODO: Un-hide this text when notes are displayed somewhere.\nThis command accepts an optional flag where you can provide notes about the contents of the version, helping you track changes from version to version.\n\n```\nnpx coda upload path/to/pack.ts --notes \"Added the formula MyNewFormula.\"\n```\n\n-->\n\n!!! info\nAt this time, this command will not upload your source code, only your compiled Pack. You will not see your source code in the web editor as you would if you had used the web code editor to compose your Pack.",
      "Creating a release": "When youve tested a Pack version and want to make that version live for users of your Pack, create a release. The Pack version that you release will become the version that is used by new installations of your Pack, and existing installations will gradually be upgraded to this version.\n\n```\nnpx coda release path/to/pack.ts <optional-version> --notes \"<Description of the release>\"\n```\n\nIf you dont pass a version argument, and don't explicitly set a version in your Pack definition, you will be prompted to use the latest version. The version must always be greater than that of any of your previous releases.  Each release must include notes that describe the changes, which are shown the Pack listing page.\n\nAlternatively, you can create releases from within the Pack Studio."
    },
    "Recommended file structure": "When using the CLI to build a Pack you can split your code into multiple files, which can be really useful for large or complex Packs. You can organize your code however you like, as long as there is a file that exports the Pack definition with the name `pack` (typically named `pack.ts`).\n\nCoda engineers have built dozens of Packs over the years, and have settled on a the recommended file structure below:\n\n['`helpers.ts` - A place to define helper functions used by your Pack.', '`pack.ts` - The core Pack definition, where all of the formulas, sync tables, and other building blocks are added.', '`schemas.ts` - A place to define the schemas (structured data types) used by your Pack.', '`types.ts` - A place to define TypeScript types for the data used by your Pack.']\n\nTo see this pattern in action check out the [CLI example Packs][github_examples] on GitHub.",
    "When to use Pack Studio": "Although a lot of Pack management can be done through the CLI, there are still some tasks that require you to visit the Pack Studio web interface. These include:\n\n['Setting the authorization credentials.', 'Setting rate limits.', \"Editing your Pack's listing page (name, icon, etc).\"]",
    "Migrating from the web editor": "It's possible to start development of a Pack in the Pack Studio web editor and later migrate to using the CLI. For example, to take advantage of an NPM library, which isn't possible in the web editor.\n\nTo migrate, first make sure you have the [required software](#requirements) installed. Then create a new directory for the Pack, [install the SDK](#install), and [register an API token](#register). Finally run `coda clone` passing in the URL of the Pack.\n\n```\nnpx coda clone \"https://coda.io/p/123456\"\n```\n\nThis will initialize the directory with the recommended settings and dependencies, download your existing Pack code into `pack.ts`, and create a `.coda-pack.json` file that links them together.\n\n!!! info \"Link only\"\nIf you've already setup your local project and just need to link it to the existing Pack use the `coda link` command instead. It will create the `.coda-pack.json` file and nothing else.\n\n```sh\nnpx coda link \"https://coda.io/p/123456\"\n```\n\n\nThe next time you run `coda upload` your Pack will be updated to use the local code. You can always get back to the previous code you wrote in the Pack Studio by visiting the [**History** tab][versions_history].\n\n[libraries]: libraries.md\n[quickstart_cli]: ../../tutorials/get-started/cli.md\n[sync_tables]: ../blocks/sync-tables/index.md\n[integration]: testing.md#integration\n[isolated_vm_requirements]: https://github.com/laverdet/isolated-vm#requirements\n[testing]: testing.md#local\n[versions_history]: versions.md#history\n[github_examples]: https://github.com/coda/packs-examples\n\n[]\n\ndescription: Add JavaScript libraries from NPM to enhance your Packs."
  },
  "Using libraries": {
    "Only available in the CLI": "At the moment you can only add libraries to your Pack when building with the Packs command line tool (CLI). If you are using the browser-based Pack Studio and want to use a library you'll have to migrate to the CLI workflow. See the [CLI getting started guide][get_started_cli] for information on how to install and setup the CLI.",
    "Use NPM": "The easiest way to install libraries is via the Node package manager (NPM). While originally created just for the Node.js environment, it's now used to distribute all sorts of JavaScript libraries. If you completed the [CLI getting started guide][get_started_cli] then you should already have NPM installed.\n\nTo add a library to your Pack simply use `npm install` to install it. For example, to install the popular JavaScript library [Lodash][lodash] you would run:\n\n```\nnpm install lodash\n```\n\nYou can then import this library into your code using either Node's `require` or the more modern `import` syntax:\n\n```\nconst _ = require('lodash');\n// ... or ...\nimport _ from 'lodash';\n```\n\n!!! info\nHow to import the library may vary; consult the library's documentation for the correct syntax.\n\n[get_started_cli]: ../../tutorials/get-started/cli.md\n[lodash]: https://lodash.com/",
    "Library compatibility": {
      "Shims": "When using the CLI, [browserify][browserify] is used to provide shims [for some Node.js modules][browserify_modules]. These shims themselves are designed to work in the browser, so not all modules that browserify supports may be supported in the Packs execution environment.\n\nAdditionally, the CLI provides optional shims for some timer-related functions (`setTimeout` and `setInterval`). To enable these shims, pass the flag `--timerStrategy=fake` when executing and uploading your Pack. Note that these shims attempt to approximate the behavior of these methods, but may not work reliably.\n\n[mdn_standard]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n[mdn_web]: https://developer.mozilla.org/en-US/docs/Web/API\n[node_apis]: https://nodejs.org/api/documentation.html\n[browserify]: https://browserify.org/\n[browserify_modules]: https://github.com/browserify/browserify#compatibility\n\n[]\n\ndescription: Utilities for Pack makers to helper them build and troubleshoot their Packs."
    }
  },
  "Pack maker tools": {
    "How to access": "There are a few different ways to open the Pack maker tools.\n\n=== \"Doc menu\"\nClick the three dots icon to the right of the doc's name and select **Toggle Pack maker tools**.\n\n<img src=\"../../../images/pmt_open_doc.png\" srcset=\"../../../images/pmt_open_doc_2x.png 2x\" class=\"screenshot\" alt=\"Open Pack maker tools from doc menu\">\n\n\n=== \"Pack side panel\"\nOpen the side panel for a Pack ({{ coda.pack_panel_clicks }}) and click the button **View logs** at the bottom. This option is only visible for users with edit access to the Pack.\n\n<img src=\"../../../images/pmt_open_panel.png\" srcset=\"../../../images/pmt_open_panel_2x.png 2x\" class=\"screenshot\" alt=\"Open Pack maker tools from Pack panel\">\n\n\n=== \"Error message\"\nHover over the broken Pack formula and click **View error details**. This option is only visible for users with edit access to the Pack.\n\n<img src=\"../../../images/pmt_open_error.png\" srcset=\"../../../images/pmt_open_error_2x.png 2x\" class=\"screenshot\" alt=\"Open Pack maker tools from a formula error\">\n\n\nThe Pack maker tools opens in the document as a panel at the bottom of the document. You can freely resize or close this panel.\n\n<img src=\"../../../images/pmt_overview.png\" srcset=\"../../../images/pmt_overview_2x.png 2x\" class=\"screenshot\" alt=\"The Pack maker tools\">",
    "Selecting the Pack": "The Pack maker tools only works with one Pack at a time. To change the selected Pack you can click the Pack name at the top of the panel and select a new one from the dropdown. You'll only be able to select Packs that are installed in the document and that you have edit access to.\n\n<img src=\"../../../images/pmt_select.png\" srcset=\"../../../images/pmt_select_2x.png 2x\" class=\"screenshot\" alt=\"Change the selected Pack\">",
    "Logs": {
      "Invocations": "The logs for your Pack are grouped by invocation, in reverse chronological order (latest invocations at the top).\n\n<img src=\"../../../images/pmt_overview.png\" srcset=\"../../../images/pmt_overview_2x.png 2x\" class=\"screenshot\" alt=\"Invocation logs\">\n\nEach invocation has a brief description, if it was successful or failed, approximately when it was run, and what version of the Pack was run (if not the latest).\n\nA new invocation is logged each time your Pack is run, for example when a formula is calculated or a button is pressed. When a sync table syncs you'll see an invocation for the initial sync, and additional invocation for each continuation of the sync.\n\n!!! info \"Duplicate invocations\"\nWhen looking at the logs you may see duplicate invocations for the same formula. Some common reasons for this include:\n\n- Using the formula editor, which runs formulas multiple times as you type to generate a preview of the result.\n- Multiple users have the doc open at the same time (each browser will run the formula).\n- The Coda backend running a recalculation as a part of normal operation.\n\n",
      "Entries": "Clicking on an invocation expands it to reveal individual log entries.\n\n<img src=\"../../../images/pmt_entries.png\" srcset=\"../../../images/pmt_entries_2x.png 2x\" class=\"screenshot\" alt=\"Log entries\">\n\nThe first entry will always be an **Overview** of the invocation. Additional entries are shown in reverse chronological order (latest entries at the top), and are added when your Pack makes a fetcher request or [logs a message][troubleshooting_logging]. If you Pack encounters an error the execution will stop and no further log entries will be added.",
      "Details": "Clicking on a log entry expands it to reveal additional details.\n\n<img src=\"../../../images/pmt_details.png\" srcset=\"../../../images/pmt_details_2x.png 2x\" class=\"screenshot\" alt=\"Log entry details\">\n\nThese details include information you can use directly (**Pack Version**, etc), as well as internal details that may be useful when working with Coda support (**Request ID**, etc). The **Overview** log entry will include a **Duration** field containing the total execution time.\n\nFailed invocations will include some additional detail in the **Overview** entry.\n\n<img src=\"../../../images/pmt_details_error.png\" srcset=\"../../../images/pmt_details_error_2x.png 2x\" class=\"screenshot\" alt=\"Log entry details for a failed invocation\">\n\nSpecifically the **Error** field will include the error message, and the **Stack trace** field will include the line number where the error happened (`code.ts:18:23` means line 18, character 23).",
      "HTTP requests": "Log entries for fetcher requests include an extra link at the bottom called **Show HTTP request details**. Clicking this link will open a dialog that shows the full details of the request, including the headers and bodies of the request and response.\n\n<img src=\"../../../images/pmt_http.png\" srcset=\"../../../images/pmt_http_2x.png 2x\" class=\"screenshot\" alt=\"HTTP request details dialog\">\n\nJust like in your Pack's code, [some headers are redacted][fetcher_headers] as well as any user credentials.",
      "Searching": "You can search for logs using the magnifying glass icon at the top of the panel.\n\n<img src=\"../../../images/pmt_search.png\" srcset=\"../../../images/pmt_search_2x.png 2x\" class=\"screenshot\" alt=\"Searching for log entries\">\n\nSearch results are no longer grouped by invocation, but instead a flat list of entries from across all invocations. You can expand an entry and click the **View related logs** link to view all of the log entries from that invocation."
    },
    "Settings {: #settings}": "The Pack maker tools also lets you adjust a few developer-specific settings for the Pack. You can access these settings by clicking the gear icon at the top of the panel.\n\n<img src=\"../../../images/pmt_settings.png\" srcset=\"../../../images/pmt_settings_2x.png 2x\" class=\"screenshot\" alt=\"Pack settings for the doc\">\n\n**Installed in this doc**\n:   Which version of the Pack to use in the doc. This allows you to test new versions of your Pack before releasing them, or roll back to previous versions to reproduce a bug. It's recommended to use **Latest Version** while developing your Pack. However, in order to publish or convert the doc to a template, you must use **Latest Release**. Also note that you will be unable to change the version in a published doc or template.\n\n**Auto-refresh formulas & tables**\n:   If you enable this setting and have selected **Latest version** above, whenever you build a new version of your Pack all of the formulas and sync tables in the doc will be automatically refreshed. This only applies to the current session (browser tab), so you'll need to turn it back on if you refresh the page or open the doc again later.",
    "Additional options {: #options}": "A few additional options are available under the three dots menu at the top of the panel. These are mostly quick links that let you jump between the various assets of the Pack, but also includes an option to force a refresh of the Pack's formulas and sync tables in the document.\n\n<img src=\"../../../images/pmt_additional.png\" srcset=\"../../../images/pmt_additional_2x.png 2x\" class=\"screenshot\" alt=\"Additional options in the Pack maker tools\">\n\n[troubleshooting_logging]: troubleshooting.md#logging\n[fetcher_headers]: ../basics/fetcher.md#headers\n\n[]\n\nnav: Testing\ndescription: Make sure your Pack is working correctly by testing it in a doc or locally.\n\n[]"
  },
  "Testing your code": {
    "In the browser": "Packs built using the web editor in the Pack Studio can only be run and tested in a live doc. Since users will always use a released version of your Pack, you can continue to build and test new versions without affecting existing users. To configure a doc to always use the latest version of your Pack, regardless of what's released, follow these steps:\n\n['Open the doc you want to use for testing.', 'Open the Pack in the sidebar.', 'Open the **Settings** tab of the Pack.', 'Click on the **View logs** button.', 'Click the gear icon (:octicons-gear-16:) to open the **Pack maker settings** dialog.', 'In the **Installed in this doc** dropdown select **Latest Version**.']\n\nWe recommend building out a dedicated doc for testing, which you can use to validate that your Pack is working as expected. Use your Pack with a variety of inputs, and compare the output to an expected value.",
    "On your local machine {: #local}": {
      "Basic formula unit test": "Heres a very simple example test, using Mocha, for a formula that doesnt make any fetcher requests:\n\n```\nimport {assert} from 'chai';\nimport {describe} from 'mocha';\nimport {executeFormulaFromPackDef} from '@codahq/packs-sdk/dist/development';\nimport {it} from 'mocha';\nimport {pack} from '../pack';\n\ndescribe('Simple Formula', () => {\n  it('executes a formula', async () => {\n    const result = await executeFormulaFromPackDef(pack, 'MyFormula', ['my-param']);\n    assert.equal(result, 'my-return-value');\n  });\n});\n```",
      "Formula unit test with mock fetcher": "A more interesting example is for a Pack that does make some kind of HTTP request using the fetcher. Here we set up a mock execution context, register a fake response on it, and pass our pre-configured mock fetcher when executing our formula.\n\n```\nimport {MockExecutionContext} from '@codahq/packs-sdk/dist/development';\nimport {assert} from 'chai';\nimport {describe} from 'mocha';\nimport {executeFormulaFromPackDef} from '@codahq/packs-sdk/dist/development';\nimport {it} from 'mocha';\nimport {pack} from '../pack';\nimport {newJsonFetchResponse} from '@codahq/packs-sdk/dist/development';\nimport {newMockExecutionContext} from '@codahq/packs-sdk/dist/development';\nimport sinon from 'sinon';\n\ndescribe('Formula with Fetcher', () => {\n  let context: MockExecutionContext;\n\n  beforeEach(() => {\n    context = newMockExecutionContext();\n  });\n\n  it('basic fetch', async () => {\n    const fakeResponse = newJsonFetchResponse({\n      id: 123,\n      name: 'Alice',\n    });\n    context.fetcher.fetch.returns(fakeResponse);\n\n    const result = await executeFormulaFromPackDef(pack, 'MyFormula', ['my-param'], context);\n\n    assert.equal(result.Name, 'Alice');\n    sinon.assert.calledOnce(context.fetcher.fetch);\n  });\n});\n```",
      "Sync unit test": "Testing a sync is very similar to testing a regular formula. However, you want to create a `MockSyncExecutionContext` instead of a vanilla execution context, and you can test that your sync handles pagination properly by setting up mock fetcher responses that will result in your sync formula return a `Continuation` at least once.\n\n```\nimport {MockSyncExecutionContext} from '@codahq/packs-sdk/dist/development';\nimport {assert} from 'chai';\nimport {describe} from 'mocha';\nimport {executeFormulaFromPackDef} from '@codahq/packs-sdk/dist/development';\nimport {it} from 'mocha';\nimport {pack} from '../pack';\nimport {newJsonFetchResponse} from '@codahq/packs-sdk/dist/development';\nimport {newMockSyncExecutionContext} from '@codahq/packs-sdk/dist/development';\nimport sinon from 'sinon';\n\ndescribe('Sync Formula', () => {\n  let syncContext: MockSyncExecutionContext;\n\n  beforeEach(() => {\n    syncContext = newMockSyncExecutionContext();\n  });\n\n  it('sync with pagination', async () => {\n    const page1Response = newJsonFetchResponse({\n      users: [{id: 123, name: 'Alice'}],\n      nextPageNumber: 2,\n    });\n    const page2Response = newJsonFetchResponse({\n      users: [{id: 456, name: 'Bob'}],\n      nextPageNumber: undefined,\n    });\n    syncContext.fetcher.fetch\n      .withArgs('/api/users')\n      .returns(page1Response)\n      .withArgs('/api/users?page=2')\n      .returns(page2Response);\n\n    const result = await executeSyncFormulaFromPackDef(pack, 'MySync', [], syncContext);\n\n    assert.equal(result.length, 2);\n    assert.equal(result[0].Id, 123);\n    assert.equal(result[1].Id, 456);\n    sinon.assert.calledTwice(syncContext.fetcher.fetch);\n  });\n});\n```",
      "Integration test {: #integration}": "If you wish to write an end-to-end integration test that actually hits the third-party API that you Pack interacts with, you can simply pass `useRealFetcher: true` when using these test utilities. The execution context will include a fetcher that will make real HTTP requests to whatever urls they are given. For example:\n\n```\nimport {assert} from 'chai';\nimport {describe} from 'mocha';\nimport {executeFormulaFromPackDef} from '@codahq/packs-sdk/dist/development';\nimport {it} from 'mocha';\nimport {pack} from '../pack';\n\ndescribe('Formula integration test', () => {\n  it('executes the formula', async () => {\n    const result = await executeFormulaFromPackDef(pack, 'MyFormula', ['my-param'], undefined, undefined, {\n      useRealFetcher: true,\n      manifestPath: require.resolve('../pack'),\n    });\n    assert.equal(result, 'my-return-value');\n  });\n});\n```\n\nThe fetcher will apply authentication to these requests if you have configured authentication locally using `coda auth`. For this to work you must specify the `manifestPath` and set it to the directory where the `.coda-credentials.json` file is located (usually the same directory as the Pack definition).",
      "Return value validation": "By default, these testing utility functions will validate return values after executing your Pack formulas. This validation checks that the values you actually return from your formula implementations match the schema you have written. This helps find bugs in your code and also helps catch subtle issues in how your values might be interpreted in the Coda application when you Pack is executed for real.\n\nThis validation can also help ensure that your test code correctly simulates responses from the API that youre integrating with. For instance, while developing our Pack, you may have been regularly exercising your formula code by running `coda execute` frequently and youre confident that your code works correctly when run against the real API. Then you go to write unit tests for you Pack and you define some fake response objects, but you forget some required fields or you specified a field as an array when it should be a comma-separated list. If your fake response result in your Pack is returning a value that doesnt match the schema you defined, the validator will catch these and notify you.\n\nThe validator will check for things like:\n\n['Does the type of the return value match the type declared in the schema? For example, if you declared that your formula returns a number but it returns a string.', 'If your formula returns an object (like all sync formulas), do all of the child properties in that object match the types declared in the schema?', 'Are all properties that are declared as `required` in the schema present and non-empty?', 'If the schema for a property declares a `codaType` type hint, can the value actually be interpreted as the hinted type? For example, if you declare a property as a string and give a hint type of `ValueType.DateTime`, the validator will try to parse the value as a datetime and give an error if that fails.']\n\nThe validator does not perfectly represent how Coda will process your return values at runtime but is intended to help catch the most common bugs so that you can fix them before uploading your Pack to Coda.\n\nIf desired, you can disable return value validation by passing `validateResult: false` in the `ExecuteOptions` argument of these testing utilities.\n\n[cli]: cli.md\n\n[]\n\nnav: Troubleshooting\ndescription: Tools and tips for how to find and fix problems in your Pack.\n\n[]"
    }
  },
  "How to troubleshoot your code": {
    "Logging": "You can log messages using the standard JavaScript logging method, `console.log()`.\n\n```\nlet response = context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://api.example.com/items\"\n});\nlet items = response.body.items;\nconsole.log(\"Retrieved %s items.\", items.length);\n```\n\nWhen executing a Pack locally these logs will be written to the console, and when run in a doc they will be visible in the [Pack maker tools][pmt]. This can be useful for debugging during development as well as in production.\n\nThe Packs runtime only includes a subset of the [full `console` methods][mdn_console], specifically:\n\n['`console.debug()`', '`console.error()`', '`console.info()`', '`console.log()`', '`console.trace()`', '`console.warn()`']",
    "HTTP request logs": "For Packs that make HTTP requests to external services and APIs it can be useful to see the details of the outgoing and request and incoming response. Whenever a Pack is run in a Coda doc the HTTP requests are automatically logged and can be inspected in the [Pack maker tools][pmt_http].\n\nWhen executing a Pack locally using the Pack CLI, you can use Node's built-in HTTP debug logs to see the raw requests and responses. To enable this logging, set the environment variable `NODE_DEBUG=http`. This can be done for a single execution by adding it before the execute command.\n\n```\nNODE_DEBUG=http npx coda execute pack.ts Hello \"World\"\n```",
    "Debugging": "When developing using the Pack CLI you can connect a JavaScript debugger to your Pack code. This allows you to set breakpoints, examine variables, and step through your code line by line. It requires a bit more setup than simply logging values but is much more flexible.\n\nBy default the `coda execute` command runs your Pack code in a limited JavaScript VM that emulates the Packs runtime. This VM lacks the debugging capability however, so you must run your Pack with the `--vm=false` flag to execute it in Node.js directly.\n\nFor example, to use the debugger in the VS Code IDE follow these steps:\n\n['Add a `debugger;` statement to your code where you want to add a breakpoint. Setting a breakpoint in the IDE itself (the red dot in the gutter to the left of the line) works in some environments, but has known issues in others.', 'Open a **JavaScript Debug Terminal** (run **Debug: Create JavaScript Debug Terminal** from the command palette).', 'Run the `npx coda execute` command passing in the flag `--vm=false`. For example:', '```npx coda execute --vm=false pack.ts Hello \"Eric\"```']\n\n[mdn_console]: https://developer.mozilla.org/en-US/docs/Web/API/console\n[pmt]: pack-maker-tools.md\n[pmt_http]: pack-maker-tools.md#http-requests\n\n[]\n\nnav: Versions & releases\ndescription: Create new builds of your Pack and release them to users.\n\n[]"
  },
  "Managing versions and releases": {
    "Versions": {
      "Version numbers": "By default version numbers are automatically generated for you, as a set of incrementing whole numbers (1, 2, 3, etc). In various places throughout the user interface they are presented with a preceding \"v\" character, to indicate they are a version number (\"v1\", \"v2\", etc).\n\nIt is possible to manually set the version numbers, by calling the `setVersion()` method in your code:\n\n```\nexport const pack = coda.newPack();\npack.setVersion(\"1.0.5\");\n```\n\nThere are some restrictions to the version numbers you can select however:\n\n['The version numbers must increase with each new build / upload.', 'The version numbers must follow the [SemVer standard][semver], meaning them must be of the form `1`, `1.2`, or `1.2.3`.', 'If you make a user-visible change to your Pack Coda will enforce standards on your version number:', ['A new minor version if you make a backwards-compatible change (add a new building block or parameter, etc).', 'A new major version if you make a backwards-incompatible change (add a new request parameter, remove a building block, etc).']]",
      "Version history {: #history}": "The **History** section in the Pack Studio shows a log of all past versions of your code, including when they were created and by who. For each version you can also download the code at that checkpoint or restore it.\n\n<img src=\"../../../images/versions_restore.png\" srcset=\"../../../images/versions_restore_2x.png 2x\" class=\"screenshot\" alt=\"Version history of a Pack\">\n\nRestoring a previous version simply loads the code from that version into the web editor, and you'll need to re-build that code (and hence create a new version) to actually change the state of your Pack.\n\n!!! warning \"Pack CLI doesn't upload source code\"\nThe download and restore options aren't available for versions created using the Pack CLI. The CLI doesn't upload the source code, only the compiled version of your Pack. When developing using the CLI we recommend you use a version control system like [Git][git] to store a history of your source code."
    },
    "Releases": {
      "Corresponding versions": "To determine which version of your Pack a given release corresponds to, visit the **History** section of the Pack Studio. Release numbers will be displayed next to their corresponding version, and the **Released** tab can be used to filter the versions to just those that were released.\n\n<img src=\"../../../images/versions_releases.png\" srcset=\"../../../images/versions_releases_2x.png 2x\" class=\"screenshot\" alt=\"Versions tagged with release\">",
      "Rollout": "Creating a new release only takes a moment, but it can take much longer for it to reach your users. A few minutes after you create the release Coda begins the process of upgrading existing docs that use your Pack to the new release. This process can take anywhere from a few minutes to a few hours, depending on how many docs need to be processed.",
      "Rollbacks": "Let's say you release a new version of your Pack only to discover that it has a critical bug. Given how versions and releases work in Packs, to rollback to the previous release you must:\n\n[\"Restore your code to the point of the previous release's version (see [Version history](#history) above).\", 'Create a new version using that code.', 'Create a new release using that version.']\n\nTo your users it will appear as if you've released a new version of your Pack, but it will contain the code of the previous stable version."
    },
    "Which version is in use": "When a user installs your Pack they have only one choice of what version to use: the latest release. The Pack side panel will show them the release number, but not the associated version number.\n\n<img src=\"../../../images/versions_installed.png\" srcset=\"../../../images/versions_installed_2x.png 2x\" class=\"screenshot\" alt=\"Pack side panel showing release installed\">\n\nPack makers can choose to install a different version however, which is useful when testing out new versions before releasing them. Do this in the [Pack maker tools][pmt_settings] panel. Select **Latest Version** to always use the latest build of your Pack, or a specific version if for example you want to reproduce an issue on an earlier release.\n\n!!! info \"Default for Pack makers\"\nBefore your Pack has any releases, when you install it the doc will be set to use the **Latest Version**. Making your first release won't change any of your existing docs, but when adding your Pack to a new doc you'll default to **Latest Release** just like your users.\n\n!!! warning \"Don't use latest version for published docs\"\nThe **Latest Version** option is useful for developing and testing, but before publishing a doc you should make sure it's set to **Latest Release**. This ensures that you don't break your doc as you make changes to your Pack, and that users get the same behavior when they copy the doc.\n\n[semver]: https://semver.org/\n[git]: https://git-scm.com/\n[pmt_settings]: pack-maker-tools.md#settings\n\n[]\n\nnav: Overview\ndescription: A quick introduction to what Packs are and how they work.\n\n[]"
  },
  "What are Packs?": {
    "What can Packs do?": "Packs can extend Coda in four specific ways:\n\n=== \"Formulas\"\n\nPacks can add new formulas for the [Coda formula language][formula_list]. These formulas can do simple calculations, call a library, or pull in data from an external source.\n\n<figure>\n  <img src=\"../../images/overview_formula.png\" srcset=\"../../images/overview_formula_2x.png 2x\" alt=\"A custom formula in the formula editor\">\n  <figcaption>A formula from the Google Calendar Pack which looks up when the user has busy time on their calendar.</figcaption>\n</figure>\n\n[Learn more][formulas]{ .md-button }\n\n\n=== \"Actions\"\n\nPacks can add new actions, which are a special type of formula that powers [buttons][help_buttons] and [automations][help_automations]. These actions typically make a change in an external application.\n\n<figure>\n  <img src=\"../../images/overview_action.png\" srcset=\"../../images/overview_action_2x.png 2x\" alt=\"A custom action in a button\">\n  <figcaption>A button being configured with an action from the the Google Calendar Pack that creates a new event in the user's calendar.</figcaption>\n</figure>\n\n[Learn more][actions]{ .md-button }\n\n\n=== \"Column formats\"\n\nPacks can add new [column formats][help_format], which control how values are displayed within a table. They can simply reformat the data or enrich it with related information from an external source.\n\n<figure>\n  <img src=\"../../images/overview_column_format.png\" srcset=\"../../images/overview_column_format_2x.png 2x\" class=\"screenshot\" alt=\"A custom column format\">\n  <figcaption>A column format from the Google Calendar Pack that displays rich information about an event provided its URL.</figcaption>\n</figure>\n\n[Learn more][column_formats]{ .md-button }\n\n\n=== \"Pack tables\"\n\nPacks can add [Pack tables][help_pack_table], which are a special type of table that automatically syncs in data from an outside source. These tables are often used to bring in records from other apps or productivity tools.\n\n<figure>\n  <img src=\"../../images/overview_sync_table.png\" srcset=\"../../images/overview_sync_table_2x.png 2x\" class=\"screenshot\" alt=\"A Pack table that syncs from an external source\">\n  <figcaption>A table from the Google Calendar Pack that pulls in the upcoming events on a user's calendar.</figcaption>\n</figure>\n\n[Learn more][sync_tables]{ .md-button }\n\n",
    "Who can build Packs?": "Anyone with a Coda account is able to build a Pack, and getting started is as easy as clicking the \"Create a Pack\" button in the app. Our Pack Studio comes bundled with all the tools you'll need to write, build, and deploy a Pack, all without leaving your browser. And for more advanced developers we provide a command-line tool, allowing you to use your favorite IDE, tooling, and version control system.\n\nYou will need to have a basic understanding of JavaScript or TypeScript to be successful, so if you're new to coding an [online JavaScript course][codecademy] might be a good place to start. We also have a large library of examples and templates built into the Pack Studio, plus a [friendly community][community] of fellow Pack makers that can help you along the way.\n\n[Build your first Pack][quickstart_web]{ .md-button }",
    "How do Packs work?": "Each Pack is its own [serverless application][wikipedia_serverless], fully managed and run by Coda. All you have to do is write the code and we'll take care of the rest.\n\nAll Pack code is run on the server, ensuring a consistent and secure environment. Each execution of a Pack can run for at most a minute, but there are features that allow for longer running operations.\n\nUnlike other scripting languages, Packs don't automatically have access to all of the data within the doc. Instead users pass the Pack only the specific parameters it requires. Packs can then make requests to external APIs to fetch more data, including our own [Coda API][api].\n\n```\nsequenceDiagram\n  participant Doc as Doc (browser)\n  participant Pack as Pack (server)\n  participant API as External API\n  Doc->>+Pack: Execute Pack\n  Note left of Pack: Passes parameters\n  opt 0+ times\n    Pack->>API: HTTP request\n    API-->>Pack: Data\n  end\n  Pack-->>-Doc: Result\n```\n\nPacks are run in a custom JavaScript execution environment created by Coda, compatible with the [ES2022 standard][mdn_ecmascript]. You can use all the modern JavaScript features, but browser- and Node-specific objects are not available (`window`, `fs`, etc).\n\n[packs_landing]: https://coda.io/packs\n[packs_why]: https://coda.io/why-build-packs\n[gallery_slack]: https://coda.io/packs/slack-1000\n[formula_list]: https://coda.io/formulas\n[help_buttons]: https://help.coda.io/en/articles/2033889-overview-of-buttons\n[help_automations]: https://help.coda.io/en/articles/2423860-automations-in-coda\n[help_format]: https://help.coda.io/en/articles/1235680-overview-of-column-formats\n[help_pack_table]: https://help.coda.io/en/articles/3213629-using-packs-tables-to-sync-your-data-into-coda\n[codecademy]: https://www.codecademy.com/learn/introduction-to-javascript\n[community]: https://community.coda.io/c/developers-central/making-packs/15\n[quickstart_web]: ../tutorials/get-started/web.md\n[quickstart_cli]: ../tutorials/get-started/cli.md\n[wikipedia_serverless]: https://en.wikipedia.org/wiki/Serverless_computing\n[mdn_ecmascript]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources\n[api]: https://coda.io/developers/apis/v1\n[formulas]: blocks/formulas.md\n[actions]: blocks/actions.md\n[column_formats]: blocks/column-formats.md\n[sync_tables]: blocks/sync-tables/index.md\n[help_admin]: https://help.coda.io/en/articles/5574990-managing-packs-approvals-for-enterprise-admins\n[gallery_packs]: https://coda.io/gallery?filter=packs\n\n[]\n\nnav: Home\ndescription: A Pack is an extension that adds new powers to your doc. With a little JavaScript, anyone can create and publish one.\nhide:\n\n['navigation', 'toc']\n\n[]"
  },
  "Build Packs for Coda": "A Pack is an extension that adds new powers to your doc. Packs work by supplementing the core building blocks of Coda, so you can customize how your doc looks, works, and integrates.\n\n<section class=\"landing-row\" markdown>\n\n<div class=\"landing-item\" markdown>\n## :material-toy-brick-outline: Lets build building blocks together.\n\nWith a little JavaScript, anyone can create and publish a Pack to the Gallery. All you need to do is write the code and Coda will deploy and host the Pack for you.\n\nPacks can be created for personal use, shared with a team, or published to the world. Everything from simple utilities to rich integrations can be built with Packs.\n\n[Learn more][overview]{ .md-button .md-button--primary }\n\n</div>\n\n<div class=\"landing-item\" markdown>\n<video style=\"width:auto\" loop muted autoplay alt=\"Illustration video of using a Pack.\" class=\"screenshot\"><source src=\"images/home_demo.mp4\" type=\"video/mp4\"></source></video>\n</div>\n\n</section>\n\n[]\n\n<section class=\"landing-row landing-row-reverse\" markdown>\n\n<div class=\"landing-item\" markdown>\n## :octicons-stopwatch-16: Build your first Pack in minutes.\n\nUsing Coda's Pack Studio you can write, build, and deploy your Pack all from your browser. Nothing to download or install.\n\n[Get started][get_started]{ .md-button .md-button--primary }\n\nOr for you power users, build a Pack using the `coda` command line tool on your [local machine][tutorial_cli], [GitHub :octicons-mark-github-16:][tutorial_github], [Gitpod :simple-gitpod:][tutorial_gitpod], or [Replit :simple-replit:][tutorial_replit].\n\n</div>\n\n<div class=\"landing-item\" markdown>\n<video style=\"width:auto\" loop muted autoplay alt=\"Creating a Pack in the Pack Studio.\" class=\"screenshot\"><source src=\"images/web_ide_build.mp4\" type=\"video/mp4\"></source></video>\n</div>\n\n</section>\n\n<br>\n\n<section class=\"box-row\" markdown>\n\n<div class=\"box-item\" markdown>\n### :octicons-terminal-16: Command line tool\n\nUse the CLI to develop Packs on your local machine, where you can use the IDE, tooling, and version control of your choice.\n\n[Install CLI][cli]{ .md-button }\n\n</div>\n\n<div class=\"box-item\" markdown>\n### :material-application-braces-outline: Sample code\n\nFrom Math to GitHub to Cat Photos, we've got dozens of examples written covering all major aspects of the SDK.\n\n[Browse samples][samples]{ .md-button }\n\n</div>\n\n<div class=\"box-item\" markdown>\n### :fontawesome-solid-people-group: Community\n\nOur passionate community of Pack makers and Coda experts can help answer your questions or share tips to get you started.\n\n[Join the community][community]{ .md-button }\n\n</div>\n\n</section>\n\n<br>\n\n<section class=\"landing-row\" markdown>\n\n<div class=\"landing-item\" markdown>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/z8J6kBxAod4\" title=\"YouTube video player: Your team hub needs more photos of dogs\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"landing-item\" markdown>\n## :material-youtube: Grab the popcorn.\n\nSit back, relax, and watch as Developer Advocate Eric Koleda builds a Pack from scratch in under 5 minutes and 20 lines of code. After that check out other videos covering topics like building blocks and the CLI.\n\n[More videos][videos]{ .md-button }\n\n</div>\n\n</section>\n\n<section class=\"landing-row\" markdown>\n\n<div class=\"landing-item\" markdown>\n## :fontawesome-regular-lightbulb: Get inspired.\n\nCoda makers have been busy building Packs of all types, and many have published their work to the Gallery. Try installing a few Packs to get a sense for what you could build.\n\n[Browse the Gallery][gallery]{ .md-button }\n\n</div>\n\n<div class=\"landing-item\" markdown>\n![Packs in the Gallery](images/home_gallery.png)\n</div>\n\n</section>\n\n[overview]: guides/overview.md\n[get_started]: tutorials/get-started/web.md\n[cli]: guides/development/cli.md\n[samples]: samples/index.md\n[changelog]: reference/changes.md\n[community]: https://community.coda.io/c/developers-central/making-packs/15\n[gallery]: https://coda.io/gallery?filter=packs\n[videos]: tutorials/videos.md\n[tutorial_cli]: tutorials/get-started/cli.md\n[tutorial_github]: tutorials/get-started/github.md\n[tutorial_gitpod]: tutorials/get-started/gitpod.md\n[tutorial_replit]: tutorials/get-started/replit.md\n\n[]\n\nnav: \"MissingScopesError\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Class: MissingScopesError": {
    "Hierarchy": [
      "`Error`",
      " **`MissingScopesError`**"
    ],
    "Properties": {
      "name": {
        "Overrides": "Error.name"
      }
    },
    "Methods": {
      "isMissingScopesError": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `err` | `any` |",
        "Returns": "err is MissingScopesError\n\n[]\n\nnav: \"PackDefinitionBuilder\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Class: PackDefinitionBuilder": {
    "Implements": [
      "[`BasicPackDefinition`](../types/core.BasicPackDefinition.md)"
    ],
    "Constructors": {
      "constructor": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `definition?` | `Partial`<[`PackVersionDefinition`](../interfaces/core.PackVersionDefinition.md)\\> |"
      }
    },
    "Properties": {
      "defaultAuthentication": {
        "Implementation of": "BasicPackDefinition.defaultAuthentication\n\n[]"
      },
      "formats": {
        "Implementation of": "BasicPackDefinition.formats\n\n[]"
      },
      "formulaNamespace": {
        "Implementation of": "BasicPackDefinition.formulaNamespace\n\n[]"
      },
      "formulas": {
        "Implementation of": "BasicPackDefinition.formulas\n\n[]"
      },
      "networkDomains": {
        "Implementation of": "BasicPackDefinition.networkDomains\n\n[]"
      },
      "syncTables": {
        "Implementation of": "BasicPackDefinition.syncTables\n\n[]"
      },
      "systemConnectionAuthentication": {
        "Implementation of": "BasicPackDefinition.systemConnectionAuthentication\n\n[]"
      },
      "version": " `Optional` **version**: `string`\n\nSee [version](../interfaces/core.PackVersionDefinition.md#version)."
    },
    "Methods": {
      "addColumnFormat": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `format` | [`Format`](../interfaces/core.Format.md) |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "addDynamicSyncTable": {
        "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<`any`, `any`, `any`\\> |",
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `definition` | [`DynamicSyncTableOptions`](../interfaces/core.DynamicSyncTableOptions.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\> |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "addFormula": {
        "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `ResultT` | extends [`ValueType`](../enums/core.ValueType.md) |\n| `SchemaT` | extends [`Schema`](../types/core.Schema.md) |",
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `definition` | { `resultType`: `ResultT`  } & [`FormulaDefinition`](../types/core.FormulaDefinition.md)<`ParamDefsT`, `ResultT`, `SchemaT`\\> |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "addNetworkDomain": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `...domain` | `string`[] |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "addSyncTable": {
        "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends `ObjectSchema`<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<`any`, `any`, `any`\\> |",
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `definition` | [`SyncTableOptions`](../interfaces/core.SyncTableOptions.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\> |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "setSystemAuthentication": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `systemAuthentication` | [`SystemAuthenticationDef`](../types/core.SystemAuthenticationDef.md) |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "setUserAuthentication": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `authDef` | [`UserAuthenticationDef`](../types/core.UserAuthenticationDef.md) |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]"
      },
      "setVersion": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `version` | `string` |",
        "Returns": "[`PackDefinitionBuilder`](core.PackDefinitionBuilder.md)\n\n[]\n\nnav: \"StatusCodeError\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Class: StatusCodeError": {
    "Hierarchy": [
      "`Error`",
      " **`StatusCodeError`**"
    ],
    "Properties": {
      "body": " **body**: `any`\n\nThe parsed body of the HTTP response.\n\n[]",
      "error": " **error**: `any`\n\nAlias for [body](core.StatusCodeError.md#body).\n\n[]",
      "name": {
        "Overrides": "Error.name\n\n[]"
      },
      "options": " **options**: [`FetchRequest`](../interfaces/core.FetchRequest.md)\n\nThe original fetcher request used to make this HTTP request.\n\n[]",
      "response": " **response**: [`StatusCodeErrorResponse`](../interfaces/core.StatusCodeErrorResponse.md)\n\nThe raw HTTP response, including headers.\n\n[]",
      "statusCode": " **statusCode**: `number`\n\nThe HTTP status code, e.g. `404`."
    },
    "Methods": {
      "isStatusCodeError": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `err` | `any` |",
        "Returns": "err is StatusCodeError\n\n[]\n\nnav: \"UserVisibleError\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Class: UserVisibleError": {
    "Hierarchy": [
      "`Error`",
      " **`UserVisibleError`**"
    ],
    "Constructors": {
      "constructor": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `message?` | `string` |\n| `internalError?` | `Error` |",
        "Overrides": "Error.constructor\n\n[]\n\nnav: \"AttributionNodeType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Enumeration: AttributionNodeType": {
    "Enumeration Members": {
      "Image": " **Image** = ``3``\n\nAn image, often a logo of the data source.\n\n[]",
      "Link": " **Link** = ``2``\n\nA hyperlink pointing to the data source.\n\n[]",
      "Text": " **Text** = ``1``\n\nText attribution content.\n\n[]\n\nnav: \"AuthenticationType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: AuthenticationType": {
    "Enumeration Members": {
      "AWSAccessKey": " **AWSAccessKey** = ``\"AWSAccessKey\"``\n\nAuthenticate to Amazon Web Services using an IAM access key id & secret access key pair.\n\n**`See`**\n\n[AWSAccessKeyAuthentication](../interfaces/core.AWSAccessKeyAuthentication.md)\n\n[]",
      "AWSAssumeRole": " **AWSAssumeRole** = ``\"AWSAssumeRole\"``\n\nAuthenticate to Amazon Web Services by assuming an IAM role.\n\n**`See`**\n\n[AWSAssumeRoleAuthentication](../interfaces/core.AWSAssumeRoleAuthentication.md)\n\n[]",
      "CodaApiHeaderBearerToken": " **CodaApiHeaderBearerToken** = ``\"CodaApiHeaderBearerToken\"``\n\nAuthenticate using a Coda REST API token, sent as an HTTP header.\n\n**`See`**\n\n[CodaApiBearerTokenAuthentication](../interfaces/core.CodaApiBearerTokenAuthentication.md)\n\n[]",
      "Custom": " **Custom** = ``\"Custom\"``\n\nAuthenticate in a custom way by having one or more arbitrary secret values inserted into the request URL, body,\nheaders, or the form data using template replacement. Approval from Coda is required.\n\n**`See`**\n\n[CustomAuthentication](../interfaces/core.CustomAuthentication.md)\n\n[]",
      "CustomHeaderToken": " **CustomHeaderToken** = ``\"CustomHeaderToken\"``\n\nAuthenticate using an HTTP header with a custom name and token prefix that you specify.\n\n**`See`**\n\n[CustomHeaderTokenAuthentication](../interfaces/core.CustomHeaderTokenAuthentication.md)\n\n[]",
      "HeaderBearerToken": " **HeaderBearerToken** = ``\"HeaderBearerToken\"``\n\nAuthenticate using an HTTP header of the form `Authorization: Bearer <token>`.\n\n**`See`**\n\n[HeaderBearerTokenAuthentication](../interfaces/core.HeaderBearerTokenAuthentication.md)\n\n[]",
      "MultiHeaderToken": " **MultiHeaderToken** = ``\"MultiHeaderToken\"``\n\nAuthenticate using multiple HTTP headers that you specify.\n\n**`See`**\n\n[MultiHeaderTokenAuthentication](../interfaces/core.MultiHeaderTokenAuthentication.md)\n\n[]",
      "MultiQueryParamToken": " **MultiQueryParamToken** = ``\"MultiQueryParamToken\"``\n\nAuthenticate using multiple tokens, each passed as a different URL parameter, e.g.\n`https://example.com/api?param1=token1&param2=token2`\n\n**`See`**\n\n[MultiQueryParamTokenAuthentication](../interfaces/core.MultiQueryParamTokenAuthentication.md)\n\n[]",
      "None": " **None** = ``\"None\"``\n\nIndicates this pack does not use authentication. You may also omit an authentication declaration entirely.\n\n[]",
      "OAuth2": " **OAuth2** = ``\"OAuth2\"``\n\nAuthenticate using OAuth2. This is the most common type of OAuth2, which involves the user approving access to\ntheir account before being granted a token.\nThe API must use a (largely) standards-compliant implementation of OAuth2.\n\n**`See`**\n\n[OAuth2Authentication](../interfaces/core.OAuth2Authentication.md)\n\n[]",
      "OAuth2ClientCredentials": " **OAuth2ClientCredentials** = ``\"OAuth2ClientCredentials\"``\n\nAuthenticate using OAuth2 client credentials. This is a less common type of OAuth2,\nwhich involves exchanging a client ID and secret for a temporary access token.\n\n**`See`**\n\n['[OAuth2 client credentials spec](https://oauth.net/2/grant-types/client-credentials/)', '[OAuth2ClientCredentials](core.AuthenticationType.md#oauth2clientcredentials)']\n\n[]",
      "QueryParamToken": " **QueryParamToken** = ``\"QueryParamToken\"``\n\nAuthenticate using a token that is passed as a URL parameter with each request, e.g.\n`https://example.com/api?paramName=token`.\n\n**`See`**\n\n[QueryParamTokenAuthentication](../interfaces/core.QueryParamTokenAuthentication.md)\n\n[]",
      "WebBasic": " **WebBasic** = ``\"WebBasic\"``\n\nAuthenticate using HTTP Basic authorization. The user provides a username and password\n(sometimes optional) which are included as an HTTP header according to the Basic auth standard.\n\n**`See`**\n\n[WebBasicAuthentication](../interfaces/core.WebBasicAuthentication.md)\n\n[]\n\nnav: \"ConnectionRequirement\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ConnectionRequirement": {
    "Enumeration Members": {
      "None": " **None** = ``\"none\"``\n\nIndicates this building block does not make use of an account.\n\n[]",
      "Optional": " **Optional** = ``\"optional\"``\n\nIndicates that this building block can be used with or without an account.\n\nAn optional parameter will be added to the formula (or sync formula) for the calling user\nto specify an account to use.\n\n[]",
      "Required": " **Required** = ``\"required\"``\n\nIndicates that this building block must be used with an account.\n\nA required parameter will be added to the formula (or sync formula) for the calling user\nto specify an account to use.\n\n[]\n\nnav: \"CurrencyFormat\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: CurrencyFormat": {
    "Enumeration Members": {
      "Accounting": " **Accounting** = ``\"accounting\"``\n\nIndicates the value should be rendered as a number with a currency symbol as a prefix, but padded\nto allow the numeric values to line up vertically, e.g.\n\n```\n$       2.50\n$      29.99\n```\n\n[]",
      "Currency": " **Currency** = ``\"currency\"``\n\nIndicates the value should be rendered as a number with a currency symbol as a prefix, e.g. `$2.50`.\n\n[]",
      "Financial": " **Financial** = ``\"financial\"``\n\nIndicates the value should be rendered as a number without a currency symbol, e.g. `2.50`.\n\n[]\n\nnav: \"DurationUnit\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: DurationUnit": {
    "Enumeration Members": {
      "Days": " **Days** = ``\"days\"``\n\nIndications a duration as a number of days.\n\n[]",
      "Hours": " **Hours** = ``\"hours\"``\n\nIndications a duration as a number of hours.\n\n[]",
      "Minutes": " **Minutes** = ``\"minutes\"``\n\nIndications a duration as a number of minutes.\n\n[]",
      "Seconds": " **Seconds** = ``\"seconds\"``\n\nIndications a duration as a number of seconds.\n\n[]\n\nnav: \"EmailDisplayType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: EmailDisplayType": {
    "Enumeration Members": {
      "EmailOnly": " **EmailOnly** = ``\"emailOnly\"``\n\nDisplay email address only.\n\n[]",
      "IconAndEmail": " **IconAndEmail** = ``\"iconAndEmail\"``\n\nDisplay both icon and email (default).\n\n[]",
      "IconOnly": " **IconOnly** = ``\"iconOnly\"``\n\nDisplay icon only.\n\n[]\n\nnav: \"ImageCornerStyle\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ImageCornerStyle": {
    "Enumeration Members": {
      "Rounded": " **Rounded** = ``\"rounded\"``\n\nImage is rendered with rounded corners.\n\n[]",
      "Square": " **Square** = ``\"square\"``\n\nImage is rendered with square corners.\n\n[]\n\nnav: \"ImageOutline\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ImageOutline": {
    "Enumeration Members": {
      "Disabled": " **Disabled** = ``\"disabled\"``\n\nImage is rendered without outline.\n\n[]",
      "Solid": " **Solid** = ``\"solid\"``\n\nImage is rendered with outline.\n\n[]\n\nnav: \"ImageShapeStyle\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ImageShapeStyle": {
    "Enumeration Members": {
      "Auto": " **Auto** = ``\"auto\"``\n\nImage is rendered normally.\n\n[]",
      "Circle": " **Circle** = ``\"circle\"``\n\nImage is rendered as a circle.\n\n[]\n\nnav: \"LinkDisplayType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: LinkDisplayType": {
    "Enumeration Members": {
      "Card": " **Card** = ``\"card\"``\n\nDisplay the referenced web page as a card.\n\n[]",
      "Embed": " **Embed** = ``\"embed\"``\n\nDisplay the referenced web page as an embed.\n\n[]",
      "IconOnly": " **IconOnly** = ``\"iconOnly\"``\n\nDisplay icon only.\n\n[]",
      "Title": " **Title** = ``\"title\"``\n\nDisplay web page title.\n\n[]",
      "Url": " **Url** = ``\"url\"``\n\nDisplay URL.\n\n[]\n\nnav: \"NetworkConnection\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: NetworkConnection": {
    "Enumeration Members": {
      "None": " **None** = ``\"none\"``\n\n[]",
      "Optional": " **Optional** = ``\"optional\"``\n\n[]",
      "Required": " **Required** = ``\"required\"``\n\n[]\n\nnav: \"OptionsType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: OptionsType": {
    "Enumeration Members": {
      "Dynamic": " **Dynamic** = ``\"__coda_dynamic__\"``\n\nThe property's options should be generated by the sync table's\n[propertyOptions](../interfaces/core.DynamicSyncTableOptions.md#propertyoptions) function.\n\n[]\n\nnav: \"ParameterType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ParameterType": {
    "Enumeration Members": {
      "Boolean": " **Boolean** = ``\"boolean\"``\n\nIndicates a parameter that is a Coda boolean value.\n\n[]",
      "BooleanArray": " **BooleanArray** = ``\"booleanArray\"``\n\nIndicates a parameter that is a list of Coda boolean values.\n\n[]",
      "Date": " **Date** = ``\"date\"``\n\nIndicates a parameter that is a Coda date value (which includes time and datetime values).\n\n[]",
      "DateArray": " **DateArray** = ``\"dateArray\"``\n\nIndicates a parameter that is a list of Coda date values (which includes time and datetime values).\n\nCurrently, when such a parameter is used with a sync table formula or an action formula\n([isAction](../interfaces/core.BaseFormulaDef.md#isaction)), which will generate a builder UI for selecting parameters, a date array\nparameter will always render as a date range selector. A date range will always be passed to a pack formula\nas a list of two elements, the beginning of the range and the end of the range.\n\n[]",
      "File": " **File** = ``\"file\"``\n\nIndicates a parameter that is a Coda file. The pack is passed a file URL.\n\n[]",
      "FileArray": " **FileArray** = ``\"fileArray\"``\n\nIndicates a parameter that is a list of Coda file values. The pack is passed a list of file URLs.\n\n[]",
      "Html": " **Html** = ``\"html\"``\n\nIndicates a parameter that is a Coda rich text value that should be passed to the pack as HTML.\n\n[]",
      "HtmlArray": " **HtmlArray** = ``\"htmlArray`\"``\n\nIndicates a parameter that is a list of Coda rich text values that should be passed to the pack as HTML.\n\n[]",
      "Image": " **Image** = ``\"image\"``\n\nIndicates a parameter that is a Coda image. The pack is passed an image URL.\n\n[]",
      "ImageArray": " **ImageArray** = ``\"imageArray\"``\n\nIndicates a parameter that is a list of Coda image values. The pack is passed a list of image URLs.\n\n[]",
      "Markdown": " **Markdown** = ``\"markdown\"``\n\nIndicates a parameter that is a Coda rich text value that should be passed to the pack as Markdown.\n\n[]",
      "MarkdownArray": " **MarkdownArray** = ``\"markdownArray`\"``\n\nIndicates a parameter that is a list of Coda rich text values that should be passed to the pack as Markdown.\n\n[]",
      "Number": " **Number** = ``\"number\"``\n\nIndicates a parameter that is a Coda number value.\n\n[]",
      "NumberArray": " **NumberArray** = ``\"numberArray\"``\n\nIndicates a parameter that is a list of Coda number values.\n\n[]",
      "SparseBooleanArray": " **SparseBooleanArray** = ``\"sparseBooleanArray\"``\n\n[BooleanArray](core.ParameterType.md#booleanarray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseDateArray": " **SparseDateArray** = ``\"sparseDateArray\"``\n\n[DateArray](core.ParameterType.md#datearray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseFileArray": " **SparseFileArray** = ``\"sparseFileArray\"``\n\n[FileArray](core.ParameterType.md#filearray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseHtmlArray": " **SparseHtmlArray** = ``\"sparseHtmlArray\"``\n\n[HtmlArray](core.ParameterType.md#htmlarray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseImageArray": " **SparseImageArray** = ``\"sparseImageArray\"``\n\n[ImageArray](core.ParameterType.md#imagearray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseMarkdownArray": " **SparseMarkdownArray** = ``\"sparseMarkdownArray\"``\n\n[MarkdownArray](core.ParameterType.md#markdownarray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseNumberArray": " **SparseNumberArray** = ``\"sparseNumberArray\"``\n\n[NumberArray](core.ParameterType.md#numberarray) that accepts unparsable values as `undefined`.\n\n[]",
      "SparseStringArray": " **SparseStringArray** = ``\"sparseStringArray\"``\n\n[StringArray](core.ParameterType.md#stringarray) that accepts unparsable values as `undefined`.\n\n[]",
      "String": " **String** = ``\"string\"``\n\nIndicates a parameter that is a Coda text value.\n\n[]",
      "StringArray": " **StringArray** = ``\"stringArray\"``\n\nIndicates a parameter that is a list of Coda text values.\n\n[]\n\nnav: \"PostSetupType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: PostSetupType": {
    "Enumeration Members": {
      "SetEndpoint": " **SetEndpoint** = ``\"SetEndPoint\"``\n\nSee [SetEndpoint](../interfaces/core.SetEndpoint.md).\n\n[]\n\nnav: \"PrecannedDateRange\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: PrecannedDateRange": {
    "Enumeration Members": {
      "Everything": " **Everything** = ``\"everything\"``\n\nIndicates a date range beginning in the very distant past (e.g. 1/1/1, aka 1 A.D.)\nand ending in the distant future (e.g. 12/31/3999). Exact dates are subject to change.\n\n[]",
      "Last180Days": " **Last180Days** = ``\"last_180_days\"``\n\n[]",
      "Last30AndNext30Days": " **Last30AndNext30Days** = ``\"last_30_and_next_30_days\"``\n\n[]",
      "Last30Days": " **Last30Days** = ``\"last_30_days\"``\n\n[]",
      "Last365Days": " **Last365Days** = ``\"last_365_days\"``\n\n[]",
      "Last3Months": " **Last3Months** = ``\"last_3_months\"``\n\n**`Deprecated`**\n\n[]",
      "Last6Months": " **Last6Months** = ``\"last_6_months\"``\n\n**`Deprecated`**\n\n[]",
      "Last7AndNext7Days": " **Last7AndNext7Days** = ``\"last_7_and_next_7_days\"``\n\n[]",
      "Last7Days": " **Last7Days** = ``\"last_7_days\"``\n\n[]",
      "Last90AndNext90Days": " **Last90AndNext90Days** = ``\"last_90_and_next_90_days\"``\n\n[]",
      "Last90Days": " **Last90Days** = ``\"last_90_days\"``\n\n[]",
      "LastMonth": " **LastMonth** = ``\"last_month\"``\n\n[]",
      "LastWeek": " **LastWeek** = ``\"last_week\"``\n\n[]",
      "LastYear": " **LastYear** = ``\"last_year\"``\n\n[]",
      "Next180Days": " **Next180Days** = ``\"next_180_days\"``\n\n[]",
      "Next30Days": " **Next30Days** = ``\"next_30_days\"``\n\n[]",
      "Next365Days": " **Next365Days** = ``\"next_365_days\"``\n\n[]",
      "Next3Months": " **Next3Months** = ``\"next_3_months\"``\n\n**`Deprecated`**\n\n[]",
      "Next6Months": " **Next6Months** = ``\"next_6_months\"``\n\n**`Deprecated`**\n\n[]",
      "Next7Days": " **Next7Days** = ``\"next_7_days\"``\n\n[]",
      "Next90Days": " **Next90Days** = ``\"next_90_days\"``\n\n[]",
      "NextMonth": " **NextMonth** = ``\"next_month\"``\n\n[]",
      "NextWeek": " **NextWeek** = ``\"next_week\"``\n\n[]",
      "NextYear": " **NextYear** = ``\"next_year\"``\n\n[]",
      "ThisMonth": " **ThisMonth** = ``\"this_month\"``\n\n[]",
      "ThisWeek": " **ThisWeek** = ``\"this_week\"``\n\n[]",
      "ThisYear": " **ThisYear** = ``\"this_year\"``\n\n[]",
      "Today": " **Today** = ``\"today\"``\n\n[]",
      "Tomorrow": " **Tomorrow** = ``\"tomorrow\"``\n\n[]",
      "YearToDate": " **YearToDate** = ``\"year_to_date\"``\n\n[]",
      "Yesterday": " **Yesterday** = ``\"yesterday\"``\n\n[]\n\nnav: \"ScaleIconSet\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ScaleIconSet": {
    "Enumeration Members": {
      "Battery": " **Battery** = ``\"battery\"``\n\n[]",
      "Bell": " **Bell** = ``\"bell\"``\n\n[]",
      "Bug": " **Bug** = ``\"bug\"``\n\n[]",
      "Checkmark": " **Checkmark** = ``\"checkmark\"``\n\n[]",
      "Chili": " **Chili** = ``\"chili\"``\n\n[]",
      "Circle": " **Circle** = ``\"circle\"``\n\n[]",
      "Cloud": " **Cloud** = ``\"cloud\"``\n\n[]",
      "Cocktail": " **Cocktail** = ``\"cocktail\"``\n\n[]",
      "Coffee": " **Coffee** = ``\"coffee\"``\n\n[]",
      "Currency": " **Currency** = ``\"currency\"``\n\n[]",
      "Diamond": " **Diamond** = ``\"diamond\"``\n\n[]",
      "Fire": " **Fire** = ``\"fire\"``\n\n[]",
      "Heart": " **Heart** = ``\"heart\"``\n\n[]",
      "LightBulb": " **LightBulb** = ``\"lightbulb\"``\n\n[]",
      "Lightning": " **Lightning** = ``\"lightning\"``\n\n[]",
      "Person": " **Person** = ``\"person\"``\n\n[]",
      "Smiley": " **Smiley** = ``\"smiley\"``\n\n[]",
      "Star": " **Star** = ``\"star\"``\n\n[]",
      "Sun": " **Sun** = ``\"sun\"``\n\n[]",
      "ThumbsUp": " **ThumbsUp** = ``\"thumbsup\"``\n\n[]\n\nnav: \"TokenExchangeCredentialsLocation\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: TokenExchangeCredentialsLocation": {
    "Enumeration Members": {
      "AuthorizationHeader": " **AuthorizationHeader** = ``\"AuthorizationHeader\"``\n\nThe credentials are passed in the Authorization header using the `Basic` scheme.\n\n[]",
      "Automatic": " **Automatic** = ``\"Automatic\"``\n\nAllow Coda to determine this automatically. Currently that means Coda tries passing the\ncredentials in the body first, and if that fails then tries passing them in the Authorization\nheader.\n\n[]",
      "Body": " **Body** = ``\"Body\"``\n\nThe credentials are passed in the body of the request, encoded as\n`application/x-www-form-urlencoded` along with the other parameters.\n\n[]\n\nnav: \"Type\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: Type": {
    "Enumeration Members": {
      "boolean": " **boolean** = ``3``\n\n[]",
      "date": " **date** = ``4``\n\n[]",
      "file": " **file** = ``7``\n\n[]",
      "html": " **html** = ``5``\n\n[]",
      "image": " **image** = ``6``\n\n[]",
      "markdown": " **markdown** = ``8``\n\n[]",
      "number": " **number** = ``1``\n\n[]",
      "object": " **object** = ``2``\n\n[]",
      "string": " **string** = ``0``\n\n[]\n\nnav: \"ValueHintType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ValueHintType": {
    "Enumeration Members": {
      "Attachment": " **Attachment** = ``\"attachment\"``\n\nIndicates to interpret and render a value as a file attachment. The provided value should be a URL\npointing to a file of a Coda-supported type. Coda will ingest the file and host it from Coda infrastructure.\n\n[]",
      "Currency": " **Currency** = ``\"currency\"``\n\nIndicates to interpret and render the value as a currency value.\n\n[]",
      "Date": " **Date** = ``\"date\"``\n\nIndicates to interpret the value as a date (e.g. March 3, 2021).\n\n[]",
      "DateTime": " **DateTime** = ``\"datetime\"``\n\nIndicates to interpret the value as a datetime (e.g. March 3, 2021 at 5:24pm).\n\n[]",
      "Duration": " **Duration** = ``\"duration\"``\n\nIndicates to interpret the value as a duration (e.g. 3 hours).\n\n[]",
      "Email": " **Email** = ``\"email\"``\n\nIndicates to interpret the value as an email address (e.g. joe@foo.com).\n\n[]",
      "Embed": " **Embed** = ``\"embed\"``\n\nIndicates to interpret and render a value as an embed. The provided value should be a URL pointing\nto an embeddable web page.\n\n[]",
      "Html": " **Html** = ``\"html\"``\n\nIndicates to interpret a text value as HTML, which will be converted and rendered as Coda rich text.\n\n[]",
      "ImageAttachment": " **ImageAttachment** = ``\"imageAttachment\"``\n\nIndicates to interpret and render the value as an image. The provided value should be a URL that\npoints to an image. Coda will ingest the image and host it from Coda infrastructure.\n\n[]",
      "ImageReference": " **ImageReference** = ``\"image\"``\n\nIndicates to interpret and render the value as an image. The provided value should be a URL that\npoints to an image. Coda will hotlink to the image when rendering it a doc.\n\nUsing [ImageAttachment](core.ValueHintType.md#imageattachment) is recommended instead, so that the image is always accessible\nand won't appear as broken if the source image is later deleted.\n\n[]",
      "Markdown": " **Markdown** = ``\"markdown\"``\n\nIndicates to interpret a text value as Markdown, which will be converted and rendered as Coda rich text.\n\n[]",
      "Percent": " **Percent** = ``\"percent\"``\n\nIndicates to interpret and render the value as a percentage.\n\n[]",
      "Person": " **Person** = ``\"person\"``\n\nIndicates to interpret and render the value as a Coda person reference. The provided value should be\nan object whose `id` property is an email address, which Coda will try to resolve to a user\nand render an @-reference to the user.\n\n**`Example`**\n\n```\nmakeObjectSchema({\n  type: ValueType.Object,\n  codaType: ValueHintType.Person,\n  id: 'email',\n  primary: 'name',\n  properties: {\n    email: {type: ValueType.String, required: true},\n    name: {type: ValueType.String, required: true},\n  },\n});\n```\n\n[]",
      "ProgressBar": " **ProgressBar** = ``\"progressBar\"``\n\nIndicates to render a numeric value as a progress bar UI component.\n\n[]",
      "Reference": " **Reference** = ``\"reference\"``\n\nIndicates to interpret and render the value as a Coda @-reference to a table row. The provided value should\nbe an object whose `id` value matches the id of some row in a sync table. The schema where this hint type is\nused must specify an identity that specifies the desired sync table.\n\nNormally a reference schema is constructed from the schema object being referenced using the helper\n[makeReferenceSchemaFromObjectSchema](../functions/core.makeReferenceSchemaFromObjectSchema.md).\n\n**`Example`**\n\n```\nmakeObjectSchema({\n  type: ValueType.Object,\n  codaType: ValueHintType.Reference,\n  identity: {\n    name: \"SomeSyncTableIdentity\"\n  },\n  id: 'identifier',\n  primary: 'name',\n  properties: {\n    identifier: {type: ValueType.Number, required: true},\n    name: {type: ValueType.String, required: true},\n  },\n});\n```\n\n[]",
      "Scale": " **Scale** = ``\"scale\"``\n\nIndicates to render a numeric value as a scale UI component (e.g. a star rating).\n\n[]",
      "SelectList": " **SelectList** = ``\"selectList\"``\n\nIndicates to render a value as a select list.\n\n[]",
      "Slider": " **Slider** = ``\"slider\"``\n\nIndicates to render a numeric value as a slider UI component.\n\n[]",
      "Time": " **Time** = ``\"time\"``\n\nIndicates to interpret the value as a time (e.g. 5:24pm).\n\n[]",
      "Toggle": " **Toggle** = ``\"toggle\"``\n\nIndicates to render a boolean value as a toggle.\n\n[]",
      "Url": " **Url** = ``\"url\"``\n\nIndicates to interpret and render the value as a URL link.\n\n[]\n\nnav: \"ValueType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Enumeration: ValueType": {
    "Enumeration Members": {
      "Array": " **Array** = ``\"array\"``\n\nIndicates a JavaScript array should be returned. The schema of the array items must also be specified.\n\n[]",
      "Boolean": " **Boolean** = ``\"boolean\"``\n\nIndicates a JavaScript boolean (true/false) should be returned.\n\n[]",
      "Number": " **Number** = ``\"number\"``\n\nIndicates a JavaScript number should be returned.\n\n[]",
      "Object": " **Object** = ``\"object\"``\n\nIndicates a JavaScript object should be returned. The schema of each object property must also be specified.\n\n[]",
      "String": " **String** = ``\"string\"``\n\nIndicates a JavaScript string should be returned.\n\n[]\n\nnav: \"assertCondition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Function: assertCondition": "[core](../modules/core.md).assertCondition\n\n **assertCondition**(`condition`, `message?`): asserts condition\n\nHelper to apply a TypeScript assertion to subsequent code. TypeScript can infer\ntype information from many expressions, and this helper applies those inferences\nto all code that follows call to this function.\n\nSee https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions\n\n**`Example`**\n\n```\nfunction foo(value: string | number) {\n  assertCondtion(typeof value === 'string');\n  // TypeScript would otherwise compalin, because `value` could have been number,\n  // but the above assertion refines the type based on the `typeof` expression.\n  return value.toUpperCase();\n}\n```\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `condition` | `any` |\n| `message?` | `string` |\n\nReturns\n\nasserts condition\n\n[]\n\nnav: \"autocompleteSearchObjects\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: autocompleteSearchObjects": "[core](../modules/core.md).autocompleteSearchObjects\n\n **autocompleteSearchObjects**<`T`\\>(`search`, `objs`, `displayKey`, `valueKey`): `Promise`<[`MetadataFormulaObjectResultType`](../interfaces/core.MetadataFormulaObjectResultType.md)[]\\>\n\nA helper to search over a list of objects representing candidate search results,\nfiltering to only those that match a search string, and converting the matching\nobjects into the format needed for autocomplete results.\n\nA case-insensitive search is performed over each object's `displayKey` property.\n\nA common pattern for implementing autocomplete for a formula pattern is to\nmake a request to an API endpoint that returns a list of all entities,\nand then to take the user's partial input and search over those entities\nfor matches. The helper generalizes this use case.\n\n**`Example`**\n\n```\ncoda.makeParameter({\n  type: ParameterType.Number,\n  name: \"userId\",\n  description: \"The ID of a user.\",\n  autocomplete: async function(context, search) {\n    // Suppose this endpoint returns a list of users that have the form\n    // `{name: \"Jane Doe\", userId: 123, email: \"jane@doe.com\"}`\n    const usersResponse = await context.fetcher.fetch(\"/api/users\");\n    // This will search over the name property of each object and filter to only\n    // those that match. Then it will transform the matching objects into the form\n    // `{display: \"Jane Doe\", value: 123}` which is what is required to render\n    // autocomplete responses.\n    return coda.autocompleteSearchObjects(search, usersResponse.body, \"name\", \"userId\");\n  }\n});\n```\n\nType parameters\n\n| Name |\n| :------ |\n| `T` |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `search` | `string` |\n| `objs` | `T`[] |\n| `displayKey` | { [K in string \\| number \\| symbol]: T[K] extends string ? K : never }[keyof `T`] |\n| `valueKey` | { [K in string \\| number \\| symbol]: T[K] extends string \\| number ? K : never }[keyof `T`] |\n\nReturns\n\n`Promise`<[`MetadataFormulaObjectResultType`](../interfaces/core.MetadataFormulaObjectResultType.md)[]\\>\n\n[]\n\nnav: \"ensureExists\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: ensureExists": "[core](../modules/core.md).ensureExists\n\n **ensureExists**<`T`\\>(`value`, `message?`): `T`\n\nHelper to check that a given value is defined, that is, is neither `undefined` nor `null`.\nIf the value is `undefined` or `null`, an error will be raised at runtime.\n\nThis is typically used to inform TypeScript that you expect a given value to always exist.\nCalling this function refines a type that can otherwise be null or undefined.\n\nType parameters\n\n| Name |\n| :------ |\n| `T` |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `value` | `undefined` \\| ``null`` \\| `T` |\n| `message?` | `string` |\n\nReturns\n\n`T`\n\n[]\n\nnav: \"ensureNonEmptyString\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: ensureNonEmptyString": "[core](../modules/core.md).ensureNonEmptyString\n\n **ensureNonEmptyString**(`value`, `message?`): `string`\n\nHelper to check that a given value is a string, and is not the empty string.\nIf the value is not a string or is empty, an error will be raised at runtime.\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `value` | `undefined` \\| ``null`` \\| `string` |\n| `message?` | `string` |\n\nReturns\n\n`string`\n\n[]\n\nnav: \"ensureUnreachable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: ensureUnreachable": "[core](../modules/core.md).ensureUnreachable\n\n **ensureUnreachable**(`value`, `message?`): `never`\n\nHelper for TypeScript to make sure that handling of code forks is exhaustive,\nmost commonly with a `switch` statement.\n\n**`Example`**\n\n```\nenum MyEnum {\n  Foo = 'Foo',\n  Bar = 'Bar',\n}\n\nfunction handleEnum(value: MyEnum) {\n  switch(value) {\n    case MyEnum.Foo:\n      return 'foo';\n    case MyEnum.Bar:\n      return 'bar';\n    default:\n      // This code is unreachable since the two cases above are exhaustive.\n      // However, if a third value were added to MyEnum, TypeScript would flag\n      // an error at this line, informing you that you need to update this piece of code.\n      return ensureUnreachable(value);\n  }\n}\n```\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `value` | `never` |\n| `message?` | `string` |\n\nReturns\n\n`never`\n\n[]\n\nnav: \"generateSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: generateSchema": "[core](../modules/core.md).generateSchema\n\n **generateSchema**(`obj`): [`Schema`](../types/core.Schema.md)\n\nUtility that examines a JavaScript value and attempts to infer a schema definition\nthat describes it.\n\nIt is vastly preferable to define a schema manually. A clear and accurate schema is one of the\nfundamentals of a good pack. However, for data that is truly dynamic for which a schema can't\nbe known in advance nor can a function be written to generate a dynamic schema from other\ninputs, it may be useful to us this helper to sniff the return value and generate a basic\ninferred schema from it.\n\nThis utility does NOT attempt to determine [idProperty](../interfaces/core.ObjectSchemaDefinition.md#idproperty) or\n[displayProperty](../interfaces/core.ObjectSchemaDefinition.md#displayproperty) attributes for\nan object schema, those are left undefined.\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `obj` | [`InferrableTypes`](../types/core.InferrableTypes.md) |\n\nReturns\n\n[`Schema`](../types/core.Schema.md)\n\n[]\n\nnav: \"getEffectivePropertyKeysFromSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: getEffectivePropertyKeysFromSchema": "[core](../modules/core.md).getEffectivePropertyKeysFromSchema\n\n **getEffectivePropertyKeysFromSchema**(`schema`): `string`[] \\| `undefined`\n\nA helper to extract properties fromKeys from a schema object. This is mostly useful\nin processing the context.sync.schema in a sync formula, where the schema would only\ninclude a subset of properties which were manually selected by the Pack user.\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `schema` | [`Schema`](../types/core.Schema.md) |\n\nReturns\n\n`string`[] \\| `undefined`\n\n[]\n\nnav: \"getQueryParams\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: getQueryParams": "[core](../modules/core.md).getQueryParams\n\n **getQueryParams**(`url`): `Object`\n\nHelper to take a URL string and return the parameters (if any) as a JavaScript object.\n\n**`Example`**\n\n```\n// Returns `{token: \"asdf\", limit: \"5\"}`\nlet params = getQueryParams(\"/someApi/someEndpoint?token=asdf&limit=5\");\n```\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `url` | `string` |\n\nReturns\n\n`Object`\n\n[]\n\nnav: \"joinUrl\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: joinUrl": "[core](../modules/core.md).joinUrl\n\n **joinUrl**(`...tokens`): `string`\n\nJoins all the tokens into a single URL string separated by '/'. Zero length tokens cause errors.\n\nParameters\n\n| Name | Type | Description |\n| :------ | :------ | :------ |\n| `...tokens` | `string`[] | Zero or more tokens to be combined. If token doesn't end with '/', one will be added as the separator |\n\nReturns\n\n`string`\n\n[]\n\nnav: \"makeAttributionNode\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeAttributionNode": "[core](../modules/core.md).makeAttributionNode\n\n **makeAttributionNode**<`T`\\>(`node`): `T`\n\nA helper for constructing attribution text, links, or images that render along with a Pack value.\n\nMany APIs have licensing requirements that ask for specific attribution to be included\nwhen using their data. For example, a stock photo API may require attribution text\nand a logo.\n\nAny [IdentityDefinition](../interfaces/core.IdentityDefinition.md) can include one or more attribution nodes that will be\nrendered any time a value with that identity is rendered in a doc.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`AttributionNode`](../types/core.AttributionNode.md) |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `node` | `T` |\n\nReturns\n\n`T`\n\n[]\n\nnav: \"makeDynamicSyncTable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeDynamicSyncTable": "[core](../modules/core.md).makeDynamicSyncTable\n\n **makeDynamicSyncTable**<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>(`destructured`): [`DynamicSyncTableDef`](../interfaces/core.DynamicSyncTableDef.md)<`K`, `L`, `ParamDefsT`, `any`, `ContextT`\\>\n\nCreates a dynamic sync table definition.\n\n**`Example`**\n\n```\ncoda.makeDynamicSyncTable({\n  name: \"MySyncTable\",\n  getName: async function(context) => {\n    const response = await context.fetcher.fetch({method: \"GET\", url: context.sync.dynamicUrl});\n    return response.body.name;\n  },\n  getName: async function(context) => {\n    const response = await context.fetcher.fetch({method: \"GET\", url: context.sync.dynamicUrl});\n    return response.body.browserLink;\n  },\n  ...\n});\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<`any`, `any`, `any`\\> |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `destructured` | `Object` |\n| `connectionRequirement?` | [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md) |\n| `defaultAddDynamicColumns?` | `boolean` |\n| `description?` | `string` |\n| `entityName?` | `string` |\n| `formula` | [`SyncFormulaDef`](../interfaces/core.SyncFormulaDef.md)<`K`, `L`, `ParamDefsT`, `any`, `ContextT`\\> |\n| `getDisplayUrl` | [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\> |\n| `getName` | [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\> |\n| `getSchema` | [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\> |\n| `identityName` | `string` |\n| `listDynamicUrls?` | [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<[`ExecutionContext`](../interfaces/core.ExecutionContext.md)\\> |\n| `name` | `string` |\n| `placeholderSchema?` | `SchemaT` |\n| `propertyOptions?` | [`PropertyOptionsMetadataFunction`](../types/core.PropertyOptionsMetadataFunction.md)<`any`\\> |\n| `searchDynamicUrls?` | [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<[`ExecutionContext`](../interfaces/core.ExecutionContext.md)\\> |\n\nReturns\n\n[`DynamicSyncTableDef`](../interfaces/core.DynamicSyncTableDef.md)<`K`, `L`, `ParamDefsT`, `any`, `ContextT`\\>\n\n[]\n\nnav: \"makeEmptyFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeEmptyFormula": "[core](../modules/core.md).makeEmptyFormula\n\n **makeEmptyFormula**<`ParamDefsT`\\>(`definition`): { `cacheTtlSecs?`: `number` ; `connectionRequirement?`: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md) ; `description`: `string` ; `examples?`: { `params`: (`undefined` \\| [`PackFormulaValue`](../types/core.PackFormulaValue.md))[] ; `result`: [`PackFormulaResult`](../types/core.PackFormulaResult.md)  }[] ; `extraOAuthScopes?`: `string`[] ; `isAction?`: `boolean` ; `isExperimental?`: `boolean` ; `isSystem?`: `boolean` ; `name`: `string` ; `network?`: [`Network`](../interfaces/core.Network.md) ; `parameters`: `ParamDefsT` ; `varargParameters?`: [`ParamDefs`](../types/core.ParamDefs.md)  } & { `execute`: (`params`: [`ParamValues`](../types/core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `Promise`<`string`\\> ; `resultType`: [`string`](../enums/core.Type.md#string)  }\n\nCreates the definition of an \"empty\" formula, that is, a formula that uses a [RequestHandlerTemplate](../interfaces/core.RequestHandlerTemplate.md)\nto define an implementation for the formula rather than implementing an actual `execute` function\nin JavaScript.\n\n**`Example`**\n\n```\ncoda.makeEmptyFormula({\n   name: \"GetWidget\",\n   description: \"Gets a widget.\",\n   request: {\n     url: \"https://example.com/widgets/{id}\",\n     method: \"GET\",\n   },\n   parameters: [\n     coda.makeParameter({type: coda.ParameterType.Number, name: \"id\", description: \"The ID of the widget to get.\"}),\n   ],\n }),\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `definition` | [`EmptyFormulaDef`](../interfaces/core.EmptyFormulaDef.md)<`ParamDefsT`\\> |\n\nReturns\n\n{ `cacheTtlSecs?`: `number` ; `connectionRequirement?`: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md) ; `description`: `string` ; `examples?`: { `params`: (`undefined` \\| [`PackFormulaValue`](../types/core.PackFormulaValue.md))[] ; `result`: [`PackFormulaResult`](../types/core.PackFormulaResult.md)  }[] ; `extraOAuthScopes?`: `string`[] ; `isAction?`: `boolean` ; `isExperimental?`: `boolean` ; `isSystem?`: `boolean` ; `name`: `string` ; `network?`: [`Network`](../interfaces/core.Network.md) ; `parameters`: `ParamDefsT` ; `varargParameters?`: [`ParamDefs`](../types/core.ParamDefs.md)  } & { `execute`: (`params`: [`ParamValues`](../types/core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `Promise`<`string`\\> ; `resultType`: [`string`](../enums/core.Type.md#string)  }\n\n[]\n\nnav: \"makeFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeFormula": "[core](../modules/core.md).makeFormula\n\n **makeFormula**<`ParamDefsT`, `ResultT`, `SchemaT`\\>(`fullDefinition`): [`Formula`](../types/core.Formula.md)<`ParamDefsT`, `ResultT`, `SchemaT`\\>\n\nCreates a formula definition.\n\nYou must indicate the kind of value that this formula returns (string, number, boolean, array, or object)\nusing the `resultType` field.\n\nFormulas always return basic types, but you may optionally give a type hint using\n`codaType` to tell Coda how to interpret a given value. For example, you can return\na string that represents a date, but use `codaType: ValueType.Date` to tell Coda\nto interpret as a date in a document.\n\nIf your formula returns an object, you must provide a `schema` property that describes\nthe structure of the object. See [makeObjectSchema](core.makeObjectSchema.md) for how to construct an object schema.\n\nIf your formula returns a list (array), you must provide an `items` property that describes\nwhat the elements of the array are. This could be a simple schema like `{type: ValueType.String}`\nindicating that the array elements are all just strings, or it could be an object schema\ncreated using [makeObjectSchema](core.makeObjectSchema.md) if the elements are objects.\n\n**`Example`**\n\n```\nmakeFormula({resultType: ValueType.String, name: 'Hello', ...});\n```\n\n**`Example`**\n\n```\nmakeFormula({resultType: ValueType.String, codaType: ValueType.Html, name: 'HelloHtml', ...});\n```\n\n**`Example`**\n\n```\nmakeFormula({resultType: ValueType.Array, items: {type: ValueType.String}, name: 'HelloStringArray', ...});\n```\n\n**`Example`**\n\n```\nmakeFormula({\n  resultType: ValueType.Object,\n  schema: makeObjectSchema({type: ValueType.Object, properties: {...}}),\n  name: 'HelloObject',\n  ...\n});\n```\n\n**`Example`**\n\n```\nmakeFormula({\n  resultType: ValueType.Array,\n  items: makeObjectSchema({type: ValueType.Object, properties: {...}}),\n  name: 'HelloObjectArray',\n  ...\n});\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `ResultT` | extends [`ValueType`](../enums/core.ValueType.md) |\n| `SchemaT` | extends [`Schema`](../types/core.Schema.md) = [`Schema`](../types/core.Schema.md) |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `fullDefinition` | [`FormulaDefinition`](../types/core.FormulaDefinition.md)<`ParamDefsT`, `ResultT`, `SchemaT`\\> |\n\nReturns\n\n[`Formula`](../types/core.Formula.md)<`ParamDefsT`, `ResultT`, `SchemaT`\\>\n\n[]\n\nnav: \"makeMetadataFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeMetadataFormula": "[core](../modules/core.md).makeMetadataFormula\n\n **makeMetadataFormula**<`ContextT`\\>(`execute`, `options?`): [`MetadataFormula`](../types/core.MetadataFormula.md)<`ContextT`\\>\n\nA wrapper that generates a formula definition from the function that implements a metadata formula.\nIt is uncommon to ever need to call this directly, normally you would just define the JavaScript\nfunction implementation, and Coda will wrap it with this to generate a full metadata formula\ndefinition.\n\nAll function-like behavior in a pack is ultimately implemented using formulas, like you would\ndefine using [makeFormula](core.makeFormula.md). That is, a formula with a name, description, parameter list,\nand an `execute` function body. This includes supporting utilities like parameter autocomplete functions.\nThis wrapper simply adds the surrounding boilerplate for a given JavaScript function so that\nit is shaped like a Coda formula to be used at runtime.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ContextT` | extends [`ExecutionContext`](../interfaces/core.ExecutionContext.md) |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `execute` | [`MetadataFunction`](../types/core.MetadataFunction.md)<`ContextT`\\> |\n| `options?` | `Object` |\n| `options.connectionRequirement?` | [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md) |\n\nReturns\n\n[`MetadataFormula`](../types/core.MetadataFormula.md)<`ContextT`\\>\n\n[]\n\nnav: \"makeObjectSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeObjectSchema": "[core](../modules/core.md).makeObjectSchema\n\n **makeObjectSchema**<`K`, `L`, `T`\\>(`schemaDef`): `T` & { `identity?`: [`Identity`](../interfaces/core.Identity.md) ; `type`: [`Object`](../enums/core.ValueType.md#object)  }\n\nA wrapper for creating a schema definition for an object value.\n\nIt is always recommended to use wrapper functions for creating top-level schema\nobjects rather than specifying object literals. Wrappers validate your schemas\nat creation time, provide better TypeScript type inference, and can reduce\nboilerplate.\n\n**`Example`**\n\n```\ncoda.makeObjectSchema({\n  id: \"email\",\n  primary: \"name\",\n  properties: {\n    email: {type: coda.ValueType.String, required: true},\n    name: {type: coda.ValueType.String, required: true},\n  },\n});\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `T` | extends `Omit`<[`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\>, ``\"type\"``\\> |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `schemaDef` | `T` & { `type?`: [`Object`](../enums/core.ValueType.md#object)  } |\n\nReturns\n\n`T` & { `identity?`: [`Identity`](../interfaces/core.Identity.md) ; `type`: [`Object`](../enums/core.ValueType.md#object)  }\n\n[]\n\nnav: \"makeParameter\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeParameter": "[core](../modules/core.md).makeParameter\n\n **makeParameter**<`T`, `O`\\>(`paramDefinition`): [`ParamDefFromOptionsUnion`](../types/core.ParamDefFromOptionsUnion.md)<`T`, `O`\\>\n\nCreate a definition for a parameter for a formula or sync.\n\n**`Example`**\n\n```\nmakeParameter({type: ParameterType.String, name: 'myParam', description: 'My description'});\n```\n\n**`Example`**\n\n```\nmakeParameter({type: ParameterType.StringArray, name: 'myArrayParam', description: 'My description'});\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`ParameterType`](../enums/core.ParameterType.md) |\n| `O` | extends [`ParameterOptions`](../types/core.ParameterOptions.md)<`T`\\> |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `paramDefinition` | `O` |\n\nReturns\n\n[`ParamDefFromOptionsUnion`](../types/core.ParamDefFromOptionsUnion.md)<`T`, `O`\\>\n\n[]\n\nnav: \"makeReferenceSchemaFromObjectSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeReferenceSchemaFromObjectSchema": "[core](../modules/core.md).makeReferenceSchemaFromObjectSchema\n\n **makeReferenceSchemaFromObjectSchema**(`schema`, `identityName?`): `GenericObjectSchema` & [`ObjectSchemaProperty`](../interfaces/core.ObjectSchemaProperty.md)\n\nConvenience for creating a reference object schema from an existing schema for the\nobject. Copies over the identity, idProperty, and displayProperty from the schema,\nand the subset of properties indicated by the idProperty and displayProperty.\nA reference schema can always be defined directly, but if you already have an object\nschema it provides better code reuse to derive a reference schema instead.\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `schema` | [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`string`, `string`\\> & [`ObjectSchemaProperty`](../interfaces/core.ObjectSchemaProperty.md) |\n| `identityName?` | `string` |\n\nReturns\n\n`GenericObjectSchema` & [`ObjectSchemaProperty`](../interfaces/core.ObjectSchemaProperty.md)\n\n[]\n\nnav: \"makeSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeSchema": "[core](../modules/core.md).makeSchema\n\n **makeSchema**<`T`\\>(`schema`): `T`\n\nA wrapper for creating any schema definition.\n\nIf you are creating a schema for an object (as opposed to a scalar or array),\nuse the more specific [makeObjectSchema](core.makeObjectSchema.md).\n\nIt is always recommended to use wrapper functions for creating top-level schema\nobjects rather than specifying object literals. Wrappers validate your schemas\nat creation time, provide better TypeScript type inference, and can reduce\nboilerplate.\n\nAt this time, this wrapper provides only better TypeScript type inference,\nbut it may do validation in a future SDK version.\n\n**`Example`**\n\n```\ncoda.makeSchema({\n  type: coda.ValueType.Array,\n  items: {type: coda.ValueType.String},\n});\n```\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`Schema`](../types/core.Schema.md) |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `schema` | `T` |\n\nReturns\n\n`T`\n\n[]\n\nnav: \"makeSimpleAutocompleteMetadataFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeSimpleAutocompleteMetadataFormula": "[core](../modules/core.md).makeSimpleAutocompleteMetadataFormula\n\n **makeSimpleAutocompleteMetadataFormula**<`T`\\>(`options`): [`MetadataFormula`](../types/core.MetadataFormula.md)\n\n**`Deprecated`**\n\nIf you have a hardcoded array of autocomplete options, simply include that array\nas the value of the `autocomplete` property in your parameter definition. There is no longer\nany needed to wrap a value with this formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends `AutocompleteParameterTypes` |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `options` | (`TypeMap`[`AutocompleteParameterTypeMapping`[`T`]] \\| [`SimpleAutocompleteOption`](../interfaces/core.SimpleAutocompleteOption.md)<`T`\\>)[] |\n\nReturns\n\n[`MetadataFormula`](../types/core.MetadataFormula.md)\n\n[]\n\nnav: \"makeSyncTable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeSyncTable": "[core](../modules/core.md).makeSyncTable\n\n **makeSyncTable**<`K`, `L`, `ParamDefsT`, `SchemaDefT`, `SchemaT`, `ContextT`\\>(`destructured`): [`SyncTableDef`](../interfaces/core.SyncTableDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>\n\nWrapper to produce a sync table definition. All (non-dynamic) sync tables should be created\nusing this wrapper rather than declaring a sync table definition object directly.\n\nThis wrapper does a variety of helpful things, including\n\n['Doing basic validation of the provided definition.', 'Normalizing the schema definition to conform to Coda-recommended syntax.', 'Wrapping the execute formula to normalize return values to match the normalized schema.']\n\nSee [Normalization]({{ config.site_url }}guides/advanced/schemas/#normalization) for more information about schema normalization.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaDefT` | extends [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\> & { `identity?`: [`Identity`](../interfaces/core.Identity.md)  } |\n| `ContextT` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<`any`, `any`, `any`\\> |\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `destructured` | [`SyncTableOptions`](../interfaces/core.SyncTableOptions.md)<`K`, `L`, `ParamDefsT`, `SchemaDefT`, `ContextT`\\> |\n\nReturns\n\n[`SyncTableDef`](../interfaces/core.SyncTableDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>\n\n[]\n\nnav: \"makeTranslateObjectFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Function: makeTranslateObjectFormula": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`CodaApiBearerTokenAuthentication`**"
    ],
    "Properties": {
      "deferConnectionSetup": " `Optional` **deferConnectionSetup**: `boolean`\n\n**`Deprecated`**\n\n[]",
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "shouldAutoAuthSetup": " `Optional` **shouldAutoAuthSetup**: `boolean`\n\nIf true, automatically creates and configures an account with a Coda API token with\ndefault settings when installing the pack: a read-write token, added to the doc\nas a shared account that allows actions.\n\n[]",
      "type": " **type**: [`CodaApiHeaderBearerToken`](../enums/core.AuthenticationType.md#codaapiheaderbearertoken)\n\nIdentifies this as CodaApiHeaderBearerToken authentication.\n\n[]\n\nnav: \"CommonPackFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: CommonPackFormulaDef<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends [`ParamDefs`](../types/core.ParamDefs.md) |",
    "Hierarchy": [
      "**`CommonPackFormulaDef`**",
      " [`PackFormulaDef`](core.PackFormulaDef.md)",
      " [`SyncFormulaDef`](core.SyncFormulaDef.md)"
    ],
    "Properties": {
      "cacheTtlSecs": " `Optional` `Readonly` **cacheTtlSecs**: `number`\n\nHow long formulas running with the same values should cache their results for.\n\n[]",
      "connectionRequirement": " `Optional` `Readonly` **connectionRequirement**: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md)\n\nDoes this formula require a connection (aka an account)?\n\n[]",
      "description": " `Readonly` **description**: `string`\n\nA brief description of what the formula does.\n\n[]",
      "examples": " `Optional` `Readonly` **examples**: { `params`: (`undefined` \\| [`PackFormulaValue`](../types/core.PackFormulaValue.md))[] ; `result`: [`PackFormulaResult`](../types/core.PackFormulaResult.md)  }[]\n\nSample inputs and outputs demonstrating usage of this formula.\n\n[]",
      "extraOAuthScopes": " `Optional` `Readonly` **extraOAuthScopes**: `string`[]\n\nOAuth scopes that the formula needs that weren't requested in the pack's overall authentication\nconfig. For example, a Slack pack can have one formula that needs admin privileges, but non-admins\ncan use the bulk of the pack without those privileges. Coda will give users help in understanding\nthat they need additional authentication to use a formula with extra OAuth scopes. Note that\nthese scopes will always be requested in addition to the default scopes for the pack,\nso an end user must have both sets of permissions.\n\n[]",
      "isAction": " `Optional` `Readonly` **isAction**: `boolean`\n\nDoes this formula take an action (vs retrieve data or make a calculation)?\nActions are presented as buttons in the Coda UI.\n\n[]",
      "isExperimental": " `Optional` `Readonly` **isExperimental**: `boolean`\n\nIf specified, the formula will not be suggested to users in Coda's formula autocomplete.\nThe formula can still be invoked by manually typing its full name.\n\n[]",
      "isSystem": " `Optional` `Readonly` **isSystem**: `boolean`\n\nWhether this is a formula that will be used by Coda internally and not exposed directly to users.\nNot for use by packs that are not authored by Coda.\n\n[]",
      "name": " `Readonly` **name**: `string`\n\nThe name of the formula, used to invoke it.\n\n[]",
      "network": " `Optional` `Readonly` **network**: [`Network`](core.Network.md)\n\n**`Deprecated`**\n\nuse `isAction` and `connectionRequirement` instead\n\n[]",
      "parameters": " `Readonly` **parameters**: `T`\n\nThe parameter inputs to the formula, if any.\n\n[]",
      "varargParameters": " `Optional` `Readonly` **varargParameters**: [`ParamDefs`](../types/core.ParamDefs.md)\n\nVariable argument parameters, used if this formula should accept arbitrary\nnumbers of inputs.\n\n[]\n\nnav: \"Continuation\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: Continuation": {
    "Indexable": " [key: `string`]: `string` \\| `number` \\| { `[key: string]`: `string` \\| `number`;  }\n\n[]\n\nnav: \"CurrencySchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
  },
  "Interface: CurrencySchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Currency`](../enums/core.ValueHintType.md#currency)\\>",
      " **`CurrencySchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "currencyCode": " `Optional` **currencyCode**: `string`\n\nA three-letter ISO 4217 currency code, e.g. USD or EUR.\nIf the currency code is not supported by Coda, the value will be rendered using USD.\n\n[]",
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "format": " `Optional` **format**: [`CurrencyFormat`](../enums/core.CurrencyFormat.md)\n\nA render format for further refining how the value is rendered.\n\n[]",
      "precision": " `Optional` **precision**: `number`\n\nThe decimal precision. The value is rounded to this precision when rendered.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"CustomAuthParameter\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: CustomAuthParameter": {
    "Properties": {
      "description": " **description**: `string`\n\nA description shown to the user indicating what value they should provide for this parameter.\n\n[]",
      "name": " **name**: `string`\n\nThe name used to refer to this parameter and to generate the template replacement string.\n\n[]\n\nnav: \"CustomAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: CustomAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`CustomAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "params": " **params**: [`CustomAuthParameter`](core.CustomAuthParameter.md)[]\n\nAn array of parameters that must be provided for new connection accounts to authenticate this pack.\nThese parameters can then be referenced via the [name](core.CustomAuthParameter.md#name) property for template\nreplacement inside the constructed network request.\n\n[]",
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`Custom`](../enums/core.AuthenticationType.md#custom)\n\nIdentifies this as Custom authentication.\n\n[]\n\nnav: \"CustomHeaderTokenAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: CustomHeaderTokenAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`CustomHeaderTokenAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "headerName": " **headerName**: `string`\n\nThe name of the HTTP header.\n\n[]",
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "tokenPrefix": " `Optional` **tokenPrefix**: `string`\n\nAn optional prefix in the HTTP header value before the actual token. Omit this\nif the token is the entirety of the header value.\n\nThe HTTP header will be of the form `<headerName>: <tokenPrefix> <token>`\n\n[]",
      "type": " **type**: [`CustomHeaderToken`](../enums/core.AuthenticationType.md#customheadertoken)\n\nIdentifies this as CustomHeaderToken authentication.\n\n[]\n\nnav: \"DurationSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: DurationSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Duration`](../enums/core.ValueHintType.md#duration)\\>",
      " **`DurationSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Inherited from": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "maxUnit": " `Optional` **maxUnit**: [`DurationUnit`](../enums/core.DurationUnit.md)\n\nThe unit to use for rounding the duration when rendering. For example, if using `DurationUnit.Days`,\nand a value of \"3 days 4 hours\" is provided, it will be rendered as \"3 days\".\n\n[]",
      "precision": " `Optional` **precision**: `number`\n\nA refinement of [maxUnit](core.DurationSchema.md#maxunit) to use for rounding the duration when rendering.\nCurrently only `1` is supported, which is the same as omitting a value.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"DynamicOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: DynamicOptions": {
    "Properties": {
      "defaultAddDynamicColumns": " `Optional` **defaultAddDynamicColumns**: `boolean`\n\nSee [defaultAddDynamicColumns](core.DynamicSyncTableOptions.md#defaultadddynamiccolumns)\n\n[]",
      "entityName": " `Optional` **entityName**: `string`\n\nSee [entityName](core.DynamicSyncTableOptions.md#entityname)\n\n[]",
      "getSchema": " `Optional` **getSchema**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nA formula that returns the schema for this table.\n\nFor a dynamic sync table, the value of [getSchema](core.DynamicSyncTableOptions.md#getschema)\nis passed through here. For a non-dynamic sync table, you may still implement\nthis if you table has a schema that varies based on the user account, but\ndoes not require a [dynamicUrl](core.SyncBase.md#dynamicurl).\n\n[]",
      "propertyOptions": " `Optional` **propertyOptions**: [`PropertyOptionsMetadataFunction`](../types/core.PropertyOptionsMetadataFunction.md)<`any`\\>\n\nSee [propertyOptions](core.DynamicSyncTableOptions.md#propertyoptions)\n\n[]\n\nnav: \"DynamicSyncTableDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: DynamicSyncTableDef<K, L, ParamDefsT, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends `ObjectSchema`<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`\\> |",
    "Hierarchy": [
      "[`SyncTableDef`](core.SyncTableDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>",
      " **`DynamicSyncTableDef`**"
    ],
    "Properties": {
      "defaultAddDynamicColumns": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[defaultAddDynamicColumns](core.SyncTableDef.md#defaultadddynamiccolumns)\n\n[]"
      },
      "description": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[description](core.SyncTableDef.md#description)\n\n[]"
      },
      "entityName": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[entityName](core.SyncTableDef.md#entityname)\n\n[]"
      },
      "getDisplayUrl": " **getDisplayUrl**: [`MetadataFormula`](../types/core.MetadataFormula.md)<`ContextT`\\>\n\nSee [getDisplayUrl](core.DynamicSyncTableOptions.md#getdisplayurl)\n\n[]",
      "getName": " **getName**: [`MetadataFormula`](../types/core.MetadataFormula.md)<`ContextT`\\>\n\nSee [getName](core.DynamicSyncTableOptions.md#getname)\n\n[]",
      "getSchema": {
        "Overrides": "[SyncTableDef](core.SyncTableDef.md).[getSchema](core.SyncTableDef.md#getschema)\n\n[]"
      },
      "getter": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[getter](core.SyncTableDef.md#getter)\n\n[]"
      },
      "identityName": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[identityName](core.SyncTableDef.md#identityname)\n\n[]"
      },
      "isDynamic": " **isDynamic**: ``true``\n\nIdentifies this sync table as dynamic.\n\n[]",
      "listDynamicUrls": " `Optional` **listDynamicUrls**: [`MetadataFormula`](../types/core.MetadataFormula.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nSee [listDynamicUrls](core.DynamicSyncTableOptions.md#listdynamicurls)\n\n[]",
      "name": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[name](core.SyncTableDef.md#name)\n\n[]"
      },
      "propertyOptions": " `Optional` **propertyOptions**: `PropertyOptionsMetadataFormula`<`any`\\>\n\nSee [propertyOptions](core.DynamicSyncTableOptions.md#propertyoptions)\n\n[]",
      "schema": {
        "Inherited from": "[SyncTableDef](core.SyncTableDef.md).[schema](core.SyncTableDef.md#schema)\n\n[]"
      },
      "searchDynamicUrls": " `Optional` **searchDynamicUrls**: [`MetadataFormula`](../types/core.MetadataFormula.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nSee [searchDynamicUrls](core.DynamicSyncTableOptions.md#searchdynamicurls)\n\n[]\n\nnav: \"DynamicSyncTableOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: DynamicSyncTableOptions<K, L, ParamDefsT, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`\\> |",
    "Properties": {
      "connectionRequirement": " `Optional` **connectionRequirement**: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md)\n\nA [ConnectionRequirement](../enums/core.ConnectionRequirement.md) that will be used for all formulas contained within\nthis sync table (including autocomplete formulas).\n\n[]",
      "defaultAddDynamicColumns": " `Optional` **defaultAddDynamicColumns**: `boolean`\n\nDefault is true.\n\nIf false, when subsequent syncs discover new schema properties, these properties will not automatically be\nadded as new columns on the table. The user can still manually add columns for these new properties.\nThis only applies to tables that use dynamic schemas.\n\nWhen tables with dynamic schemas are synced, the [getSchema](core.DynamicSyncTableOptions.md#getschema) formula is run each time,\nwhich may return a schema that is different than that from the last sync. The default behavior\nis that any schema properties that are new in this sync are automatically added as new columns,\nso they are apparent to the user. However, in rare cases when schemas change frequently,\nthis can cause the number of columns to grow quickly and become overwhelming. Setting this\nvalue to false leaves the columns unchanged and puts the choice of what columns to display\ninto the hands of the user.\n\n[]",
      "description": " `Optional` **description**: `string`\n\nThe description of the dynamic sync table. This is shown to users in the Coda UI\nwhen listing what build blocks are contained within this pack.\nThis should describe what the dynamic sync table does in a more detailed language.\n\n[]",
      "entityName": " `Optional` **entityName**: `string`\n\nA label for the kind of entities that you are syncing. This label is used in a doc to identify\nthe column in this table that contains the synced data. If you don't provide an `entityName`, the value\nof `identity.name` from your schema will be used instead, so in most cases you don't need to provide this.\n\n[]",
      "formula": " **formula**: [`SyncFormulaDef`](core.SyncFormulaDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>\n\nThe definition of the formula that implements this sync. This is a Coda packs formula\nthat returns an array of objects fitting the given schema and optionally a [Continuation](core.Continuation.md).\n(The [name](core.SyncFormulaDef.md#name) is redundant and should be the same as the `name` parameter here.\nThese will eventually be consolidated.)\n\n[]",
      "getDisplayUrl": " **getDisplayUrl**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\>\n\nA formula that that returns a browser-friendly url representing the\nresource being synced. The Coda UI links to this url as the source\nof the table data. This is typically a browser-friendly form of the\n`dynamicUrl`, which is typically an API url.\n\n[]",
      "getName": " **getName**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\>\n\nA formula that returns the name of this table.\n\n[]",
      "getSchema": " **getSchema**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<`ContextT`\\>\n\nA formula that returns the schema for this table.\n\n[]",
      "identityName": " **identityName**: `string`\n\nSee [identityName](core.SyncTableOptions.md#identityname) for an introduction.\n\nEvery dynamic schema generated from this dynamic sync table definition should all use the same name\nfor their identity. Code that refers to objects in these tables will use the dynamicUrl to\ndifferentiate which exact table to use.\n\n[]",
      "listDynamicUrls": " `Optional` **listDynamicUrls**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nA formula that returns a list of available dynamic urls that can be\nused to create an instance of this dynamic sync table.\n\n[]",
      "name": " **name**: `string`\n\nThe name of the dynamic sync table. This is shown to users in the Coda UI\nwhen listing what build blocks are contained within this pack.\nThis should describe the category of entities being synced. The actual\ntable name once added to the doc will be dynamic, it will be whatever value\nis returned by the `getName` formula.\n\n[]",
      "placeholderSchema": " `Optional` **placeholderSchema**: `SchemaT`\n\nOptional placeholder schema before the dynamic schema is retrieved.\n\nIf `defaultAddDynamicColumns` is false, only featured columns\nin placeholderSchema will be rendered by default after the sync.\n\n[]",
      "propertyOptions": " `Optional` **propertyOptions**: [`PropertyOptionsMetadataFunction`](../types/core.PropertyOptionsMetadataFunction.md)<`any`\\>\n\nAn options function to use for any dynamic schema properties.\nThe name of the property that's being modified by the doc editor\nis available in the option function's context parameter.\n\n**`Example`**\n\n```\ncoda.makeDynamicSyncTable({\n  name: \"MySyncTable\",\n  getSchema: async function (context) => {\n    return coda.makeObjectSchema({\n      properties: {\n        dynamicPropertyName: {\n          type: coda.ValueType.String,\n          codaType: coda.ValueHintType.SelectList,\n          mutable: true,\n          options: coda.OptionsType.Dynamic,\n        },\n      },\n    });\n  },\n  propertyOptions: async function (context) => {\n    if (context.propertyName === \"dynamicPropertyName\") {\n      return [\"Dynamic Value 1\", \"Dynamic value 2\"];\n    }\n    throw new coda.UserVisibleError(\n      `Cannot generate options for property ${context.propertyName}`\n    );\n  },\n  ...\n```\n\n[]",
      "searchDynamicUrls": " `Optional` **searchDynamicUrls**: [`MetadataFormulaDef`](../types/core.MetadataFormulaDef.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nA formula that returns a list of available dynamic urls that match a given\nsearch query that can be used to create an instance of this dynamic sync table.\n\n[]\n\nnav: \"EmailSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: EmailSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Email`](../enums/core.ValueHintType.md#email)\\>",
      " **`EmailSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "display": " `Optional` **display**: [`EmailDisplayType`](../enums/core.EmailDisplayType.md)\n\nHow the email should be displayed in the UI.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"EmptyFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: EmptyFormulaDef<ParamsT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ParamsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |",
    "Hierarchy": [
      "`Omit`<[`PackFormulaDef`](core.PackFormulaDef.md)<`ParamsT`, `string`\\>, ``\"execute\"``\\>",
      " **`EmptyFormulaDef`**"
    ],
    "Properties": {
      "cacheTtlSecs": {
        "Inherited from": "Omit.cacheTtlSecs\n\n[]"
      },
      "connectionRequirement": {
        "Inherited from": "Omit.connectionRequirement\n\n[]"
      },
      "description": {
        "Inherited from": "Omit.description\n\n[]"
      },
      "examples": {
        "Inherited from": "Omit.examples\n\n[]"
      },
      "extraOAuthScopes": {
        "Inherited from": "Omit.extraOAuthScopes\n\n[]"
      },
      "isAction": {
        "Inherited from": "Omit.isAction\n\n[]"
      },
      "isExperimental": {
        "Inherited from": "Omit.isExperimental\n\n[]"
      },
      "isSystem": {
        "Inherited from": "Omit.isSystem\n\n[]"
      },
      "name": {
        "Inherited from": "Omit.name\n\n[]"
      },
      "network": {
        "Inherited from": "Omit.network\n\n[]"
      },
      "parameters": {
        "Inherited from": "Omit.parameters\n\n[]"
      },
      "request": " **request**: [`RequestHandlerTemplate`](core.RequestHandlerTemplate.md)\n\nA definition of the request and any parameter transformations to make in order to implement this formula.\n\n[]",
      "varargParameters": {
        "Inherited from": "Omit.varargParameters\n\n[]\n\nnav: \"ExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: ExecutionContext": {
    "Hierarchy": [
      "**`ExecutionContext`**",
      " [`SyncExecutionContext`](core.SyncExecutionContext.md)",
      " [`UpdateSyncExecutionContext`](core.UpdateSyncExecutionContext.md)",
      " [`MockExecutionContext`](testing.MockExecutionContext.md)"
    ],
    "Properties": {
      "endpoint": " `Optional` `Readonly` **endpoint**: `string`\n\nThe base endpoint URL for the user's account, only if applicable. See\n[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl).\n\nIf the API URLs are variable based on the user account, you will need this endpoint\nto construct URLs to use with the fetcher. Alternatively, you can use relative URLs\n(e.g. \"/api/entity\") and Coda will include the endpoint for you automatically.\n\n[]",
      "fetcher": " `Readonly` **fetcher**: [`Fetcher`](core.Fetcher.md)\n\nThe [Fetcher](core.Fetcher.md) used for making HTTP requests.\n\n[]",
      "invocationLocation": " `Readonly` **invocationLocation**: [`InvocationLocation`](core.InvocationLocation.md)\n\nInformation about the Coda environment and doc this formula was invoked from.\nThis is mostly for Coda internal use and we do not recommend relying on it.\n\n[]",
      "invocationToken": " `Readonly` **invocationToken**: `string`\n\nA random token scoped to only this request invocation.\nThis is a unique identifier for the invocation, and in particular used with\n[Custom](../enums/core.AuthenticationType.md#custom) for naming template parameters that will be\nreplaced by the fetcher in secure way.\n\n[]",
      "sync": " `Optional` `Readonly` **sync**: [`Sync`](../types/core.Sync.md)<`unknown`, `unknown`, `unknown`\\>\n\nInformation about state of the current sync. Only populated if this is a sync table formula.\n\n[]",
      "temporaryBlobStorage": " `Readonly` **temporaryBlobStorage**: [`TemporaryBlobStorage`](core.TemporaryBlobStorage.md)\n\nA utility to fetch and store files and images that either require the pack user's authentication\nor are too large to return inline. See [TemporaryBlobStorage](core.TemporaryBlobStorage.md).\n\n[]",
      "timezone": " `Readonly` **timezone**: `string`\n\nThe timezone of the doc from which this formula was invoked.\n\n[]\n\nnav: \"FetchRequest\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: FetchRequest": {
    "Properties": {
      "body": " `Optional` **body**: `string` \\| `Buffer`\n\nThe body of the HTTP request, if any.\n\nIf you are sending a JSON payload, make sure to call `JSON.stringify()` on the object payload.\n\n[]",
      "cacheTtlSecs": " `Optional` **cacheTtlSecs**: `number`\n\nA time in seconds that Coda should cache the result of this HTTP request.\n\nAny time that this pack makes the same FetchRequest, a cached value can be returned\ninstead of making the HTTP request. If left unspecified, Coda will automatically\ncache all GET requests for approximately 5 minutes. To disable the default caching,\nset this value to `0`.\n\nIf you are trying to cache a POST, PUT, PATCH, or DELETE request, you must also\nset [forceCache](core.FetchRequest.md#forcecache) to true.\n\n[]",
      "disableAuthentication": " `Optional` **disableAuthentication**: `boolean`\n\nIf true, Coda will not apply authentication credentials even if this pack is\nconfigured to use authentication. This is very rare, but sometimes you may\nwish to make an unauthenticated supporting request as part of a formula implementation.\n\n[]",
      "forceCache": " `Optional` **forceCache**: `boolean`\n\nIf true, Coda will cache the request (including POST, PUT, PATCH, and DELETE) and return the\nsame response for subsequent requests. This option does *not* need to be specified to cache\nGET requests.\n\nThis is mainly used for POST requests that do not have side effects, such as querying a\nGraphQL API.\n\n[]",
      "form": {
        "Index signature": " [key: `string`]: `string`\n\n[]"
      },
      "headers": {
        "Index signature": " [header: `string`]: `string`\n\n[]"
      },
      "ignoreRedirects": " `Optional` **ignoreRedirects**: `boolean`\n\nIf true, will immediately return a response when encountering an HTTP 301\nYou may inspect the `Location` header of the response to observe the indicated redirect URL.\n\n[]",
      "isBinaryResponse": " `Optional` **isBinaryResponse**: `boolean`\n\nIndicates that you expect the response to be binary data, instructing Coda\nnot to attempt to parse the response in any way. Otherwise, Coda may attempt\nto parse the response as a JSON object. If true, [body](core.FetchResponse.md#body)\nwill be a NodeJS Buffer.\n\n[]",
      "method": " **method**: ``\"GET\"`` \\| ``\"PATCH\"`` \\| ``\"POST\"`` \\| ``\"PUT\"`` \\| ``\"DELETE\"`` \\| ``\"HEAD\"``\n\nThe HTTP method/verb (e.g. GET or POST).\n\n[]",
      "url": " **url**: `string`\n\nThe URL to connect to. This is typically an absolute URL, but if your\npack uses authentication and [requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl) and so has a unique\nendpoint per user account, you may also use a relative URL and Coda will\napply the user's endpoint automatically.\n\n[]\n\nnav: \"FetchResponse\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: FetchResponse<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `any` = `any` |",
    "Properties": {
      "body": " `Optional` **body**: `T`\n\nThe body of the response.\n\nIf the response contains JSON data, either because the Content-Type header is application/json\nor if the data is JSON-parsable, this will be a parsed JavaScript object.\nSimilarly, if the response headers are text/xml or application/xml, this will be a parsed\nJavaScript object using the `xml2js` library.\n\nIf implicit parsing is undesirable, you may consider using [isBinaryResponse](core.FetchRequest.md#isbinaryresponse) on the request\nto disable any parsing. Note however that this will result in the body being a NodeJS Buffer.\n\n[]",
      "headers": {
        "Index signature": " [header: `string`]: `string` \\| `string`[] \\| `undefined`\n\n[]"
      },
      "status": " **status**: `number`\n\nThe HTTP status code, e.g. `200`.\n\n[]\n\nnav: \"Fetcher\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: Fetcher": {
    "Methods": {
      "fetch": {
        "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | `any` |",
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `request` | [`FetchRequest`](core.FetchRequest.md) |",
        "Returns": "`Promise`<[`FetchResponse`](core.FetchResponse.md)<`T`\\>\\>\n\n[]\n\nnav: \"Format\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: Format": {
    "Properties": {
      "formulaName": " **formulaName**: `string`\n\nThe name of the formula to invoke for values in columns using this format.\nThis must correspond to the name of a regular, public formula defined in this pack.\n\n[]",
      "formulaNamespace": " `Optional` **formulaNamespace**: `string`\n\n**`Deprecated`**\n\nNamespaces are being removed from the product.\n\n[]",
      "hasNoConnection": " `Optional` **hasNoConnection**: `boolean`\n\n**`Deprecated`**\n\nNo longer needed, will be inferred from the referenced formula.\n\n[]",
      "instructions": " `Optional` **instructions**: `string`\n\nA brief, optional explanation of how users should use this format, for example, what kinds\nof values they should put in columns using this format.\n\n[]",
      "matchers": " `Optional` **matchers**: `RegExp`[]\n\nA list of regular expressions that match URLs that the formula implementing this format\nis capable of handling. As described in [Format](core.Format.md), this is a discovery mechanism.\n\n[]",
      "name": " **name**: `string`\n\nThe name of this column format. This will show to users in the column type chooser.\n\n[]",
      "placeholder": " `Optional` **placeholder**: `string`\n\n**`Deprecated`**\n\nCurrently unused.\n\n[]\n\nnav: \"HeaderBearerTokenAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: HeaderBearerTokenAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`HeaderBearerTokenAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`HeaderBearerToken`](../enums/core.AuthenticationType.md#headerbearertoken)\n\nIdentifies this as HeaderBearerToken authentication.\n\n[]\n\nnav: \"Identity\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: Identity": {
    "Hierarchy": [
      "[`IdentityDefinition`](core.IdentityDefinition.md)",
      " **`Identity`**"
    ],
    "Properties": {
      "attribution": {
        "Inherited from": "[IdentityDefinition](core.IdentityDefinition.md).[attribution](core.IdentityDefinition.md#attribution)\n\n[]"
      },
      "dynamicUrl": {
        "Inherited from": "[IdentityDefinition](core.IdentityDefinition.md).[dynamicUrl](core.IdentityDefinition.md#dynamicurl)\n\n[]"
      },
      "name": {
        "Inherited from": "[IdentityDefinition](core.IdentityDefinition.md).[name](core.IdentityDefinition.md#name)\n\n[]"
      },
      "packId": {
        "Overrides": "[IdentityDefinition](core.IdentityDefinition.md).[packId](core.IdentityDefinition.md#packid)\n\n[]\n\nnav: \"IdentityDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: IdentityDefinition": {
    "Hierarchy": [
      "**`IdentityDefinition`**",
      " [`Identity`](core.Identity.md)"
    ],
    "Properties": {
      "attribution": " `Optional` **attribution**: [`AttributionNode`](../types/core.AttributionNode.md)[]\n\n**`Deprecated`**\n\nSee [attribution](core.ObjectSchemaDefinition.md#attribution)\n\n[]",
      "dynamicUrl": " `Optional` **dynamicUrl**: `string`\n\nThe dynamic URL, if this is a schema for a dynamic sync table. When returning a schema from the\n[getSchema](core.DynamicSyncTableOptions.md#getschema) formula of a dynamic sync table, you must include\nthe dynamic URL of that table, so that rows\nin this table may be distinguished from rows in another dynamic instance of the same table.\n\nWhen creating a reference to a dynamic sync table, you must include the dynamic URL of the table\nyou wish to reference, again to distinguish which table instance you are trying to reference.\n\n[]",
      "name": " **name**: `string`\n\nThe name of this entity. This is an arbitrary name but should be unique within your pack.\nFor example, if you are defining a schema that represents a user object, \"User\" would be a good identity name.\n\n[]",
      "packId": " `Optional` **packId**: `number`\n\nThe ID of another pack, if you are trying to reference a value from different pack.\n\n[]\n\nnav: \"ImageAttributionNode\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ImageAttributionNode": {
    "Properties": {
      "anchorUrl": " **anchorUrl**: `string`\n\nThe URL to link to.\n\n[]",
      "imageUrl": " **imageUrl**: `string`\n\nThe URL of the image to render.\n\n[]",
      "type": " **type**: [`Image`](../enums/core.AttributionNodeType.md#image)\n\nIdentifies this as an image attribution node.\n\n[]\n\nnav: \"ImageSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ImageSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`ImageReference`](../enums/core.ValueHintType.md#imagereference) \\| [`ImageAttachment`](../enums/core.ValueHintType.md#imageattachment)\\>",
      " **`ImageSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "height": " `Optional` **height**: `string` \\| `number`\n\nHow tall to render the image (supports number or formula). Use 0 for default.\n\n[]",
      "imageCornerStyle": " `Optional` **imageCornerStyle**: [`ImageCornerStyle`](../enums/core.ImageCornerStyle.md)\n\nImageCornerStyle type specifying style of corners on images. If unspecified, default is Rounded.\n\n[]",
      "imageOutline": " `Optional` **imageOutline**: [`ImageOutline`](../enums/core.ImageOutline.md)\n\nImageOutline type specifying style of outline on images. If unspecified, default is Solid.\n\n[]",
      "imageShapeStyle": " `Optional` **imageShapeStyle**: [`ImageShapeStyle`](../enums/core.ImageShapeStyle.md)\n\nImageShapeStyle type specifying shape of image. If unspecified, default is Auto.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]"
      },
      "width": " `Optional` **width**: `string` \\| `number`\n\nHow wide to render the image (supports number or formula). Use 0 for default.\n\n[]\n\nnav: \"InvocationLocation\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: InvocationLocation": {
    "Properties": {
      "docId": " `Optional` **docId**: `string`\n\n**`Deprecated`**\n\nThis will be removed in a future version of the SDK.\n\n[]",
      "protocolAndHost": " **protocolAndHost**: `string`\n\nThe base URL of the Coda environment executing this formula. Only for Coda internal use.\n\n[]\n\nnav: \"LinkAttributionNode\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: LinkAttributionNode": {
    "Properties": {
      "anchorText": " **anchorText**: `string`\n\nThe text of the hyperlink.\n\n[]",
      "anchorUrl": " **anchorUrl**: `string`\n\nThe URL to link to.\n\n[]",
      "type": " **type**: [`Link`](../enums/core.AttributionNodeType.md#link)\n\nIdentifies this as a link attribution node.\n\n[]\n\nnav: \"LinkSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: LinkSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Url`](../enums/core.ValueHintType.md#url)\\>",
      " **`LinkSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "display": " `Optional` **display**: [`LinkDisplayType`](../enums/core.LinkDisplayType.md)\n\nHow the URL should be displayed in the UI.\n\n[]",
      "force": " `Optional` **force**: `boolean`\n\nWhether to force client embedding (only for LinkDisplayType.Embed) - for example, if user login required.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"MetadataFormulaObjectResultType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: MetadataFormulaObjectResultType": {
    "Properties": {
      "display": " **display**: `string`\n\nThe value displayed to the user in the UI.\n\n[]",
      "hasChildren": " `Optional` **hasChildren**: `boolean`\n\nIf true, indicates that this result has child results nested underneath it.\nThis option only applies to [listDynamicUrls](core.DynamicSyncTableOptions.md#listdynamicurls).\nWhen fetching options for entities that can be used as dynamic URLs for a dynamic sync table,\nsome APIs may return data in a hierarchy rather than a flat list of options.\n\nFor example, if your dynamic sync table synced data from a Google Drive file,\nyou might return a list of folders, and then a user could click on a folder\nto view the files within it. When returning folder results, you would set\n`hasChildren: true` on them, but omit that on the file results.\n\nLeaf nodes, that is those without `hasChildren: true`, are ultimately selectable\nto create a table. Selecting a result with `hasChildren: true` will invoke\n`listDynamicUrls` again with `value` as the second argument.\n\nThat is, your dynamic sync table definition might include:\n\n```\nlistDynamicUrls: async function(context, parentValue) {\n  ...\n}\n```\n\n`parentValue` will be undefined the initial time that `listDynamicUrls`\nis invoked, but if you return a result with `hasChildren: true` and the user\nclicks on it, `listDynamicUrls` will be invoked again, with `parentValue`\nas the `value` of the result that was clicked on.\n\n[]",
      "value": " **value**: `string` \\| `number`\n\nThe value used for the formula argument when the user selects this option.\n\n[]\n\nnav: \"MultiHeaderTokenAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: MultiHeaderTokenAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`MultiHeaderTokenAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "headers": " **headers**: { `description`: `string` ; `name`: `string` ; `tokenPrefix?`: `string`  }[]\n\nNames and descriptions of the headers used for authentication.\n\n[]",
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`MultiHeaderToken`](../enums/core.AuthenticationType.md#multiheadertoken)\n\nIdentifies this as MultiHeaderToken authentication.\n\n[]\n\nnav: \"MultiQueryParamTokenAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: MultiQueryParamTokenAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`MultiQueryParamTokenAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "params": " **params**: { `description`: `string` ; `name`: `string`  }[]\n\nNames and descriptions of the query parameters used for authentication.\n\n[]",
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`MultiQueryParamToken`](../enums/core.AuthenticationType.md#multiqueryparamtoken)\n\nIdentifies this as MultiQueryParamToken authentication.\n\n[]\n\nnav: \"Network\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: Network": {
    "Properties": {
      "connection": " `Optional` `Readonly` **connection**: [`NetworkConnection`](../enums/core.NetworkConnection.md)\n\n[]",
      "hasSideEffect": " `Optional` `Readonly` **hasSideEffect**: `boolean`\n\n[]",
      "requiresConnection": " `Optional` `Readonly` **requiresConnection**: `boolean`\n\n[]\n\nnav: \"NoAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: NoAuthentication": {
    "Properties": {
      "type": " **type**: [`None`](../enums/core.AuthenticationType.md#none)\n\nIdentifies this as not using authentication. You may also omit any definition to achieve the same result.\n\n[]\n\nnav: \"NumericDateSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: NumericDateSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Date`](../enums/core.ValueHintType.md#date)\\>",
      " **`NumericDateSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "format": " `Optional` **format**: `string`\n\nA Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"NumericDateTimeSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: NumericDateTimeSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`DateTime`](../enums/core.ValueHintType.md#datetime)\\>",
      " **`NumericDateTimeSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "dateFormat": " `Optional` **dateFormat**: `string`\n\nA Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "timeFormat": " `Optional` **timeFormat**: `string`\n\nA Moment time format string, such as 'HH:mm:ss', that corresponds to a supported Coda time column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"NumericDurationSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: NumericDurationSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Duration`](../enums/core.ValueHintType.md#duration)\\>",
      " **`NumericDurationSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "maxUnit": " `Optional` **maxUnit**: [`DurationUnit`](../enums/core.DurationUnit.md)\n\nThe unit to use for rounding the duration when rendering. For example, if using `DurationUnit.Days`,\nand a value of 273600 is provided (3 days 4 hours) is provided, it will be rendered as \"3 days\".\n\n[]",
      "precision": " `Optional` **precision**: `number`\n\nA refinement of [maxUnit](core.DurationSchema.md#maxunit) to use for rounding the duration when rendering.\nCurrently only `1` is supported, which is the same as omitting a value.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"NumericSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: NumericSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`",
      " **`NumericSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "precision": " `Optional` **precision**: `number`\n\nThe decimal precision. The number will be rounded to this precision when rendered.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]"
      },
      "useThousandsSeparator": " `Optional` **useThousandsSeparator**: `boolean`\n\nIf specified, will render thousands separators for large numbers, e.g. `1,234,567.89`.\n\n[]\n\nnav: \"NumericTimeSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: NumericTimeSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Time`](../enums/core.ValueHintType.md#time)\\>",
      " **`NumericTimeSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "format": " `Optional` **format**: `string`\n\nA Moment time format string, such as 'HH:mm:ss', that corresponds to a supported Coda time column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"OAuth2Authentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: OAuth2Authentication": {
    "Hierarchy": [
      "`BaseOAuthAuthentication`",
      " **`OAuth2Authentication`**"
    ],
    "Properties": {
      "additionalParams": {
        "Index signature": " [key: `string`]: `any`\n\n[]"
      },
      "authorizationUrl": " **authorizationUrl**: `string`\n\nThe URL to which the user will be redirected in order to authorize this pack.\nThis is typically just a base url with no parameters. Coda will append the `scope`\nparameter automatically. If the authorization flow requires additional parameters,\nthey may be specified using [additionalParams](core.OAuth2Authentication.md#additionalparams).\n\n[]",
      "credentialsLocation": {
        "Inherited from": "BaseOAuthAuthentication.credentialsLocation\n\n[]"
      },
      "endpointDomain": {
        "Inherited from": "BaseOAuthAuthentication.endpointDomain\n\n[]"
      },
      "endpointKey": " `Optional` **endpointKey**: `string`\n\nIn rare cases, OAuth providers will return the specific API endpoint domain for the user as\npart of the OAuth token exchange response. If so, this is the property in the OAuth\ntoken exchange response JSON body that points to the endpoint.\n\nThe endpoint will be saved along with the account and will be available during execution\nas [endpoint](core.ExecutionContext.md#endpoint).\n\n[]",
      "getConnectionName": {
        "Inherited from": "BaseOAuthAuthentication.getConnectionName\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "BaseOAuthAuthentication.instructionsUrl\n\n[]"
      },
      "nestedResponseKey": {
        "Inherited from": "BaseOAuthAuthentication.nestedResponseKey\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "BaseOAuthAuthentication.networkDomain\n\n[]"
      },
      "pkceChallengeMethod": " `Optional` **pkceChallengeMethod**: ``\"plain\"`` \\| ``\"S256\"``\n\nSee [useProofKeyForCodeExchange](core.OAuth2Authentication.md#useproofkeyforcodeexchange)\n\n[]",
      "postSetup": {
        "Inherited from": "BaseOAuthAuthentication.postSetup\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "BaseOAuthAuthentication.requiresEndpointUrl\n\n[]"
      },
      "scopeDelimiter": {
        "Inherited from": "BaseOAuthAuthentication.scopeDelimiter\n\n[]"
      },
      "scopeParamName": {
        "Inherited from": "BaseOAuthAuthentication.scopeParamName\n\n[]"
      },
      "scopes": {
        "Inherited from": "BaseOAuthAuthentication.scopes\n\n[]"
      },
      "tokenPrefix": {
        "Inherited from": "BaseOAuthAuthentication.tokenPrefix\n\n[]"
      },
      "tokenQueryParam": {
        "Inherited from": "BaseOAuthAuthentication.tokenQueryParam\n\n[]"
      },
      "tokenUrl": {
        "Inherited from": "BaseOAuthAuthentication.tokenUrl\n\n[]"
      },
      "type": " **type**: [`OAuth2`](../enums/core.AuthenticationType.md#oauth2)\n\nIdentifies this as OAuth2 authentication.\n\n[]",
      "useProofKeyForCodeExchange": " `Optional` **useProofKeyForCodeExchange**: `boolean`\n\nOption to apply PKCE (Proof Key for Code Exchange) OAuth2 extension. With PKCE extension,\na `code_challenge` parameter and a `code_challenge_method` parameter will be sent to the\nauthorization page. A `code_verifier` parameter will be sent to the token exchange API as\nwell.\n\n`code_challenge_method` defaults to SHA256 and can be configured with [pkceChallengeMethod](core.OAuth2Authentication.md#pkcechallengemethod).\n\nSee https://datatracker.ietf.org/doc/html/rfc7636 for more details.\n\n[]\n\nnav: \"OAuth2ClientCredentialsAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: OAuth2ClientCredentialsAuthentication": {
    "Hierarchy": [
      "`BaseOAuthAuthentication`",
      " **`OAuth2ClientCredentialsAuthentication`**"
    ],
    "Properties": {
      "credentialsLocation": {
        "Inherited from": "BaseOAuthAuthentication.credentialsLocation\n\n[]"
      },
      "endpointDomain": {
        "Inherited from": "BaseOAuthAuthentication.endpointDomain\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "BaseOAuthAuthentication.getConnectionName\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "BaseOAuthAuthentication.instructionsUrl\n\n[]"
      },
      "nestedResponseKey": {
        "Inherited from": "BaseOAuthAuthentication.nestedResponseKey\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "BaseOAuthAuthentication.networkDomain\n\n[]"
      },
      "postSetup": {
        "Inherited from": "BaseOAuthAuthentication.postSetup\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "BaseOAuthAuthentication.requiresEndpointUrl\n\n[]"
      },
      "scopeDelimiter": {
        "Inherited from": "BaseOAuthAuthentication.scopeDelimiter\n\n[]"
      },
      "scopeParamName": {
        "Inherited from": "BaseOAuthAuthentication.scopeParamName\n\n[]"
      },
      "scopes": {
        "Inherited from": "BaseOAuthAuthentication.scopes\n\n[]"
      },
      "tokenPrefix": {
        "Inherited from": "BaseOAuthAuthentication.tokenPrefix\n\n[]"
      },
      "tokenQueryParam": {
        "Inherited from": "BaseOAuthAuthentication.tokenQueryParam\n\n[]"
      },
      "tokenUrl": {
        "Inherited from": "BaseOAuthAuthentication.tokenUrl\n\n[]"
      },
      "type": " **type**: [`OAuth2ClientCredentials`](../enums/core.AuthenticationType.md#oauth2clientcredentials)\n\nIdentifies this as OAuth2 client credentials authentication.\n\n[]\n\nnav: \"ObjectArrayFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ObjectArrayFormulaDef<ParamsT, SchemaT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ParamsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`Schema`](../types/core.Schema.md) |",
    "Hierarchy": [
      "`Omit`<[`PackFormulaDef`](core.PackFormulaDef.md)<`ParamsT`, [`SchemaType`](../types/core.SchemaType.md)<`SchemaT`\\>\\>, ``\"execute\"``\\>",
      " **`ObjectArrayFormulaDef`**"
    ],
    "Properties": {
      "cacheTtlSecs": {
        "Inherited from": "Omit.cacheTtlSecs\n\n[]"
      },
      "connectionRequirement": {
        "Inherited from": "Omit.connectionRequirement\n\n[]"
      },
      "description": {
        "Inherited from": "Omit.description\n\n[]"
      },
      "examples": {
        "Inherited from": "Omit.examples\n\n[]"
      },
      "extraOAuthScopes": {
        "Inherited from": "Omit.extraOAuthScopes\n\n[]"
      },
      "isAction": {
        "Inherited from": "Omit.isAction\n\n[]"
      },
      "isExperimental": {
        "Inherited from": "Omit.isExperimental\n\n[]"
      },
      "isSystem": {
        "Inherited from": "Omit.isSystem\n\n[]"
      },
      "name": {
        "Inherited from": "Omit.name\n\n[]"
      },
      "network": {
        "Inherited from": "Omit.network\n\n[]"
      },
      "parameters": {
        "Inherited from": "Omit.parameters\n\n[]"
      },
      "request": " **request**: [`RequestHandlerTemplate`](core.RequestHandlerTemplate.md)\n\nA definition of the request and any parameter transformations to make in order to implement this formula.\n\n[]",
      "response": " **response**: [`ResponseHandlerTemplate`](core.ResponseHandlerTemplate.md)<`SchemaT`\\>\n\nA definition of the schema for the object list returned by this function.\n\n[]",
      "varargParameters": {
        "Inherited from": "Omit.varargParameters\n\n[]\n\nnav: \"ObjectSchemaDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: ObjectSchemaDefinition<K, L\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |",
    "Hierarchy": [
      "`BaseSchema`",
      "[`PropertyWithOptions`](core.PropertyWithOptions.md)<{}\\>",
      " **`ObjectSchemaDefinition`**"
    ],
    "Properties": {
      "attribution": " `Optional` **attribution**: [`AttributionNode`](../types/core.AttributionNode.md)[]\n\nAttribution text, images, and/or links that should be rendered along with this value.\n\nSee [makeAttributionNode](../functions/core.makeAttributionNode.md).\n\n[]",
      "codaType": " `Optional` **codaType**: [`Person`](../enums/core.ValueHintType.md#person) \\| [`Reference`](../enums/core.ValueHintType.md#reference) \\| [`SelectList`](../enums/core.ValueHintType.md#selectlist)\n\nA hint for how Coda should interpret and render this object value.\n\nFor example, an object can represent a person (user) in a Coda doc, with properties for the\nemail address of the person and their name. Using `ValueHintType.Person` tells Coda to\nrender such a value as an @-reference to that person, rather than a basic object chip.\n\n[]",
      "description": {
        "Inherited from": "BaseSchema.description\n\n[]"
      },
      "displayProperty": " `Optional` **displayProperty**: `K`\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that be used to label this object in the\nUI.\nObject values can contain many properties and the Coda UI will display them as a \"chip\"\nwith only the value of the \"displayProperty\" property used as the chip's display label.\nThe other properties can be seen when hovering over the chip.\n\n[]",
      "featured": " `Optional` **featured**: `L`[]\n\n**`Deprecated`**\n\nUse [featuredProperties](core.ObjectSchemaDefinition.md#featuredproperties)\n\n[]",
      "featuredProperties": " `Optional` **featuredProperties**: `L`[]\n\nA list of property names from within [properties](core.ObjectSchemaDefinition.md#properties) for the \"featured\" properties\nof this object, used in sync tables. When a sync table is first added to a document,\ncolumns are created for each of the featured properties. The user can easily add additional\ncolumns for any other properties, as desired. All featured properties need to be top-level.\nIf you can't or don't want to change the received data format, consider changing the\nreceived object after fetching and before returning and assigning it to the schema.\n\nThis distinction exists for cases where a sync table may include dozens of properties,\nwhich would create a very wide table that is difficult to use. Featuring properties\nallows a sync table to be created with the most useful columns created by default,\nand the user can add additional columns as they find them useful.\n\nNon-featured properties can always be referenced in formulas regardless of whether column\nprojections have been created for them.\n\n[]",
      "id": " `Optional` **id**: `K`\n\n**`Deprecated`**\n\nUse [idProperty](core.ObjectSchemaDefinition.md#idproperty)\n\n[]",
      "idProperty": " `Optional` **idProperty**: `K`\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that represents a unique id for this\nobject. Sync table schemas must specify an id property, which uniquely identify each synced row.\n\n[]",
      "identity": " `Optional` **identity**: [`IdentityDefinition`](core.IdentityDefinition.md)\n\nAn identity for this schema, if this schema is important enough to be named and referenced.\nSee [IdentityDefinition](core.IdentityDefinition.md).\n\n[]",
      "imageProperty": " `Optional` **imageProperty**: [`PropertyIdentifier`](../types/core.PropertyIdentifier.md)<`K`\\>\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that can be used as a rich image preview of\nthe object.\n\nMust be a [String](../enums/core.ValueType.md#string) property with the\n[ImageAttachment](../enums/core.ValueHintType.md#imageattachment) or [ImageReference](../enums/core.ValueHintType.md#imagereference) hints\n\n[]",
      "includeUnknownProperties": " `Optional` **includeUnknownProperties**: `boolean`\n\nSpecifies that object instances with this schema can contain additional properties not defined\nin the schema, and that the packs infrastructure should retain these unknown properties\nrather than stripping them.\n\nProperties not declared in the schema will not work properly in Coda: they cannot be\nused natively in the formula language and will not have correct types in Coda. But, in certain\nscenarios they can be useful.\n\n[]",
      "linkProperty": " `Optional` **linkProperty**: [`PropertyIdentifier`](../types/core.PropertyIdentifier.md)<`K`\\>\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that will\nnavigate users to more details about this object\n\nMust be a [String](../enums/core.ValueType.md#string) property with a [Url](../enums/core.ValueHintType.md#url)\n[codaType](core.ObjectSchemaDefinition.md#codatype).\n\n[]",
      "options": {
        "Inherited from": "[PropertyWithOptions](core.PropertyWithOptions.md).[options](core.PropertyWithOptions.md#options)\n\n[]"
      },
      "primary": " `Optional` **primary**: `K`\n\n**`Deprecated`**\n\nUse [displayProperty](core.ObjectSchemaDefinition.md#displayproperty)\n\n[]",
      "properties": " **properties**: [`ObjectSchemaProperties`](../types/core.ObjectSchemaProperties.md)<`K` \\| `L`\\>\n\nDefinition of the key-value pairs in this object.\n\n[]",
      "requireForUpdates": {
        "Inherited from": "[PropertyWithOptions](core.PropertyWithOptions.md).[requireForUpdates](core.PropertyWithOptions.md#requireforupdates)\n\n[]"
      },
      "snippetProperty": " `Optional` **snippetProperty**: [`PropertyIdentifier`](../types/core.PropertyIdentifier.md)<`K`\\>\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that be used as a textual summary\nof the object.\n\nMust be a [String](../enums/core.ValueType.md#string) property or [Array](../enums/core.ValueType.md#array) of [String](../enums/core.ValueType.md#string)s.\n\n[]",
      "subtitleProperties": " `Optional` **subtitleProperties**: [`PropertyIdentifier`](../types/core.PropertyIdentifier.md)<`K`\\>[]\n\nA list of property names from within [properties](core.ObjectSchemaDefinition.md#properties) for the properties of the object\nto be shown in the subtitle of a rich card preview for formulas that return this object.\nDefaults to the value of [featuredProperties](core.ObjectSchemaDefinition.md#featuredproperties) if not specified.\n\n[]",
      "titleProperty": " `Optional` **titleProperty**: [`PropertyIdentifier`](../types/core.PropertyIdentifier.md)<`K`\\>\n\nThe name of a property within [properties](core.ObjectSchemaDefinition.md#properties) that will be used as a title of a rich card preview\nfor formulas that return this object.\nDefaults to the value of [displayProperty](core.ObjectSchemaDefinition.md#displayproperty) if not specified\n\nMust be a [String](../enums/core.ValueType.md#string) property\n\n[]",
      "type": " **type**: [`Object`](../enums/core.ValueType.md#object)\n\nIdentifies this schema as an object schema.\n\n[]\n\nnav: \"ObjectSchemaProperty\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ObjectSchemaProperty": {
    "Properties": {
      "displayName": " `Optional` **displayName**: `string`\n\nWithout a `displayName`, a property's key will become the user-visible name. This isn't ideal\nbecause the key must also be used by the Coda formula language to refer to the property, requiring\nlossy transformation.\n\nYou probably want to set displayName if:\n\n['You want a display name with punctuation (e.g., \"Version(s)\", \"Priority/Urgency\", \"Done?\", \"Alice\\'s Thing\")', 'Your property key is not appropriate to show to an end-user (e.g., \"custom_field_123\")']\n\nOnly supported for top-level properties of a sync table.\n\n[]",
      "fixedId": " `Optional` **fixedId**: `string`\n\nOptional fixed ID for this property, used to support renames of properties over time. If specified,\nchanges to the name of this property will not cause the property to be treated as a new property.\n\nOnly supported for top-level properties of a sync table.\n\nNote that fixedIds must already be present on the existing schema prior to rolling out a name change in a\nnew schema; adding fixedId and a name change in a single schema version change will not work.\n\n[]",
      "fromKey": " `Optional` **fromKey**: `string`\n\nThe name of a field in a return value object that should be re-mapped to this property.\nThis provides a way to rename fields from API responses without writing code.\n\nSuppose that you're fetching an object from an API that has a property called \"duration\".\nBut in your pack, you'd like the value to be called \"durationSeconds\" to be more precise.\nYou could write code in your `execute` function to relabel the field, but you could\nalso use `fromKey` and Coda will do it for you.\n\nSuppose your `execute` function looked like this:\n\n```\nexecute: async function(context) {\n  const response = await context.fetcher.fetch({method: \"GET\", url: \"/api/some-entity\"});\n  // Suppose the body of the response looks like {duration: 123, name: \"foo\"}.\n  return response.body;\n}\n```\n\nYou can define your schema like this:\n\n```\ncoda.makeObjectSchema({\n  properties: {\n    name: {type: coda.ValueType.String},\n    durationSeconds: {type: coda.ValueType.Number, fromKey: \"duration\"},\n  },\n});\n```\n\nThis tells Coda to transform your formula's return value, creating a field \"durationSeconds\"\nwhose value comes another field called \"duration\".\n\n[]",
      "mutable": " `Optional` **mutable**: `boolean`\n\nWhether this object schema property is editable by the user in the UI.\n\nOnly supported for top-level properties of a sync table.\n\n[]",
      "required": " `Optional` **required**: `boolean`\n\nWhen true, indicates that an object return value for a formula that has this schema must\ninclude a non-empty value for this property.\n\n[]\n\nnav: \"OptionalParamDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: OptionalParamDef<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `UnionType` |",
    "Hierarchy": [
      "[`ParamDef`](core.ParamDef.md)<`T`\\>",
      " **`OptionalParamDef`**"
    ],
    "Properties": {
      "autocomplete": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[autocomplete](core.ParamDef.md#autocomplete)\n\n[]"
      },
      "defaultValue": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[defaultValue](core.ParamDef.md#defaultvalue)\n\n[]"
      },
      "description": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[description](core.ParamDef.md#description)\n\n[]"
      },
      "name": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[name](core.ParamDef.md#name)\n\n[]"
      },
      "optional": {
        "Overrides": "[ParamDef](core.ParamDef.md).[optional](core.ParamDef.md#optional)\n\n[]"
      },
      "suggestedValue": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[suggestedValue](core.ParamDef.md#suggestedvalue)\n\n[]"
      },
      "type": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[type](core.ParamDef.md#type)\n\n[]\n\nnav: \"PackDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: PackDefinition": {
    "Hierarchy": [
      "[`PackVersionDefinition`](core.PackVersionDefinition.md)",
      " **`PackDefinition`**"
    ],
    "Properties": {
      "category": " `Optional` **category**: `PackCategory`\n\n[]",
      "defaultAuthentication": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[defaultAuthentication](core.PackVersionDefinition.md#defaultauthentication)\n\n[]"
      },
      "description": " **description**: `string`\n\n[]",
      "exampleImages": " `Optional` **exampleImages**: `string`[]\n\n[]",
      "exampleVideoIds": " `Optional` **exampleVideoIds**: `string`[]\n\n[]",
      "formats": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[formats](core.PackVersionDefinition.md#formats)\n\n[]"
      },
      "formulaNamespace": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[formulaNamespace](core.PackVersionDefinition.md#formulanamespace)\n\n[]"
      },
      "formulas": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[formulas](core.PackVersionDefinition.md#formulas)\n\n[]"
      },
      "id": " **id**: `number`\n\n[]",
      "isSystem": " `Optional` **isSystem**: `boolean`\n\nWhether this is a pack that will be used by Coda internally and not exposed directly to users.\n\n[]",
      "logoPath": " **logoPath**: `string`\n\n[]",
      "minimumFeatureSet": " `Optional` **minimumFeatureSet**: `FeatureSet`\n\n[]",
      "name": " **name**: `string`\n\n[]",
      "networkDomains": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[networkDomains](core.PackVersionDefinition.md#networkdomains)\n\n[]"
      },
      "permissionsDescription": " `Optional` **permissionsDescription**: `string`\n\n[]",
      "quotas": " `Optional` **quotas**: `Partial`<{ `Basic`: `Quota` ; `Enterprise`: `Quota` ; `Pro`: `Quota` ; `Team`: `Quota`  }\\>\n\n[]",
      "rateLimits": " `Optional` **rateLimits**: `RateLimits`\n\n[]",
      "shortDescription": " **shortDescription**: `string`\n\n[]",
      "syncTables": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[syncTables](core.PackVersionDefinition.md#synctables)\n\n[]"
      },
      "systemConnectionAuthentication": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[systemConnectionAuthentication](core.PackVersionDefinition.md#systemconnectionauthentication)\n\n[]"
      },
      "version": {
        "Inherited from": "[PackVersionDefinition](core.PackVersionDefinition.md).[version](core.PackVersionDefinition.md#version)\n\n[]\n\nnav: \"PackFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: PackFormulaDef<ParamsT, ResultT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ParamsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `ResultT` | extends [`PackFormulaResult`](../types/core.PackFormulaResult.md) |\n| `ContextT` | extends [`ExecutionContext`](core.ExecutionContext.md) = [`ExecutionContext`](core.ExecutionContext.md) |",
    "Hierarchy": [
      "[`CommonPackFormulaDef`](core.CommonPackFormulaDef.md)<`ParamsT`\\>",
      " **`PackFormulaDef`**",
      " [`BaseFormulaDef`](core.BaseFormulaDef.md)"
    ],
    "Properties": {
      "cacheTtlSecs": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[cacheTtlSecs](core.CommonPackFormulaDef.md#cachettlsecs)\n\n[]"
      },
      "connectionRequirement": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[connectionRequirement](core.CommonPackFormulaDef.md#connectionrequirement)\n\n[]"
      },
      "description": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[description](core.CommonPackFormulaDef.md#description)\n\n[]"
      },
      "examples": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[examples](core.CommonPackFormulaDef.md#examples)\n\n[]"
      },
      "extraOAuthScopes": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[extraOAuthScopes](core.CommonPackFormulaDef.md#extraoauthscopes)\n\n[]"
      },
      "isAction": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isAction](core.CommonPackFormulaDef.md#isaction)\n\n[]"
      },
      "isExperimental": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isExperimental](core.CommonPackFormulaDef.md#isexperimental)\n\n[]"
      },
      "isSystem": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isSystem](core.CommonPackFormulaDef.md#issystem)\n\n[]"
      },
      "name": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[name](core.CommonPackFormulaDef.md#name)\n\n[]"
      },
      "network": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[network](core.CommonPackFormulaDef.md#network)\n\n[]"
      },
      "parameters": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[parameters](core.CommonPackFormulaDef.md#parameters)\n\n[]"
      },
      "varargParameters": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[varargParameters](core.CommonPackFormulaDef.md#varargparameters)"
      }
    },
    "Methods": {
      "execute": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `params` | [`ParamValues`](../types/core.ParamValues.md)<`ParamsT`\\> |\n| `context` | `ContextT` |",
        "Returns": "`ResultT` \\| `Promise`<`ResultT`\\>\n\n[]\n\nnav: \"PackVersionDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: PackVersionDefinition": {
    "Hierarchy": [
      "**`PackVersionDefinition`**",
      " [`PackDefinition`](core.PackDefinition.md)"
    ],
    "Properties": {
      "defaultAuthentication": " `Optional` **defaultAuthentication**: [`Authentication`](../types/core.Authentication.md)\n\nIf specified, the user must provide personal authentication credentials before using the pack.\n\n[]",
      "formats": " `Optional` **formats**: [`Format`](core.Format.md)[]\n\nDefinitions of this pack's column formats. See [Format](core.Format.md).\n\n[]",
      "formulaNamespace": " `Optional` **formulaNamespace**: `string`\n\n**`Deprecated`**\n\n[]",
      "formulas": " `Optional` **formulas**: [`Formula`](../types/core.Formula.md)[]\n\nDefinitions of this pack's formulas. See [Formula](../types/core.Formula.md).\n\nNote that button actions are also defined here. Buttons are simply formulas\nwith `isAction: true`.\n\n[]",
      "networkDomains": " `Optional` **networkDomains**: `string`[]\n\nAny domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be\ndeclared up front here, both to clearly communicate to users what a pack is capable of connecting to,\nand for security reasons. These network domains are enforced at execution time: any fetcher request\nto a domain not listed here will be rejected.\n\nOnly one network domain is allowed by default. If your pack has needs to connect to multiple domains\ncontact Coda support for approval.\n\n[]",
      "syncTables": " `Optional` **syncTables**: [`SyncTable`](../types/core.SyncTable.md)[]\n\nDefinitions of this pack's sync tables. See [SyncTable](../types/core.SyncTable.md).\n\n[]",
      "systemConnectionAuthentication": " `Optional` **systemConnectionAuthentication**: [`SystemAuthentication`](../types/core.SystemAuthentication.md)\n\nIf specified, this pack requires system credentials to be set up via Coda's admin console in order to work when no\nexplicit connection is specified by the user.\n\n[]",
      "version": " **version**: `string`\n\nThe semantic version of the pack. This must be valid semantic version of the form `1`, `1.2`, or `1.2.3`.\nWhen uploading a pack version, the semantic version must be greater than any previously uploaded version.\n\n[]\n\nnav: \"ParamDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ParamDef<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `UnionType` |",
    "Hierarchy": [
      "**`ParamDef`**",
      " [`OptionalParamDef`](core.OptionalParamDef.md)",
      " [`RequiredParamDef`](core.RequiredParamDef.md)"
    ],
    "Properties": {
      "autocomplete": " `Optional` **autocomplete**: [`MetadataFormula`](../types/core.MetadataFormula.md)\n\nA [MetadataFormula](../types/core.MetadataFormula.md) that returns valid values for this parameter, optionally matching a search\nquery. This can be useful both if there are a fixed number of valid values for the parameter,\nor if the valid values from the parameter can be looked up from some API.\nUse [makeMetadataFormula](../functions/core.makeMetadataFormula.md) to wrap a function that implements your autocomplete logic.\nTypically once you have fetched the list of matching values, you'll use\n[autocompleteSearchObjects](../functions/core.autocompleteSearchObjects.md) to handle searching over those values.\nIf you have a hardcoded list of valid values, you would only need to use\n[makeSimpleAutocompleteMetadataFormula](../functions/core.makeSimpleAutocompleteMetadataFormula.md).\n\n[]",
      "defaultValue": " `Optional` **defaultValue**: [`SuggestedValueType`](../types/core.SuggestedValueType.md)<`T`\\>\n\n**`Deprecated`**\n\nThis will be removed in a future version of the SDK. Use [suggestedValue](core.ParamDef.md#suggestedvalue) instead.\n\n[]",
      "description": " **description**: `string`\n\nA brief description of what this parameter is used for, shown to the user when invoking the formula.\n\n[]",
      "name": " **name**: `string`\n\nThe name of the parameter, which will be shown to the user when invoking this formula.\n\n[]",
      "optional": " `Optional` **optional**: `boolean`\n\nWhether this parameter can be omitted when invoking the formula.\nAll optional parameters must come after all non-optional parameters.\n\n[]",
      "suggestedValue": " `Optional` **suggestedValue**: [`SuggestedValueType`](../types/core.SuggestedValueType.md)<`T`\\>\n\nThe suggested value to be prepopulated for this parameter if it is not specified by the user.\n\n[]",
      "type": " **type**: `T`\n\nThe data type of this parameter (string, number, etc).\n\n[]\n\nnav: \"ProgressBarSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ProgressBarSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`ProgressBar`](../enums/core.ValueHintType.md#progressbar)\\>",
      " **`ProgressBarSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "maximum": " `Optional` **maximum**: `string` \\| `number`\n\nThe maximum value selectable by this progress bar (supports number or formula).\n\n[]",
      "minimum": " `Optional` **minimum**: `string` \\| `number`\n\nThe minimum value selectable by this progress bar (supports number or formula).\n\n[]",
      "showValue": " `Optional` **showValue**: `boolean`\n\nWhether to display the underlying numeric value in addition to the progress bar.\n\n[]",
      "step": " `Optional` **step**: `string` \\| `number`\n\nThe minimum amount the progress bar can be moved when dragged (supports number or formula).\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"PropertyIdentifierDetails\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: PropertyIdentifierDetails": {
    "Properties": {
      "label": " `Optional` **label**: `string`\n\nAn optional label for the property. This will be used in locations where the label appears with the property.\n\nIf set to '', the label will be omitted.\n\n[]",
      "placeholder": " `Optional` **placeholder**: `string`\n\nAn optional placeholder value, which will be rendered when the property value is an empty value\n(null, undefined, \"\", [], {}). This will be used in the Pack card title, subtitle, and snippet.\nNot accessible within the Coda formula language.\n\n[]",
      "property": " **property**: `string`\n\nThe value of the property to reference. Can be either an exact property name or a json path.\n\n[]\n\nnav: \"PropertyOptionsExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: PropertyOptionsExecutionContext": {
    "Hierarchy": [
      "[`SyncExecutionContext`](core.SyncExecutionContext.md)",
      " **`PropertyOptionsExecutionContext`**"
    ],
    "Properties": {
      "endpoint": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[endpoint](core.SyncExecutionContext.md#endpoint)\n\n[]"
      },
      "fetcher": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[fetcher](core.SyncExecutionContext.md#fetcher)\n\n[]"
      },
      "invocationLocation": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[invocationLocation](core.SyncExecutionContext.md#invocationlocation)\n\n[]"
      },
      "invocationToken": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[invocationToken](core.SyncExecutionContext.md#invocationtoken)\n\n[]"
      },
      "propertyName": " `Readonly` **propertyName**: `string`\n\nWhich property is being edited.\n\n[]",
      "propertySchema": " `Readonly` **propertySchema**: `Object`\n\nSchema of the property being edited. See [Schema](../types/core.Schema.md).\n\n[]",
      "propertyValues": {
        "Index signature": " [propertyValues: `string`]: `any`\n\n[]"
      },
      "search": " `Readonly` **search**: `string`\n\nWhat the user typed. For example, they may have type \"Ja\" while searching for a user named\n\"Jane\".\n\n[]",
      "sync": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[sync](core.SyncExecutionContext.md#sync)\n\n[]"
      },
      "temporaryBlobStorage": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[temporaryBlobStorage](core.SyncExecutionContext.md#temporaryblobstorage)\n\n[]"
      },
      "timezone": {
        "Inherited from": "[SyncExecutionContext](core.SyncExecutionContext.md).[timezone](core.SyncExecutionContext.md#timezone)\n\n[]\n\nnav: \"PropertyWithOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: PropertyWithOptions<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends [`PackFormulaResult`](../types/core.PackFormulaResult.md) |",
    "Hierarchy": [
      "**`PropertyWithOptions`**",
      " [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)"
    ],
    "Properties": {
      "options": " `Optional` **options**: [`PropertySchemaOptions`](../types/core.PropertySchemaOptions.md)<`T`\\>\n\nA list of values or a formula that returns a list of values to suggest when someone\nedits this property.\n\n**`Example`**\n\n```\nproperties: {\n  color: {\n     type: coda.ValueType.String,\n     codaType: coda.ValueHintType.SelectList,\n     mutable: true,\n     options: ['red', 'green', 'blue'],\n  },\n  user: {\n     type: coda.ValueType.String,\n     codaType: coda.ValueHintType.SelectList,\n     mutable: true,\n     options: async function (context) {\n       let url = coda.withQueryParams(\"https://example.com/userSearch\", { name: context.search });\n       let response = await context.fetcher.fetch({ method: \"GET\", url: url });\n       let results = response.body.users;\n       return results.map(user => {display: user.name, value: user.id})\n     },\n  },\n}\n```\n\n[]",
      "requireForUpdates": " `Optional` **requireForUpdates**: `boolean`\n\nBlocks updates from being sent with a blank value.\n\n[]\n\nnav: \"QueryParamTokenAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: QueryParamTokenAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`QueryParamTokenAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "paramName": " **paramName**: `string`\n\nThe name of the query parameter that will include the token,\ne.g. \"foo\" if a token is passed as \"foo=bar\".\n\n[]",
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`QueryParamToken`](../enums/core.AuthenticationType.md#queryparamtoken)\n\nIdentifies this as QueryParamToken authentication.\n\n[]\n\nnav: \"RequestHandlerTemplate\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: RequestHandlerTemplate": {
    "Properties": {
      "bodyParams": " `Optional` **bodyParams**: `string`[]\n\nThe names of parameters that should be included in the request body, if applicable.\n\nThat is, if some of the formula parameters should go into the URL and others should go into the body,\nspecify the subset of parameters here that should go into the body. If all of the formula parameters\nshould go into the body, list all of the parameter names here.\n\nThese are the mapped names if you are using [nameMapping](core.RequestHandlerTemplate.md#namemapping).\n\n[]",
      "bodyTemplate": " `Optional` **bodyTemplate**: `object`\n\nA base JavaScript object to be used as the body payload. Any parameters named in [bodyParams](core.RequestHandlerTemplate.md#bodyparams)\nwill be merged into this object, and the resulting object will be stringified and sent as the body.\n\n[]",
      "headers": {
        "Index signature": " [header: `string`]: `string`\n\n[]"
      },
      "method": " **method**: ``\"GET\"`` \\| ``\"PATCH\"`` \\| ``\"POST\"`` \\| ``\"PUT\"`` \\| ``\"DELETE\"`` \\| ``\"HEAD\"``\n\nThe HTTP method (verb) to use, e.g. \"GET\".\n\nIf making a POST request or any request that uses a body payload, the body is\nassumed to be JSON.\n\n[]",
      "nameMapping": {
        "Index signature": " [functionParamName: `string`]: `string`\n\n[]"
      },
      "queryParams": " `Optional` **queryParams**: `string`[]\n\nThe names of parameters that should be included in the request URL.\n\nThat is, if some of the formula parameters should go into the URL and others should go into the body,\nspecify the subset of parameters here that should go into the URL. If all of the formula parameters\nshould become URL parameters, list all of the parameter names here.\n\nThese are the mapped names if you are using [nameMapping](core.RequestHandlerTemplate.md#namemapping).\n\n[]",
      "transforms": {
        "Index signature": " [name: `string`]: (`val`: `any`) => `any`\n\n[]"
      },
      "url": " **url**: `string`\n\nThe URL to fetch.\n\nThe path of the URL can include strong formatting directives that can be replaced with\nformula parameters, e.g. \"https://example.com/api/{name}\".\n\n[]\n\nnav: \"RequiredParamDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: RequiredParamDef<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `UnionType` |",
    "Hierarchy": [
      "[`ParamDef`](core.ParamDef.md)<`T`\\>",
      " **`RequiredParamDef`**"
    ],
    "Properties": {
      "autocomplete": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[autocomplete](core.ParamDef.md#autocomplete)\n\n[]"
      },
      "defaultValue": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[defaultValue](core.ParamDef.md#defaultvalue)\n\n[]"
      },
      "description": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[description](core.ParamDef.md#description)\n\n[]"
      },
      "name": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[name](core.ParamDef.md#name)\n\n[]"
      },
      "optional": {
        "Overrides": "[ParamDef](core.ParamDef.md).[optional](core.ParamDef.md#optional)\n\n[]"
      },
      "suggestedValue": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[suggestedValue](core.ParamDef.md#suggestedvalue)\n\n[]"
      },
      "type": {
        "Inherited from": "[ParamDef](core.ParamDef.md).[type](core.ParamDef.md#type)\n\n[]\n\nnav: \"ResponseHandlerTemplate\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: ResponseHandlerTemplate<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends [`Schema`](../types/core.Schema.md) |",
    "Properties": {
      "projectKey": " `Optional` **projectKey**: `string`\n\nThe key in the response body that indicates the objects of interest.\n\nSometimes the response body is itself an array of objects, allowing you\nto return the body as-is, but more commonly, the response body is\nan object where one of its properties is the array of objects of interest,\nwith other properties containing metadata about the response.\n\nThis allows you to specify a response property name to \"project\" out\nthe relevant part of the response body.\n\nFor example, suppose the response body looks like:\n\n```\n{\n  items: [{name: \"Alice\"}, {name: \"Bob\"}],\n  nextPageUrl: \"/users?page=2\",\n}\n```\n\nYou would set `projectKey: \"items\"` and the generated formula implementation\nwill return `response.body.items`.\n\n[]",
      "schema": " `Optional` **schema**: `T`\n\nThe schema of the objects being returned."
    },
    "Methods": {
      "onError": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `error` | `Error` |",
        "Returns": "`any`\n\n[]\n\nnav: \"ScaleSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: ScaleSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Scale`](../enums/core.ValueHintType.md#scale)\\>",
      " **`ScaleSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "icon": " `Optional` **icon**: [`ScaleIconSet`](../enums/core.ScaleIconSet.md)\n\nThe icon to render.\n\n[]",
      "maximum": " `Optional` **maximum**: `number`\n\nThe number of icons to render.\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"SetEndpoint\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SetEndpoint": {
    "Properties": {
      "description": " **description**: `string`\n\nA description to render to the user describing the selection they should be making,\nfor example, \"Choose an instance to use with this account\".\n\n[]",
      "getOptions": " `Optional` **getOptions**: [`MetadataFormula`](../types/core.MetadataFormula.md)\n\nThe formula that fetches endpoints for the user\nto select from. Like any [MetadataFormula](../types/core.MetadataFormula.md), this formula should return\nan array of options, either strings or objects of the form\n`{display: '<display name>', value: '<endpoint>'}` if wanting to render a display\nlabel to the user rather than rendering the underlying value directly.\n\n[]",
      "getOptionsFormula": " `Optional` **getOptionsFormula**: [`MetadataFormula`](../types/core.MetadataFormula.md)\n\n**`Deprecated`**\n\nUse [getOptions](core.SetEndpoint.md#getoptions)\n\n[]",
      "name": " **name**: `string`\n\nAn arbitrary name for this step, to distinguish from other steps of the same type\n(exceedingly rare).\n\n[]",
      "type": " **type**: [`SetEndpoint`](../enums/core.PostSetupType.md#setendpoint)\n\nIdentifies this as a SetEndpoint step.\n\n[]\n\nnav: \"SimpleAutocompleteOption\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SimpleAutocompleteOption<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `AutocompleteParameterTypes` |",
    "Properties": {
      "display": " **display**: `string`\n\nText that will be displayed to the user in UI for this option.\n\n[]",
      "value": " **value**: `TypeMap`[`AutocompleteParameterTypeMapping`[`T`]]\n\nThe actual value that will get used in the formula if this option is selected.\n\n[]\n\nnav: \"SimpleStringSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SimpleStringSchema<T\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `T` | extends `SimpleStringHintTypes` = `SimpleStringHintTypes` |",
    "Hierarchy": [
      "`BaseStringSchema`<`T`\\>",
      " **`SimpleStringSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Inherited from": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"SliderSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SliderSchema": {
    "Hierarchy": [
      "`BaseNumberSchema`<[`Slider`](../enums/core.ValueHintType.md#slider)\\>",
      " **`SliderSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseNumberSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseNumberSchema.description\n\n[]"
      },
      "maximum": " `Optional` **maximum**: `string` \\| `number`\n\nThe maximum value selectable by this slider (supports number or formula).\n\n[]",
      "minimum": " `Optional` **minimum**: `string` \\| `number`\n\nThe minimum value selectable by this slider (supports number or formula).\n\n[]",
      "showValue": " `Optional` **showValue**: `boolean`\n\nWhether to display the underlying numeric value in addition to the slider.\n\n[]",
      "step": " `Optional` **step**: `string` \\| `number`\n\nThe minimum amount the slider can be moved when dragged (supports number or formula).\n\n[]",
      "type": {
        "Inherited from": "BaseNumberSchema.type\n\n[]\n\nnav: \"StatusCodeErrorResponse\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StatusCodeErrorResponse": {
    "Properties": {
      "body": " `Optional` **body**: `any`\n\nThe raw body of the HTTP error response.\n\n[]",
      "headers": {
        "Index signature": " [key: `string`]: `string` \\| `string`[] \\| `undefined`\n\n[]\n\nnav: \"StringDateSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StringDateSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Date`](../enums/core.ValueHintType.md#date)\\>",
      " **`StringDateSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "format": " `Optional` **format**: `string`\n\nA Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"StringDateTimeSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StringDateTimeSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`DateTime`](../enums/core.ValueHintType.md#datetime)\\>",
      " **`StringDateTimeSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "dateFormat": " `Optional` **dateFormat**: `string`\n\nA Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "timeFormat": " `Optional` **timeFormat**: `string`\n\nA Moment time format string, such as 'HH:mm:ss', that corresponds to a supported Coda time column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"StringEmbedSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StringEmbedSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Embed`](../enums/core.ValueHintType.md#embed)\\>",
      " **`StringEmbedSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "force": " `Optional` **force**: `boolean`\n\nToggle whether to try to force embed the content in Coda. Should be kept to false for most cases.\n\nBy default, we use an external provider (iframely) that supports and normalizes embeds for different sites.\nIf you are trying to embed an uncommon site or one that is not supported by them,\nyou can set this to `true` to tell Coda to force render the embed. This renders a sandboxed iframe for the embed\nbut requires user consent per-domain to actually display the embed.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"StringTimeSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StringTimeSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`Time`](../enums/core.ValueHintType.md#time)\\>",
      " **`StringTimeSchema`**"
    ],
    "Properties": {
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "format": " `Optional` **format**: `string`\n\nA Moment time format string, such as 'HH:mm:ss', that corresponds to a supported Coda time column format,\nused when rendering the value.\n\nOnly applies when this is used as a sync table property.\n\n[]",
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"StringWithOptionsSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: StringWithOptionsSchema": {
    "Hierarchy": [
      "`BaseStringSchema`<[`SelectList`](../enums/core.ValueHintType.md#selectlist)\\>",
      "`PropertyWithAutocompleteWithOptionalDisplay`<`string`\\>",
      " **`StringWithOptionsSchema`**"
    ],
    "Properties": {
      "allowNewValues": " `Optional` **allowNewValues**: `boolean`\n\nAllow custom, user-entered strings in addition to [options](core.PropertyWithOptions.md#options).\n\n[]",
      "codaType": {
        "Overrides": "BaseStringSchema.codaType\n\n[]"
      },
      "description": {
        "Inherited from": "BaseStringSchema.description\n\n[]"
      },
      "options": {
        "Inherited from": "PropertyWithAutocompleteWithOptionalDisplay.options\n\n[]"
      },
      "requireForUpdates": {
        "Inherited from": "PropertyWithAutocompleteWithOptionalDisplay.requireForUpdates\n\n[]"
      },
      "type": {
        "Inherited from": "BaseStringSchema.type\n\n[]\n\nnav: \"SyncBase\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SyncBase": {
    "Hierarchy": [
      "**`SyncBase`**",
      " [`SyncFull`](core.SyncFull.md)",
      " [`SyncIncremental`](core.SyncIncremental.md)",
      " [`UpdateSync`](core.UpdateSync.md)"
    ],
    "Properties": {
      "dynamicUrl": " `Optional` **dynamicUrl**: `string`\n\nThe dynamic URL that backs this sync table, if this is a dynamic sync table.\nThe dynamic URL is likely necessary for determining which API resources to fetch.\n\n[]",
      "parameters": " `Optional` `Readonly` **parameters**: [`MetadataContext`](../types/core.MetadataContext.md)\n\n[MetadataContext](../types/core.MetadataContext.md) The parameters of the sync formula for the sync table.\n\n[]",
      "schema": " `Optional` **schema**: [`ArraySchema`](core.ArraySchema.md)<[`Schema`](../types/core.Schema.md)\\>\n\nThe schema of this sync table, if this is a dynamic sync table. It may be useful to have\naccess to the dynamically-generated schema of the table instance in order to construct\nthe response for a dynamic sync table's `execute` function.\n\n[]\n\nnav: \"SyncExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SyncExecutionContext<SyncContinuationT, IncrementalCheckpointContinuationT, IncrementalSyncContinuationT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `SyncContinuationT` | [`Continuation`](core.Continuation.md) |\n| `IncrementalCheckpointContinuationT` | `SyncContinuationT` |\n| `IncrementalSyncContinuationT` | `SyncContinuationT` |",
    "Hierarchy": [
      "[`ExecutionContext`](core.ExecutionContext.md)",
      " **`SyncExecutionContext`**",
      " [`PropertyOptionsExecutionContext`](core.PropertyOptionsExecutionContext.md)"
    ],
    "Properties": {
      "endpoint": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[endpoint](core.ExecutionContext.md#endpoint)\n\n[]"
      },
      "fetcher": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[fetcher](core.ExecutionContext.md#fetcher)\n\n[]"
      },
      "invocationLocation": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationLocation](core.ExecutionContext.md#invocationlocation)\n\n[]"
      },
      "invocationToken": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationToken](core.ExecutionContext.md#invocationtoken)\n\n[]"
      },
      "sync": {
        "Overrides": "[ExecutionContext](core.ExecutionContext.md).[sync](core.ExecutionContext.md#sync)\n\n[]"
      },
      "temporaryBlobStorage": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[temporaryBlobStorage](core.ExecutionContext.md#temporaryblobstorage)\n\n[]"
      },
      "timezone": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[timezone](core.ExecutionContext.md#timezone)\n\n[]\n\nnav: \"SyncFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SyncFormulaDef<K, L, ParamDefsT, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`\\> |",
    "Hierarchy": [
      "[`CommonPackFormulaDef`](core.CommonPackFormulaDef.md)<`ParamDefsT`\\>",
      "`OnErrorFormulaOptions`",
      " **`SyncFormulaDef`**"
    ],
    "Properties": {
      "cacheTtlSecs": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[cacheTtlSecs](core.CommonPackFormulaDef.md#cachettlsecs)\n\n[]"
      },
      "connectionRequirement": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[connectionRequirement](core.CommonPackFormulaDef.md#connectionrequirement)\n\n[]"
      },
      "description": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[description](core.CommonPackFormulaDef.md#description)\n\n[]"
      },
      "examples": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[examples](core.CommonPackFormulaDef.md#examples)\n\n[]"
      },
      "extraOAuthScopes": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[extraOAuthScopes](core.CommonPackFormulaDef.md#extraoauthscopes)\n\n[]"
      },
      "isAction": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isAction](core.CommonPackFormulaDef.md#isaction)\n\n[]"
      },
      "isExperimental": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isExperimental](core.CommonPackFormulaDef.md#isexperimental)\n\n[]"
      },
      "isSystem": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[isSystem](core.CommonPackFormulaDef.md#issystem)\n\n[]"
      },
      "maxUpdateBatchSize": " `Optional` **maxUpdateBatchSize**: `number`\n\nIf the table supports object updates, the maximum number of objects that will be sent to the pack\nin a single batch. Defaults to 1 if not specified.\n\n[]",
      "name": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[name](core.CommonPackFormulaDef.md#name)\n\n[]"
      },
      "network": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[network](core.CommonPackFormulaDef.md#network)\n\n[]"
      },
      "parameters": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[parameters](core.CommonPackFormulaDef.md#parameters)\n\n[]"
      },
      "varargParameters": {
        "Inherited from": "[CommonPackFormulaDef](core.CommonPackFormulaDef.md).[varargParameters](core.CommonPackFormulaDef.md#varargparameters)"
      }
    },
    "Methods": {
      "execute": {
        "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ContextReturnT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`, `any`\\> |",
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `params` | [`ParamValues`](../types/core.ParamValues.md)<`ParamDefsT`\\> |\n| `context` | `ContextT` |",
        "Returns": "`Promise`<[`SyncFormulaResult`](core.SyncFormulaResult.md)<`K`, `L`, `SchemaT`, `ContextReturnT`\\>\\>\n\n[]"
      },
      "executeUpdate": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `params` | [`ParamValues`](../types/core.ParamValues.md)<`ParamDefsT`\\> |\n| `updates` | [`SyncUpdate`](core.SyncUpdate.md)<`K`, `L`, `SchemaT`\\>[] |\n| `context` | [`UpdateSyncExecutionContext`](core.UpdateSyncExecutionContext.md) |",
        "Returns": "`Promise`<[`SyncUpdateResult`](core.SyncUpdateResult.md)<`K`, `L`, `SchemaT`\\>\\>\n\n[]"
      },
      "onError": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `error` | `Error` |",
        "Returns": "`any`",
        "Inherited from": "OnErrorFormulaOptions.onError\n\n[]\n\nnav: \"SyncFormulaResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SyncFormulaResult<K, L, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`\\> = [`SyncExecutionContext`](core.SyncExecutionContext.md) |",
    "Properties": {
      "continuation": " `Optional` **continuation**: `ContextT`[``\"sync\"``][``\"continuation\"``]\n\nA marker indicating where the next sync formula invocation should pick up to get the next page of results.\nThe contents of this object are entirely of your choosing. Sync formulas are called repeatedly\nuntil there is no continuation returned.\n\n[]",
      "result": " **result**: `ObjectSchemaDefinitionType`<`K`, `L`, `SchemaT`\\>[]\n\nThe list of rows from this page.\n\n[]\n\nnav: \"SyncFull\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SyncFull<ContinuationT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `ContinuationT` | [`Continuation`](core.Continuation.md) |",
    "Hierarchy": [
      "[`SyncBase`](core.SyncBase.md)",
      " **`SyncFull`**"
    ],
    "Properties": {
      "continuation": " `Optional` **continuation**: `ContinuationT`\n\nThe continuation that was returned from the prior sync invocation. The is the exact\nvalue returned in the `continuation` property of result of the prior sync.\n\n[]",
      "dynamicUrl": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[dynamicUrl](core.SyncBase.md#dynamicurl)\n\n[]"
      },
      "parameters": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[parameters](core.SyncBase.md#parameters)\n\n[]"
      },
      "schema": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[schema](core.SyncBase.md#schema)\n\n[]\n\nnav: \"SyncIncremental\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SyncIncremental<SyncContinuationT, CheckpointContinuationT\\>": {
    "Type parameters": "| Name |\n| :------ |\n| `SyncContinuationT` |\n| `CheckpointContinuationT` |",
    "Hierarchy": [
      "[`SyncBase`](core.SyncBase.md)",
      " **`SyncIncremental`**"
    ],
    "Properties": {
      "continuation": " `Optional` **continuation**: `SyncContinuationT`\n\nThe continuation that was returned from the prior sync invocation. The is the exact\nvalue returned in the `continuation` property of result of the prior sync.\n\n[]",
      "dynamicUrl": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[dynamicUrl](core.SyncBase.md#dynamicurl)\n\n[]"
      },
      "parameters": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[parameters](core.SyncBase.md#parameters)\n\n[]"
      },
      "schema": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[schema](core.SyncBase.md#schema)\n\n[]\n\nnav: \"SyncTableDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: SyncTableDef<K, L, ParamDefsT, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends `ObjectSchema`<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`\\> |",
    "Hierarchy": [
      "**`SyncTableDef`**",
      " [`DynamicSyncTableDef`](core.DynamicSyncTableDef.md)"
    ],
    "Properties": {
      "defaultAddDynamicColumns": " `Optional` **defaultAddDynamicColumns**: `boolean`\n\nSee [defaultAddDynamicColumns](core.DynamicOptions.md#defaultadddynamiccolumns)\n\n[]",
      "description": " `Optional` **description**: `string`\n\nSee [description](core.SyncTableOptions.md#description)\n\n[]",
      "entityName": " `Optional` **entityName**: `string`\n\nSee [entityName](core.DynamicOptions.md#entityname)\n\n[]",
      "getSchema": " `Optional` **getSchema**: [`MetadataFormula`](../types/core.MetadataFormula.md)<[`ExecutionContext`](core.ExecutionContext.md)\\>\n\nSee [getSchema](core.DynamicOptions.md#getschema)\n\n[]",
      "getter": " **getter**: [`SyncFormula`](../types/core.SyncFormula.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>\n\nSee [formula](core.SyncTableOptions.md#formula)\n\n[]",
      "identityName": " **identityName**: `string`\n\nThe `identityName` is persisted for all sync tables so that a dynamic schema\ncan be annotated with an identity automatically.\n\nSee [identityName](core.SyncTableOptions.md#identityname) for more details.\n\n[]",
      "name": " **name**: `string`\n\nSee [name](core.SyncTableOptions.md#name)\n\n[]",
      "schema": " **schema**: `SchemaT`\n\nSee [schema](core.SyncTableOptions.md#schema)\n\n[]\n\nnav: \"SyncTableOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SyncTableOptions<K, L, ParamDefsT, SchemaT, ContextT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](../types/core.ParamDefs.md) |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](core.SyncExecutionContext.md)<`any`, `any`\\> |",
    "Properties": {
      "connectionRequirement": " `Optional` **connectionRequirement**: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md)\n\nA [ConnectionRequirement](../enums/core.ConnectionRequirement.md) that will be used for all formulas contained within\nthis sync table (including autocomplete formulas).\n\n[]",
      "description": " `Optional` **description**: `string`\n\nThe description of the sync table. This is shown to users in the Coda UI.\nThis should describe what the sync table does in more detailed language. For example, the\ndescription for a 'Products' sync table could be: 'Returns products from the e-commerce platform.'\n\n[]",
      "dynamicOptions": " `Optional` **dynamicOptions**: [`DynamicOptions`](core.DynamicOptions.md)\n\nA set of options used internally by [makeDynamicSyncTable](../functions/core.makeDynamicSyncTable.md), or for static\nsync tables that have a dynamic schema.\n\n[]",
      "formula": " **formula**: [`SyncFormulaDef`](core.SyncFormulaDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>\n\nThe definition of the formula that implements this sync. This is a Coda packs formula\nthat returns an array of objects fitting the given schema and optionally a [Continuation](core.Continuation.md).\n(The [name](core.SyncFormulaDef.md#name) is redundant and should be the same as the `name` parameter here.\nThese will eventually be consolidated.)\n\n[]",
      "identityName": " **identityName**: `string`\n\nThe \"unique identifier\" for the entity being synced. This will serve as the unique id for this\ntable, and must be unique across other sync tables for your pack. This is often the singular\nform of the table name, e.g. if your table name was 'Products' you might choose 'Product'\nas the identity name.\n\nWhen returning objects from other syncs or formulas, you may create Coda references to objects\nin this table by defining an [Identity](core.Identity.md) in that schema that refers to this identity name.\n\nFor example, if your identity name was 'Product', another formula or sync could return\nshell objects that reference rows in this table, so long as they contain the id\nof the object, and the schema is declared as `{identity: {name: 'Products'}}`.\n\n[]",
      "name": " **name**: `string`\n\nThe name of the sync table. This is shown to users in the Coda UI.\nThis should describe the entities being synced. For example, a sync table that syncs products\nfrom an e-commerce platform should be called 'Products'. This name must not contain spaces.\n\n[]",
      "schema": " **schema**: `SchemaT`\n\nThe definition of the schema that describes a single response object. For example, the\nschema for a single product. The sync formula will return an array of objects that fit this schema.\n\n[]\n\nnav: \"SyncUpdate\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SyncUpdate<K, L, SchemaT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |",
    "Properties": {
      "newValue": " **newValue**: `ObjectSchemaDefinitionType`<`K`, `L`, `SchemaT`\\>\n\nThe new value of the row, with the user edits applied.\n\n[]",
      "previousValue": " **previousValue**: `ObjectSchemaDefinitionType`<`K`, `L`, `SchemaT`\\>\n\nThe previous value of the row.\n\n[]",
      "updatedFields": " **updatedFields**: `string`[]\n\nThe fields of the row that have been updated.\n\n[]\n\nnav: \"SyncUpdateResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: SyncUpdateResult<K, L, SchemaT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](core.ObjectSchemaDefinition.md)<`K`, `L`\\> |",
    "Properties": {
      "result": " **result**: [`SyncUpdateSingleResult`](../types/core.SyncUpdateSingleResult.md)<`K`, `L`, `SchemaT`\\>[]\n\nThe individual update results. Every incoming update should have a corresponding result, in the same order.\n\n[]\n\nnav: \"TemporaryBlobStorage\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: TemporaryBlobStorage": {
    "Methods": {
      "storeBlob": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `blobData` | `Buffer` |\n| `contentType` | `string` |\n| `opts?` | `Object` |\n| `opts.downloadFilename?` | `string` |\n| `opts.expiryMs?` | `number` |",
        "Returns": "`Promise`<`string`\\>\n\n[]"
      },
      "storeUrl": {
        "Parameters": "| Name | Type |\n| :------ | :------ |\n| `url` | `string` |\n| `opts?` | `Object` |\n| `opts.contentType?` | `string` |\n| `opts.downloadFilename?` | `string` |\n| `opts.expiryMs?` | `number` |\n| `fetchOpts?` | `Pick`<[`FetchRequest`](core.FetchRequest.md), ``\"headers\"`` \\| ``\"cacheTtlSecs\"`` \\| ``\"disableAuthentication\"``\\> |",
        "Returns": "`Promise`<`string`\\>\n\n[]\n\nnav: \"TextAttributionNode\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: TextAttributionNode": {
    "Properties": {
      "text": " **text**: `string`\n\nThe text to render with the pack value.\n\n[]",
      "type": " **type**: [`Text`](../enums/core.AttributionNodeType.md#text)\n\nIdentifies this as a text attribution node.\n\n[]\n\nnav: \"UpdateSync\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: UpdateSync": {
    "Hierarchy": [
      "[`SyncBase`](core.SyncBase.md)",
      " **`UpdateSync`**"
    ],
    "Properties": {
      "dynamicUrl": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[dynamicUrl](core.SyncBase.md#dynamicurl)\n\n[]"
      },
      "parameters": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[parameters](core.SyncBase.md#parameters)\n\n[]"
      },
      "schema": {
        "Inherited from": "[SyncBase](core.SyncBase.md).[schema](core.SyncBase.md#schema)\n\n[]\n\nnav: \"UpdateSyncExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: UpdateSyncExecutionContext": {
    "Hierarchy": [
      "[`ExecutionContext`](core.ExecutionContext.md)",
      " **`UpdateSyncExecutionContext`**"
    ],
    "Properties": {
      "endpoint": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[endpoint](core.ExecutionContext.md#endpoint)\n\n[]"
      },
      "fetcher": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[fetcher](core.ExecutionContext.md#fetcher)\n\n[]"
      },
      "invocationLocation": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationLocation](core.ExecutionContext.md#invocationlocation)\n\n[]"
      },
      "invocationToken": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationToken](core.ExecutionContext.md#invocationtoken)\n\n[]"
      },
      "sync": {
        "Overrides": "[ExecutionContext](core.ExecutionContext.md).[sync](core.ExecutionContext.md#sync)\n\n[]"
      },
      "temporaryBlobStorage": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[temporaryBlobStorage](core.ExecutionContext.md#temporaryblobstorage)\n\n[]"
      },
      "timezone": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[timezone](core.ExecutionContext.md#timezone)\n\n[]\n\nnav: \"WebBasicAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: WebBasicAuthentication": {
    "Hierarchy": [
      "[`BaseAuthentication`](core.BaseAuthentication.md)",
      " **`WebBasicAuthentication`**"
    ],
    "Properties": {
      "endpointDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[endpointDomain](core.BaseAuthentication.md#endpointdomain)\n\n[]"
      },
      "getConnectionName": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[getConnectionName](core.BaseAuthentication.md#getconnectionname)\n\n[]"
      },
      "instructionsUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[instructionsUrl](core.BaseAuthentication.md#instructionsurl)\n\n[]"
      },
      "networkDomain": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[networkDomain](core.BaseAuthentication.md#networkdomain)\n\n[]"
      },
      "postSetup": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[postSetup](core.BaseAuthentication.md#postsetup)\n\n[]"
      },
      "requiresEndpointUrl": {
        "Inherited from": "[BaseAuthentication](core.BaseAuthentication.md).[requiresEndpointUrl](core.BaseAuthentication.md#requiresendpointurl)\n\n[]"
      },
      "type": " **type**: [`WebBasic`](../enums/core.AuthenticationType.md#webbasic)\n\nIdentifies this as WebBasic authentication.\n\n[]",
      "uxConfig": {
        "Type declaration": "| Name | Type | Description |\n| :------ | :------ | :------ |\n| `placeholderPassword?` | `string` | A placeholder value for the text input where the user will enter a password. |\n| `placeholderUsername?` | `string` | A placeholder value for the text input where the user will enter a username. |\n| `usernameOnly?` | `boolean` | If true, only a username input will be shown to the user. Some services pass API keys in the username field and do not require a password. |\n\n[]\n\nnav: \"ContextOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: ContextOptions": {
    "Properties": {
      "manifestPath": " `Optional` **manifestPath**: `string`\n\n[]",
      "useRealFetcher": " `Optional` **useRealFetcher**: `boolean`\n\n[]\n\nnav: \"ExecuteOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: ExecuteOptions": {
    "Properties": {
      "useDeprecatedResultNormalization": " `Optional` **useDeprecatedResultNormalization**: `boolean`\n\n[]",
      "validateParams": " `Optional` **validateParams**: `boolean`\n\n[]",
      "validateResult": " `Optional` **validateResult**: `boolean`\n\n[]\n\nnav: \"MockExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
    }
  },
  "Interface: MockExecutionContext": {
    "Hierarchy": [
      "[`ExecutionContext`](core.ExecutionContext.md)",
      " **`MockExecutionContext`**",
      " [`MockSyncExecutionContext`](testing.MockSyncExecutionContext.md)"
    ],
    "Properties": {
      "endpoint": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[endpoint](core.ExecutionContext.md#endpoint)\n\n[]"
      },
      "fetcher": {
        "Type declaration": "| Name | Type |\n| :------ | :------ |\n| `fetch` | `SinonStub`<[request: FetchRequest], `Promise`<[`FetchResponse`](core.FetchResponse.md)<`any`\\>\\>\\> |",
        "Overrides": "[ExecutionContext](core.ExecutionContext.md).[fetcher](core.ExecutionContext.md#fetcher)\n\n[]"
      },
      "invocationLocation": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationLocation](core.ExecutionContext.md#invocationlocation)\n\n[]"
      },
      "invocationToken": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[invocationToken](core.ExecutionContext.md#invocationtoken)\n\n[]"
      },
      "sync": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[sync](core.ExecutionContext.md#sync)\n\n[]"
      },
      "temporaryBlobStorage": {
        "Type declaration": "| Name | Type |\n| :------ | :------ |\n| `storeBlob` | `SinonStub`<[blobData: Buffer, contentType: string, opts?: Object], `Promise`<`string`\\>\\> |\n| `storeUrl` | `SinonStub`<[url: string, opts?: Object, fetchOpts?: Pick<FetchRequest, \"headers\" \\| \"cacheTtlSecs\" \\| \"disableAuthentication\"\\>], `Promise`<`string`\\>\\> |",
        "Overrides": "[ExecutionContext](core.ExecutionContext.md).[temporaryBlobStorage](core.ExecutionContext.md#temporaryblobstorage)\n\n[]"
      },
      "timezone": {
        "Inherited from": "[ExecutionContext](core.ExecutionContext.md).[timezone](core.ExecutionContext.md#timezone)\n\n[]\n\nnav: \"MockSyncExecutionContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Interface: MockSyncExecutionContext<SyncContinuationT, IncrementalCheckpointContinuationT, IncrementalSyncContinuationT\\>": {
    "Type parameters": "| Name | Type |\n| :------ | :------ |\n| `SyncContinuationT` | [`Continuation`](core.Continuation.md) |\n| `IncrementalCheckpointContinuationT` | `SyncContinuationT` |\n| `IncrementalSyncContinuationT` | `SyncContinuationT` |",
    "Hierarchy": [
      "[`MockExecutionContext`](testing.MockExecutionContext.md)",
      " **`MockSyncExecutionContext`**"
    ],
    "Properties": {
      "endpoint": {
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[endpoint](testing.MockExecutionContext.md#endpoint)\n\n[]"
      },
      "fetcher": {
        "Type declaration": "| Name | Type |\n| :------ | :------ |\n| `fetch` | `SinonStub`<[request: FetchRequest], `Promise`<[`FetchResponse`](core.FetchResponse.md)<`any`\\>\\>\\> |",
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[fetcher](testing.MockExecutionContext.md#fetcher)\n\n[]"
      },
      "invocationLocation": {
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[invocationLocation](testing.MockExecutionContext.md#invocationlocation)\n\n[]"
      },
      "invocationToken": {
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[invocationToken](testing.MockExecutionContext.md#invocationtoken)\n\n[]"
      },
      "sync": {
        "Overrides": "[MockExecutionContext](testing.MockExecutionContext.md).[sync](testing.MockExecutionContext.md#sync)\n\n[]"
      },
      "syncStateService": {
        "Type declaration": "| Name | Type |\n| :------ | :------ |\n| `getLatestRowVersions` | `SinonStub`<[rowIds: string[]], `Promise`<{ `[rowId: string]`: `string`;  }\\>\\> |\n\n[]"
      },
      "temporaryBlobStorage": {
        "Type declaration": "| Name | Type |\n| :------ | :------ |\n| `storeBlob` | `SinonStub`<[blobData: Buffer, contentType: string, opts?: Object], `Promise`<`string`\\>\\> |\n| `storeUrl` | `SinonStub`<[url: string, opts?: Object, fetchOpts?: Pick<FetchRequest, \"headers\" \\| \"cacheTtlSecs\" \\| \"disableAuthentication\"\\>], `Promise`<`string`\\>\\> |",
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[temporaryBlobStorage](testing.MockExecutionContext.md#temporaryblobstorage)\n\n[]"
      },
      "timezone": {
        "Inherited from": "[MockExecutionContext](testing.MockExecutionContext.md).[timezone](testing.MockExecutionContext.md#timezone)\n\n[]\n\nnav: \"Modules\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]"
      }
    }
  },
  "Modules": {
    "Modules": [
      "[core](modules/core.md)",
      "[testing](modules/testing.md)"
    ]
  },
  "Namespace: SvgConstants": {
    "Variables": [
      "[DarkModeFragmentId](../variables/core.SvgConstants.DarkModeFragmentId.md)",
      "[DataUrlPrefix](../variables/core.SvgConstants.DataUrlPrefix.md)",
      "[DataUrlPrefixWithDarkModeSupport](../variables/core.SvgConstants.DataUrlPrefixWithDarkModeSupport.md)"
    ]
  },
  "Module: core": {
    "Namespaces": [
      "[SvgConstants](core.SvgConstants.md)"
    ],
    "Enumerations": [
      "[AttributionNodeType](../enums/core.AttributionNodeType.md)",
      "[AuthenticationType](../enums/core.AuthenticationType.md)",
      "[ConnectionRequirement](../enums/core.ConnectionRequirement.md)",
      "[CurrencyFormat](../enums/core.CurrencyFormat.md)",
      "[DurationUnit](../enums/core.DurationUnit.md)",
      "[EmailDisplayType](../enums/core.EmailDisplayType.md)",
      "[ImageCornerStyle](../enums/core.ImageCornerStyle.md)",
      "[ImageOutline](../enums/core.ImageOutline.md)",
      "[ImageShapeStyle](../enums/core.ImageShapeStyle.md)",
      "[LinkDisplayType](../enums/core.LinkDisplayType.md)",
      "[NetworkConnection](../enums/core.NetworkConnection.md)",
      "[OptionsType](../enums/core.OptionsType.md)",
      "[ParameterType](../enums/core.ParameterType.md)",
      "[PostSetupType](../enums/core.PostSetupType.md)",
      "[PrecannedDateRange](../enums/core.PrecannedDateRange.md)",
      "[ScaleIconSet](../enums/core.ScaleIconSet.md)",
      "[TokenExchangeCredentialsLocation](../enums/core.TokenExchangeCredentialsLocation.md)",
      "[Type](../enums/core.Type.md)",
      "[ValueHintType](../enums/core.ValueHintType.md)",
      "[ValueType](../enums/core.ValueType.md)"
    ],
    "Classes": [
      "[MissingScopesError](../classes/core.MissingScopesError.md)",
      "[PackDefinitionBuilder](../classes/core.PackDefinitionBuilder.md)",
      "[StatusCodeError](../classes/core.StatusCodeError.md)",
      "[UserVisibleError](../classes/core.UserVisibleError.md)"
    ],
    "Interfaces": [
      "[AWSAccessKeyAuthentication](../interfaces/core.AWSAccessKeyAuthentication.md)",
      "[AWSAssumeRoleAuthentication](../interfaces/core.AWSAssumeRoleAuthentication.md)",
      "[ArraySchema](../interfaces/core.ArraySchema.md)",
      "[ArrayType](../interfaces/core.ArrayType.md)",
      "[BaseAuthentication](../interfaces/core.BaseAuthentication.md)",
      "[BaseFormulaDef](../interfaces/core.BaseFormulaDef.md)",
      "[BooleanSchema](../interfaces/core.BooleanSchema.md)",
      "[CodaApiBearerTokenAuthentication](../interfaces/core.CodaApiBearerTokenAuthentication.md)",
      "[CommonPackFormulaDef](../interfaces/core.CommonPackFormulaDef.md)",
      "[Continuation](../interfaces/core.Continuation.md)",
      "[CurrencySchema](../interfaces/core.CurrencySchema.md)",
      "[CustomAuthParameter](../interfaces/core.CustomAuthParameter.md)",
      "[CustomAuthentication](../interfaces/core.CustomAuthentication.md)",
      "[CustomHeaderTokenAuthentication](../interfaces/core.CustomHeaderTokenAuthentication.md)",
      "[DurationSchema](../interfaces/core.DurationSchema.md)",
      "[DynamicOptions](../interfaces/core.DynamicOptions.md)",
      "[DynamicSyncTableDef](../interfaces/core.DynamicSyncTableDef.md)",
      "[DynamicSyncTableOptions](../interfaces/core.DynamicSyncTableOptions.md)",
      "[EmailSchema](../interfaces/core.EmailSchema.md)",
      "[EmptyFormulaDef](../interfaces/core.EmptyFormulaDef.md)",
      "[ExecutionContext](../interfaces/core.ExecutionContext.md)",
      "[FetchRequest](../interfaces/core.FetchRequest.md)",
      "[FetchResponse](../interfaces/core.FetchResponse.md)",
      "[Fetcher](../interfaces/core.Fetcher.md)",
      "[Format](../interfaces/core.Format.md)",
      "[HeaderBearerTokenAuthentication](../interfaces/core.HeaderBearerTokenAuthentication.md)",
      "[Identity](../interfaces/core.Identity.md)",
      "[IdentityDefinition](../interfaces/core.IdentityDefinition.md)",
      "[ImageAttributionNode](../interfaces/core.ImageAttributionNode.md)",
      "[ImageSchema](../interfaces/core.ImageSchema.md)",
      "[InvocationLocation](../interfaces/core.InvocationLocation.md)",
      "[LinkAttributionNode](../interfaces/core.LinkAttributionNode.md)",
      "[LinkSchema](../interfaces/core.LinkSchema.md)",
      "[MetadataFormulaObjectResultType](../interfaces/core.MetadataFormulaObjectResultType.md)",
      "[MultiHeaderTokenAuthentication](../interfaces/core.MultiHeaderTokenAuthentication.md)",
      "[MultiQueryParamTokenAuthentication](../interfaces/core.MultiQueryParamTokenAuthentication.md)",
      "[Network](../interfaces/core.Network.md)",
      "[NoAuthentication](../interfaces/core.NoAuthentication.md)",
      "[NumericDateSchema](../interfaces/core.NumericDateSchema.md)",
      "[NumericDateTimeSchema](../interfaces/core.NumericDateTimeSchema.md)",
      "[NumericDurationSchema](../interfaces/core.NumericDurationSchema.md)",
      "[NumericSchema](../interfaces/core.NumericSchema.md)",
      "[NumericTimeSchema](../interfaces/core.NumericTimeSchema.md)",
      "[OAuth2Authentication](../interfaces/core.OAuth2Authentication.md)",
      "[OAuth2ClientCredentialsAuthentication](../interfaces/core.OAuth2ClientCredentialsAuthentication.md)",
      "[ObjectArrayFormulaDef](../interfaces/core.ObjectArrayFormulaDef.md)",
      "[ObjectSchemaDefinition](../interfaces/core.ObjectSchemaDefinition.md)",
      "[ObjectSchemaProperty](../interfaces/core.ObjectSchemaProperty.md)",
      "[OptionalParamDef](../interfaces/core.OptionalParamDef.md)",
      "[PackDefinition](../interfaces/core.PackDefinition.md)",
      "[PackFormulaDef](../interfaces/core.PackFormulaDef.md)",
      "[PackVersionDefinition](../interfaces/core.PackVersionDefinition.md)",
      "[ParamDef](../interfaces/core.ParamDef.md)",
      "[ProgressBarSchema](../interfaces/core.ProgressBarSchema.md)",
      "[PropertyIdentifierDetails](../interfaces/core.PropertyIdentifierDetails.md)",
      "[PropertyOptionsExecutionContext](../interfaces/core.PropertyOptionsExecutionContext.md)",
      "[PropertyWithOptions](../interfaces/core.PropertyWithOptions.md)",
      "[QueryParamTokenAuthentication](../interfaces/core.QueryParamTokenAuthentication.md)",
      "[RequestHandlerTemplate](../interfaces/core.RequestHandlerTemplate.md)",
      "[RequiredParamDef](../interfaces/core.RequiredParamDef.md)",
      "[ResponseHandlerTemplate](../interfaces/core.ResponseHandlerTemplate.md)",
      "[ScaleSchema](../interfaces/core.ScaleSchema.md)",
      "[SetEndpoint](../interfaces/core.SetEndpoint.md)",
      "[SimpleAutocompleteOption](../interfaces/core.SimpleAutocompleteOption.md)",
      "[SimpleStringSchema](../interfaces/core.SimpleStringSchema.md)",
      "[SliderSchema](../interfaces/core.SliderSchema.md)",
      "[StatusCodeErrorResponse](../interfaces/core.StatusCodeErrorResponse.md)",
      "[StringDateSchema](../interfaces/core.StringDateSchema.md)",
      "[StringDateTimeSchema](../interfaces/core.StringDateTimeSchema.md)",
      "[StringEmbedSchema](../interfaces/core.StringEmbedSchema.md)",
      "[StringTimeSchema](../interfaces/core.StringTimeSchema.md)",
      "[StringWithOptionsSchema](../interfaces/core.StringWithOptionsSchema.md)",
      "[SyncBase](../interfaces/core.SyncBase.md)",
      "[SyncExecutionContext](../interfaces/core.SyncExecutionContext.md)",
      "[SyncFormulaDef](../interfaces/core.SyncFormulaDef.md)",
      "[SyncFormulaResult](../interfaces/core.SyncFormulaResult.md)",
      "[SyncFull](../interfaces/core.SyncFull.md)",
      "[SyncIncremental](../interfaces/core.SyncIncremental.md)",
      "[SyncTableDef](../interfaces/core.SyncTableDef.md)",
      "[SyncTableOptions](../interfaces/core.SyncTableOptions.md)",
      "[SyncUpdate](../interfaces/core.SyncUpdate.md)",
      "[SyncUpdateResult](../interfaces/core.SyncUpdateResult.md)",
      "[TemporaryBlobStorage](../interfaces/core.TemporaryBlobStorage.md)",
      "[TextAttributionNode](../interfaces/core.TextAttributionNode.md)",
      "[UpdateSync](../interfaces/core.UpdateSync.md)",
      "[UpdateSyncExecutionContext](../interfaces/core.UpdateSyncExecutionContext.md)",
      "[WebBasicAuthentication](../interfaces/core.WebBasicAuthentication.md)"
    ],
    "Type Aliases": [
      "[ArrayFormulaDef](../types/core.ArrayFormulaDef.md)",
      "[AttributionNode](../types/core.AttributionNode.md)",
      "[Authentication](../types/core.Authentication.md)",
      "[AuthenticationDef](../types/core.AuthenticationDef.md)",
      "[BaseFormula](../types/core.BaseFormula.md)",
      "[BasicPackDefinition](../types/core.BasicPackDefinition.md)",
      "[BooleanFormulaDef](../types/core.BooleanFormulaDef.md)",
      "[BooleanHintTypes](../types/core.BooleanHintTypes.md)",
      "[BooleanPackFormula](../types/core.BooleanPackFormula.md)",
      "[FetchMethodType](../types/core.FetchMethodType.md)",
      "[Formula](../types/core.Formula.md)",
      "[FormulaDefinition](../types/core.FormulaDefinition.md)",
      "[GenericDynamicSyncTable](../types/core.GenericDynamicSyncTable.md)",
      "[GenericSyncFormula](../types/core.GenericSyncFormula.md)",
      "[GenericSyncFormulaResult](../types/core.GenericSyncFormulaResult.md)",
      "[GenericSyncTable](../types/core.GenericSyncTable.md)",
      "[GenericSyncUpdate](../types/core.GenericSyncUpdate.md)",
      "[GenericSyncUpdateSingleResult](../types/core.GenericSyncUpdateSingleResult.md)",
      "[InferrableTypes](../types/core.InferrableTypes.md)",
      "[MetadataContext](../types/core.MetadataContext.md)",
      "[MetadataFormula](../types/core.MetadataFormula.md)",
      "[MetadataFormulaDef](../types/core.MetadataFormulaDef.md)",
      "[MetadataFormulaResultType](../types/core.MetadataFormulaResultType.md)",
      "[MetadataFunction](../types/core.MetadataFunction.md)",
      "[NumberHintTypes](../types/core.NumberHintTypes.md)",
      "[NumberSchema](../types/core.NumberSchema.md)",
      "[NumericFormulaDef](../types/core.NumericFormulaDef.md)",
      "[NumericPackFormula](../types/core.NumericPackFormula.md)",
      "[ObjectFormulaDef](../types/core.ObjectFormulaDef.md)",
      "[ObjectHintTypes](../types/core.ObjectHintTypes.md)",
      "[ObjectPackFormula](../types/core.ObjectPackFormula.md)",
      "[ObjectSchemaProperties](../types/core.ObjectSchemaProperties.md)",
      "[PackFormulaResult](../types/core.PackFormulaResult.md)",
      "[PackFormulaValue](../types/core.PackFormulaValue.md)",
      "[PackId](../types/core.PackId.md)",
      "[ParamDefFromOptionsUnion](../types/core.ParamDefFromOptionsUnion.md)",
      "[ParamDefs](../types/core.ParamDefs.md)",
      "[ParamValues](../types/core.ParamValues.md)",
      "[ParameterOptions](../types/core.ParameterOptions.md)",
      "[PostSetup](../types/core.PostSetup.md)",
      "[PostSetupDef](../types/core.PostSetupDef.md)",
      "[PropertyIdentifier](../types/core.PropertyIdentifier.md)",
      "[PropertyOptionsMetadataFunction](../types/core.PropertyOptionsMetadataFunction.md)",
      "[PropertyOptionsMetadataResult](../types/core.PropertyOptionsMetadataResult.md)",
      "[PropertySchemaOptions](../types/core.PropertySchemaOptions.md)",
      "[Schema](../types/core.Schema.md)",
      "[SchemaType](../types/core.SchemaType.md)",
      "[SetEndpointDef](../types/core.SetEndpointDef.md)",
      "[StringFormulaDef](../types/core.StringFormulaDef.md)",
      "[StringHintTypes](../types/core.StringHintTypes.md)",
      "[StringPackFormula](../types/core.StringPackFormula.md)",
      "[StringSchema](../types/core.StringSchema.md)",
      "[SuggestedValueType](../types/core.SuggestedValueType.md)",
      "[Sync](../types/core.Sync.md)",
      "[SyncFormula](../types/core.SyncFormula.md)",
      "[SyncTable](../types/core.SyncTable.md)",
      "[SyncUpdateSingleResult](../types/core.SyncUpdateSingleResult.md)",
      "[SystemAuthentication](../types/core.SystemAuthentication.md)",
      "[SystemAuthenticationDef](../types/core.SystemAuthenticationDef.md)",
      "[TypedPackFormula](../types/core.TypedPackFormula.md)",
      "[UserAuthenticationDef](../types/core.UserAuthenticationDef.md)"
    ],
    "Variables": [
      "[PropertyLabelValueTemplate](../variables/core.PropertyLabelValueTemplate.md)",
      "[ValidFetchMethods](../variables/core.ValidFetchMethods.md)"
    ],
    "Functions": [
      "[assertCondition](../functions/core.assertCondition.md)",
      "[autocompleteSearchObjects](../functions/core.autocompleteSearchObjects.md)",
      "[ensureExists](../functions/core.ensureExists.md)",
      "[ensureNonEmptyString](../functions/core.ensureNonEmptyString.md)",
      "[ensureUnreachable](../functions/core.ensureUnreachable.md)",
      "[generateSchema](../functions/core.generateSchema.md)",
      "[getEffectivePropertyKeysFromSchema](../functions/core.getEffectivePropertyKeysFromSchema.md)",
      "[getQueryParams](../functions/core.getQueryParams.md)",
      "[joinUrl](../functions/core.joinUrl.md)",
      "[makeAttributionNode](../functions/core.makeAttributionNode.md)",
      "[makeDynamicSyncTable](../functions/core.makeDynamicSyncTable.md)",
      "[makeEmptyFormula](../functions/core.makeEmptyFormula.md)",
      "[makeFormula](../functions/core.makeFormula.md)",
      "[makeMetadataFormula](../functions/core.makeMetadataFormula.md)",
      "[makeObjectSchema](../functions/core.makeObjectSchema.md)",
      "[makeParameter](../functions/core.makeParameter.md)",
      "[makeReferenceSchemaFromObjectSchema](../functions/core.makeReferenceSchemaFromObjectSchema.md)",
      "[makeSchema](../functions/core.makeSchema.md)",
      "[makeSimpleAutocompleteMetadataFormula](../functions/core.makeSimpleAutocompleteMetadataFormula.md)",
      "[makeSyncTable](../functions/core.makeSyncTable.md)",
      "[makeTranslateObjectFormula](../functions/core.makeTranslateObjectFormula.md)",
      "[newPack](../functions/core.newPack.md)",
      "[simpleAutocomplete](../functions/core.simpleAutocomplete.md)",
      "[withIdentity](../functions/core.withIdentity.md)",
      "[withQueryParams](../functions/core.withQueryParams.md)"
    ]
  },
  "Module: testing": {
    "Interfaces": [
      "[ContextOptions](../interfaces/testing.ContextOptions.md)",
      "[ExecuteOptions](../interfaces/testing.ExecuteOptions.md)",
      "[MockExecutionContext](../interfaces/testing.MockExecutionContext.md)",
      "[MockSyncExecutionContext](../interfaces/testing.MockSyncExecutionContext.md)"
    ],
    "Type Aliases": [
      "[SyncExecutionContextAsMock](../types/testing.SyncExecutionContextAsMock.md)"
    ],
    "Functions": [
      "[executeFormulaFromPackDef](../functions/testing.executeFormulaFromPackDef.md)",
      "[executeFormulaOrSyncWithVM](../functions/testing.executeFormulaOrSyncWithVM.md)",
      "[executeMetadataFormula](../functions/testing.executeMetadataFormula.md)",
      "[executeSyncFormula](../functions/testing.executeSyncFormula.md)",
      "[executeSyncFormulaFromPackDef](../functions/testing.executeSyncFormulaFromPackDef.md)",
      "[executeSyncFormulaFromPackDefSingleIteration](../functions/testing.executeSyncFormulaFromPackDefSingleIteration.md)",
      "[newJsonFetchResponse](../functions/testing.newJsonFetchResponse.md)",
      "[newMockExecutionContext](../functions/testing.newMockExecutionContext.md)",
      "[newMockSyncExecutionContext](../functions/testing.newMockSyncExecutionContext.md)",
      "[newRealFetcherExecutionContext](../functions/testing.newRealFetcherExecutionContext.md)",
      "[newRealFetcherSyncExecutionContext](../functions/testing.newRealFetcherSyncExecutionContext.md)"
    ]
  },
  "Type alias: ArrayFormulaDef<ParamDefsT, SchemaT\\>": "[core](../modules/core.md).ArrayFormulaDef\n\n **ArrayFormulaDef**<`ParamDefsT`, `SchemaT`\\>: [`BaseFormulaDef`](../interfaces/core.BaseFormulaDef.md)<`ParamDefsT`, [`SchemaType`](core.SchemaType.md)<[`ArraySchema`](../interfaces/core.ArraySchema.md)<`SchemaT`\\>\\>\\> & { `items`: `SchemaT` ; `resultType`: [`Array`](../enums/core.ValueType.md#array)  }\n\nA definition accepted by [makeFormula](../functions/core.makeFormula.md) for a formula that returns an array.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `SchemaT` | extends [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"AttributionNode\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: AttributionNode": "[core](../modules/core.md).AttributionNode\n\n **AttributionNode**: [`TextAttributionNode`](../interfaces/core.TextAttributionNode.md) \\| [`LinkAttributionNode`](../interfaces/core.LinkAttributionNode.md) \\| [`ImageAttributionNode`](../interfaces/core.ImageAttributionNode.md)\n\nUnion of attribution node types for rendering attribution for a pack value. See [makeAttributionNode](../functions/core.makeAttributionNode.md).\n\n[]\n\nnav: \"Authentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: Authentication": "[core](../modules/core.md).Authentication\n\n **Authentication**: [`NoAuthentication`](../interfaces/core.NoAuthentication.md) \\| `VariousAuthentication` \\| `AllowedAuthentication`\n\nThe union of supported authentication methods.\n\n[]\n\nnav: \"AuthenticationDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: AuthenticationDef": "[core](../modules/core.md).AuthenticationDef\n\n **AuthenticationDef**: [`NoAuthentication`](../interfaces/core.NoAuthentication.md) \\| `VariousAuthentication` \\| `AllowedAuthenticationDef`\n\nThe union of supported authentication definitions. These represent simplified configurations\na pack developer can specify when calling [setUserAuthentication](../classes/core.PackDefinitionBuilder.md#setuserauthentication) when using\na pack definition builder. The builder massages these definitions into the form of\nan [Authentication](core.Authentication.md) value, which is the value Coda ultimately cares about.\n\n[]\n\nnav: \"BaseFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: BaseFormula<ParamDefsT, ResultT, ContextT\\>": "[core](../modules/core.md).BaseFormula\n\n **BaseFormula**<`ParamDefsT`, `ResultT`, `ContextT`\\>: [`PackFormulaDef`](../interfaces/core.PackFormulaDef.md)<`ParamDefsT`, `ResultT`, `ContextT`\\> & { `resultType`: `TypeOf`<`ResultT`\\>  }\n\nThe base class for pack formula descriptors. Subclasses vary based on the return type of the formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `ResultT` | extends [`PackFormulaResult`](core.PackFormulaResult.md) |\n| `ContextT` | extends [`ExecutionContext`](../interfaces/core.ExecutionContext.md) = [`ExecutionContext`](../interfaces/core.ExecutionContext.md) |\n\n[]\n\nnav: \"BasicPackDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: BasicPackDefinition": "[core](../modules/core.md).BasicPackDefinition\n\n **BasicPackDefinition**: `Omit`<[`PackVersionDefinition`](../interfaces/core.PackVersionDefinition.md), ``\"version\"``\\>\n\nA pack definition without an author-defined semantic version, for use in the web\neditor where Coda will manage versioning on behalf of the pack author.\n\n[]\n\nnav: \"BooleanFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: BooleanFormulaDef<ParamDefsT\\>": "[core](../modules/core.md).BooleanFormulaDef\n\n **BooleanFormulaDef**<`ParamDefsT`\\>: [`BaseFormulaDef`](../interfaces/core.BaseFormulaDef.md)<`ParamDefsT`, `boolean`\\> & { `resultType`: [`Boolean`](../enums/core.ValueType.md#boolean) ; `execute`: (`params`: [`ParamValues`](core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `boolean` \\| `Promise`<`boolean`\\>  }\n\nA definition accepted by [makeFormula](../functions/core.makeFormula.md) for a formula that returns a boolean.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"BooleanHintTypes\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: BooleanHintTypes": "[core](../modules/core.md).BooleanHintTypes\n\n **BooleanHintTypes**: typeof `BooleanHintValueTypes`[`number`]\n\nThe subset of [ValueHintType](../enums/core.ValueHintType.md) that can be used with a boolean value.\n\n[]\n\nnav: \"BooleanPackFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: BooleanPackFormula<ParamDefsT\\>": "[core](../modules/core.md).BooleanPackFormula\n\n **BooleanPackFormula**<`ParamDefsT`\\>: [`BaseFormula`](core.BaseFormula.md)<`ParamDefsT`, `boolean`\\> & { `schema?`: [`BooleanSchema`](../interfaces/core.BooleanSchema.md)  }\n\nA pack formula that returns a boolean.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"FetchMethodType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: FetchMethodType": "[core](../modules/core.md).FetchMethodType\n\n **FetchMethodType**: typeof [`ValidFetchMethods`](../variables/core.ValidFetchMethods.md)[`number`]\n\nThe type of the HTTP methods (verbs) supported by the fetcher.\n\n[]\n\nnav: \"Formula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: Formula<ParamDefsT, ResultT, SchemaT\\>": "[core](../modules/core.md).Formula\n\n **Formula**<`ParamDefsT`, `ResultT`, `SchemaT`\\>: `ResultT` extends [`String`](../enums/core.ValueType.md#string) ? [`StringPackFormula`](core.StringPackFormula.md)<`ParamDefsT`\\> : `ResultT` extends [`Number`](../enums/core.ValueType.md#number) ? [`NumericPackFormula`](core.NumericPackFormula.md)<`ParamDefsT`\\> : `ResultT` extends [`Boolean`](../enums/core.ValueType.md#boolean) ? [`BooleanPackFormula`](core.BooleanPackFormula.md)<`ParamDefsT`\\> : `ResultT` extends [`Array`](../enums/core.ValueType.md#array) ? [`ObjectPackFormula`](core.ObjectPackFormula.md)<`ParamDefsT`, [`ArraySchema`](../interfaces/core.ArraySchema.md)<`SchemaT`\\>\\> : [`ObjectPackFormula`](core.ObjectPackFormula.md)<`ParamDefsT`, `SchemaT`\\>\n\nA pack formula, complete with metadata about the formula like its name, description, and parameters,\nas well as the implementation of that formula.\n\nThis is the type for an actual user-facing formula, rather than other formula-shaped resources within a\npack, like an autocomplete metadata formula or a sync getter formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) = [`ParamDefs`](core.ParamDefs.md) |\n| `ResultT` | extends [`ValueType`](../enums/core.ValueType.md) = [`ValueType`](../enums/core.ValueType.md) |\n| `SchemaT` | extends [`Schema`](core.Schema.md) = [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"FormulaDefinition\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: FormulaDefinition<ParamDefsT, ResultT, SchemaT\\>": "[core](../modules/core.md).FormulaDefinition\n\n **FormulaDefinition**<`ParamDefsT`, `ResultT`, `SchemaT`\\>: `ResultT` extends [`String`](../enums/core.ValueType.md#string) ? [`StringFormulaDef`](core.StringFormulaDef.md)<`ParamDefsT`\\> : `ResultT` extends [`Number`](../enums/core.ValueType.md#number) ? [`NumericFormulaDef`](core.NumericFormulaDef.md)<`ParamDefsT`\\> : `ResultT` extends [`Boolean`](../enums/core.ValueType.md#boolean) ? [`BooleanFormulaDef`](core.BooleanFormulaDef.md)<`ParamDefsT`\\> : `ResultT` extends [`Array`](../enums/core.ValueType.md#array) ? [`ArrayFormulaDef`](core.ArrayFormulaDef.md)<`ParamDefsT`, `SchemaT`\\> : [`ObjectFormulaDef`](core.ObjectFormulaDef.md)<`ParamDefsT`, `SchemaT`\\>\n\nA formula definition accepted by [makeFormula](../functions/core.makeFormula.md).\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `ResultT` | extends [`ValueType`](../enums/core.ValueType.md) |\n| `SchemaT` | extends [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"GenericDynamicSyncTable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericDynamicSyncTable": "[core](../modules/core.md).GenericDynamicSyncTable\n\n **GenericDynamicSyncTable**: [`DynamicSyncTableDef`](../interfaces/core.DynamicSyncTableDef.md)<`any`, `any`, [`ParamDefs`](core.ParamDefs.md), `any`, [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)\\>\n\nType definition for a dynamic sync table.\nShould not be necessary to use directly, see [makeDynamicSyncTable](../functions/core.makeDynamicSyncTable.md)\nfor defining a sync table.\n\n[]\n\nnav: \"GenericSyncFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericSyncFormula": "[core](../modules/core.md).GenericSyncFormula\n\n **GenericSyncFormula**: [`SyncFormula`](core.SyncFormula.md)<`any`, `any`, [`ParamDefs`](core.ParamDefs.md), `any`, [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)\\>\n\nType definition for the formula that implements a sync table.\nShould not be necessary to use directly, see [makeSyncTable](../functions/core.makeSyncTable.md)\nfor defining a sync table.\n\n[]\n\nnav: \"GenericSyncFormulaResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericSyncFormulaResult": "[core](../modules/core.md).GenericSyncFormulaResult\n\n **GenericSyncFormulaResult**: [`SyncFormulaResult`](../interfaces/core.SyncFormulaResult.md)<`any`, `any`, `any`, `any`\\>\n\nType definition for the return value of a sync table.\nShould not be necessary to use directly, see [makeSyncTable](../functions/core.makeSyncTable.md)\nfor defining a sync table.\n\n[]\n\nnav: \"GenericSyncTable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericSyncTable": "[core](../modules/core.md).GenericSyncTable\n\n **GenericSyncTable**: [`SyncTableDef`](../interfaces/core.SyncTableDef.md)<`any`, `any`, [`ParamDefs`](core.ParamDefs.md), `any`, [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)\\>\n\nType definition for a static (non-dynamic) sync table.\nShould not be necessary to use directly, see [makeSyncTable](../functions/core.makeSyncTable.md)\nfor defining a sync table.\n\n[]\n\nnav: \"GenericSyncUpdate\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericSyncUpdate": "[core](../modules/core.md).GenericSyncUpdate\n\n **GenericSyncUpdate**: [`SyncUpdate`](../interfaces/core.SyncUpdate.md)<`any`, `any`, `any`\\>\n\nGeneric type definition for the parameter used to pass in updates to a sync table update function.\n\n[]\n\nnav: \"GenericSyncUpdateSingleResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: GenericSyncUpdateSingleResult": "[core](../modules/core.md).GenericSyncUpdateSingleResult\n\n **GenericSyncUpdateSingleResult**: [`SyncUpdateSingleResult`](core.SyncUpdateSingleResult.md)<`any`, `any`, `any`\\>\n\nGeneric type definition for a single update result returned by a sync table update function.\n\n[]\n\nnav: \"InferrableTypes\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: InferrableTypes": "[core](../modules/core.md).InferrableTypes\n\n **InferrableTypes**: `boolean` \\| `number` \\| `string` \\| `object` \\| `boolean`[] \\| `number`[] \\| `string`[] \\| `object`[]\n\nPrimitive types for which [generateSchema](../functions/core.generateSchema.md) can infer a schema.\n\n[]\n\nnav: \"MetadataContext\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: MetadataContext": "[core](../modules/core.md).MetadataContext\n\n **MetadataContext**: `Record`<`string`, `any`\\> & { `__brand`: ``\"MetadataContext\"``  }\n\nA context object that is provided to a metadata formula at execution time.\nFor example, an autocomplete metadata formula for a parameter value may need\nto know the value of parameters that have already been selected. Those parameter\nvalues are provided in this context object.\n\n[]\n\nnav: \"MetadataFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: MetadataFormula<ContextT\\>": "[core](../modules/core.md).MetadataFormula\n\n **MetadataFormula**<`ContextT`\\>: [`BaseFormula`](core.BaseFormula.md)<[[`ParamDef`](../interfaces/core.ParamDef.md)<[`string`](../enums/core.Type.md#string)\\>, [`ParamDef`](../interfaces/core.ParamDef.md)<[`string`](../enums/core.Type.md#string)\\>], `any`, `ContextT`\\> & { `schema?`: `any`  }\n\nA formula that returns metadata relating to a core pack building block, like a sync table,\na formula parameter, or a user account. Examples include [getSchema](../interfaces/core.DynamicOptions.md#getschema),\n[getConnectionName](../interfaces/core.BaseAuthentication.md#getconnectionname), and [autocomplete](../interfaces/core.ParamDef.md#autocomplete).\n\nMany pack building blocks make use of supporting features that often require JavaScript\nor an API request to implement. For example, fetching the list of available autocomplete\noptions for a formula parameter often requires making an API call. The logic to implement this\nand the context required, like a [Fetcher](../interfaces/core.Fetcher.md) is very similar to that of a pack formula itself,\nso metadata formulas intentionally resemble regular formulas.\n\nA variety of tasks like those mentioned above can all be accomplished with formulas that\nshare the same structure, so all of these supporting features are defined as `MetadataFormulas`.\nYou typically do not need to define a `MetadataFormula` explicitly, but rather can simply define\nthe JavaScript function that implements the formula. Coda will wrap this function with the necessary\nformula boilerplate to make it look like a complete Coda formula.\n\nAll metadata functions are passed an [ExecutionContext](../interfaces/core.ExecutionContext.md) as the first parameter,\nand the optional second parameter is a string whose purpose and value varies depending on\nthe use case. For example, a metadata formula that implements parameter autocomplete will\nbe passed the user's current search if the user has started typing to search for a result.\nNot all metadata formulas make use of this second parameter.\n\nAutocomplete metadata functions are also passed a third parameter, which is a dictionary\nthat has the values the user has specified for each of the other parameters in the formula\n(if any), so that the autocomplete options for one parameter can depend on the current\nvalues of the others. This is dictionary mapping the names of each parameter to its\ncurrent value.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ContextT` | extends [`ExecutionContext`](../interfaces/core.ExecutionContext.md) = [`ExecutionContext`](../interfaces/core.ExecutionContext.md) |\n\n[]\n\nnav: \"MetadataFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: MetadataFormulaDef<ContextT\\>": "[core](../modules/core.md).MetadataFormulaDef\n\n **MetadataFormulaDef**<`ContextT`\\>: [`MetadataFormula`](core.MetadataFormula.md)<`ContextT`\\> \\| [`MetadataFunction`](core.MetadataFunction.md)<`ContextT`\\>\n\nThe type of values that will be accepted as a metadata formula definition. This can either\nbe the JavaScript function that implements a metadata formula (strongly recommended)\nor a full metadata formula definition (mostly supported for legacy code).\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ContextT` | extends [`ExecutionContext`](../interfaces/core.ExecutionContext.md) = [`ExecutionContext`](../interfaces/core.ExecutionContext.md) |\n\n[]\n\nnav: \"MetadataFormulaResultType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: MetadataFormulaResultType": "[core](../modules/core.md).MetadataFormulaResultType\n\n **MetadataFormulaResultType**: `string` \\| `number` \\| [`MetadataFormulaObjectResultType`](../interfaces/core.MetadataFormulaObjectResultType.md)\n\nThe type of values that can be returned from a [MetadataFormula](core.MetadataFormula.md).\n\n[]\n\nnav: \"MetadataFunction\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: MetadataFunction<ContextT\\>": "[core](../modules/core.md).MetadataFunction\n\n **MetadataFunction**<`ContextT`\\>: (`context`: `ContextT`, `search`: `string`, `formulaContext?`: [`MetadataContext`](core.MetadataContext.md)) => `Promise`<[`MetadataFormulaResultType`](core.MetadataFormulaResultType.md) \\| [`MetadataFormulaResultType`](core.MetadataFormulaResultType.md)[] \\| [`ArraySchema`](../interfaces/core.ArraySchema.md) \\| `ObjectSchema`<`any`, `any`\\>\\>\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ContextT` | extends [`ExecutionContext`](../interfaces/core.ExecutionContext.md) = [`ExecutionContext`](../interfaces/core.ExecutionContext.md) |\n\nType declaration\n\n (`context`, `search`, `formulaContext?`): `Promise`<[`MetadataFormulaResultType`](core.MetadataFormulaResultType.md) \\| [`MetadataFormulaResultType`](core.MetadataFormulaResultType.md)[] \\| [`ArraySchema`](../interfaces/core.ArraySchema.md) \\| `ObjectSchema`<`any`, `any`\\>\\>\n\nA JavaScript function that can implement a [MetadataFormulaDef](core.MetadataFormulaDef.md).\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `context` | `ContextT` |\n| `search` | `string` |\n| `formulaContext?` | [`MetadataContext`](core.MetadataContext.md) |\n\nReturns\n\n`Promise`<[`MetadataFormulaResultType`](core.MetadataFormulaResultType.md) \\| [`MetadataFormulaResultType`](core.MetadataFormulaResultType.md)[] \\| [`ArraySchema`](../interfaces/core.ArraySchema.md) \\| `ObjectSchema`<`any`, `any`\\>\\>\n\n[]\n\nnav: \"NumberHintTypes\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: NumberHintTypes": "[core](../modules/core.md).NumberHintTypes\n\n **NumberHintTypes**: typeof `NumberHintValueTypes`[`number`]\n\nThe subset of [ValueHintType](../enums/core.ValueHintType.md) that can be used with a number value.\n\n[]\n\nnav: \"NumberSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: NumberSchema": "[core](../modules/core.md).NumberSchema\n\n **NumberSchema**: [`CurrencySchema`](../interfaces/core.CurrencySchema.md) \\| [`SliderSchema`](../interfaces/core.SliderSchema.md) \\| [`ProgressBarSchema`](../interfaces/core.ProgressBarSchema.md) \\| [`ScaleSchema`](../interfaces/core.ScaleSchema.md) \\| [`NumericSchema`](../interfaces/core.NumericSchema.md) \\| [`NumericDateSchema`](../interfaces/core.NumericDateSchema.md) \\| [`NumericTimeSchema`](../interfaces/core.NumericTimeSchema.md) \\| [`NumericDateTimeSchema`](../interfaces/core.NumericDateTimeSchema.md) \\| [`NumericDurationSchema`](../interfaces/core.NumericDurationSchema.md)\n\nThe union of all schemas that can represent number values.\n\n[]\n\nnav: \"NumericFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: NumericFormulaDef<ParamDefsT\\>": "[core](../modules/core.md).NumericFormulaDef\n\n **NumericFormulaDef**<`ParamDefsT`\\>: [`BaseFormulaDef`](../interfaces/core.BaseFormulaDef.md)<`ParamDefsT`, `number`\\> & { `resultType`: [`Number`](../enums/core.ValueType.md#number) ; `execute`: (`params`: [`ParamValues`](core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `number` \\| `Promise`<`number`\\>  } & { `schema?`: [`NumberSchema`](core.NumberSchema.md)  } \\| { `codaType?`: [`NumberHintTypes`](core.NumberHintTypes.md)  }\n\nA definition accepted by [makeFormula](../functions/core.makeFormula.md) for a formula that returns a number.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"NumericPackFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: NumericPackFormula<ParamDefsT\\>": "[core](../modules/core.md).NumericPackFormula\n\n **NumericPackFormula**<`ParamDefsT`\\>: [`BaseFormula`](core.BaseFormula.md)<`ParamDefsT`, `number`\\> & { `schema?`: [`NumberSchema`](core.NumberSchema.md)  }\n\nA pack formula that returns a number.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"ObjectFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ObjectFormulaDef<ParamDefsT, SchemaT\\>": "[core](../modules/core.md).ObjectFormulaDef\n\n **ObjectFormulaDef**<`ParamDefsT`, `SchemaT`\\>: [`BaseFormulaDef`](../interfaces/core.BaseFormulaDef.md)<`ParamDefsT`, [`SchemaType`](core.SchemaType.md)<`SchemaT`\\>\\> & { `resultType`: [`Object`](../enums/core.ValueType.md#object) ; `schema`: `SchemaT`  }\n\nA definition accepted by [makeFormula](../functions/core.makeFormula.md) for a formula that returns an object.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `SchemaT` | extends [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"ObjectHintTypes\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ObjectHintTypes": "[core](../modules/core.md).ObjectHintTypes\n\n **ObjectHintTypes**: typeof `ObjectHintValueTypes`[`number`]\n\nThe subset of [ValueHintType](../enums/core.ValueHintType.md) that can be used with an object value.\n\n[]\n\nnav: \"ObjectPackFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ObjectPackFormula<ParamDefsT, SchemaT\\>": "[core](../modules/core.md).ObjectPackFormula\n\n **ObjectPackFormula**<`ParamDefsT`, `SchemaT`\\>: `Omit`<[`BaseFormula`](core.BaseFormula.md)<`ParamDefsT`, [`SchemaType`](core.SchemaType.md)<`SchemaT`\\>\\>, ``\"execute\"``\\> & { `schema?`: `SchemaT` ; `execute`: (`params`: [`ParamValues`](core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `object` \\| `Promise`<`object`\\>  }\n\nA pack formula that returns a JavaScript object.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `SchemaT` | extends [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"ObjectSchemaProperties\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ObjectSchemaProperties<K\\>": "[core](../modules/core.md).ObjectSchemaProperties\n\n **ObjectSchemaProperties**<`K`\\>: { [K2 in K \\| string]: Schema & ObjectSchemaProperty }\n\nThe type of the [properties](../interfaces/core.ObjectSchemaDefinition.md#properties) in the definition of an object schema.\nThis is essentially a dictionary mapping the name of a property to a schema\ndefinition for that property.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` = `never` |\n\n[]\n\nnav: \"PackFormulaResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PackFormulaResult": "[core](../modules/core.md).PackFormulaResult\n\n **PackFormulaResult**: `$Values`<`TypeMap`\\> \\| [`PackFormulaResult`](core.PackFormulaResult.md)[]\n\nThe union of types that can be returned by the `execute` function for a formula.\n\n[]\n\nnav: \"PackFormulaValue\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PackFormulaValue": "[core](../modules/core.md).PackFormulaValue\n\n **PackFormulaValue**: `$Values`<`Omit`<`TypeMap`, [`object`](../enums/core.Type.md#object)\\>\\> \\| [`PackFormulaValue`](core.PackFormulaValue.md)[]\n\nThe union of types for arguments to the `execute` function for a formula.\n\n[]\n\nnav: \"PackId\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PackId": "[core](../modules/core.md).PackId\n\n **PackId**: `number`\n\n**`Deprecated`**\n\nUse `number` in new code.\n\n[]\n\nnav: \"ParamDefFromOptionsUnion\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ParamDefFromOptionsUnion<T, O\\>": "[core](../modules/core.md).ParamDefFromOptionsUnion\n\n **ParamDefFromOptionsUnion**<`T`, `O`\\>: `Omit`<`O`, ``\"type\"`` \\| ``\"autocomplete\"``\\> & { `autocomplete`: [`MetadataFormula`](core.MetadataFormula.md) ; `type`: `O` extends [`ParameterOptions`](core.ParameterOptions.md)<infer S\\> ? `ParameterTypeMap`[`S`] : `never`  }\n\nEquivalent to [ParamDef](../interfaces/core.ParamDef.md). A helper type to generate a param def based\non the inputs to [makeParameter](../functions/core.makeParameter.md).\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`ParameterType`](../enums/core.ParameterType.md) |\n| `O` | extends [`ParameterOptions`](core.ParameterOptions.md)<`T`\\> |\n\n[]\n\nnav: \"ParamDefs\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ParamDefs": "[core](../modules/core.md).ParamDefs\n\n **ParamDefs**: [[`ParamDef`](../interfaces/core.ParamDef.md)<`UnionType`\\>, ...ParamDef<UnionType\\>[]] \\| []\n\nThe type for the complete set of parameter definitions for a formula.\n\n[]\n\nnav: \"ParamValues\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ParamValues<ParamDefsT\\>": "[core](../modules/core.md).ParamValues\n\n **ParamValues**<`ParamDefsT`\\>: { [K in keyof ParamDefsT]: ParamDefsT[K] extends RequiredParamDef<infer S\\> ? TypeOfMap<S\\> : ParamDefsT[K] extends ParamDef<infer S\\> ? TypeOfMap<S\\> \\| undefined : never } & `any`[]\n\nThe type for the set of argument values that are passed to formula's `execute` function, based on\nthe parameter definition for that formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"ParameterOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: ParameterOptions<T\\>": "[core](../modules/core.md).ParameterOptions\n\n **ParameterOptions**<`T`\\>: `Omit`<[`ParamDef`](../interfaces/core.ParamDef.md)<`ParameterTypeMap`[`T`]\\>, ``\"type\"`` \\| ``\"autocomplete\"``\\> & { `autocomplete?`: `T` extends `AutocompleteParameterTypes` ? [`MetadataFormulaDef`](core.MetadataFormulaDef.md) \\| (`TypeMap`[`AutocompleteParameterTypeMapping`[`T`]] \\| [`SimpleAutocompleteOption`](../interfaces/core.SimpleAutocompleteOption.md)<`T`\\>)[] : `undefined` ; `type`: `T`  }\n\nOptions you can specify when defining a parameter using [makeParameter](../functions/core.makeParameter.md).\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`ParameterType`](../enums/core.ParameterType.md) |\n\n[]\n\nnav: \"PostSetup\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PostSetup": "[core](../modules/core.md).PostSetup\n\n **PostSetup**: [`SetEndpoint`](../interfaces/core.SetEndpoint.md)\n\nDefinitions for optional steps that can happen upon a user completing setup\nfor a new account for this pack.\n\nThis addresses only a highly-specific use case today but may grow to other\nuse cases and step types in the future.\n\n[]\n\nnav: \"PostSetupDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PostSetupDef": "[core](../modules/core.md).PostSetupDef\n\n **PostSetupDef**: [`SetEndpointDef`](core.SetEndpointDef.md)\n\nSimplified configuration for [PostSetup](core.PostSetup.md) that a pack developer can specify when calling\n[setUserAuthentication](../classes/core.PackDefinitionBuilder.md#setuserauthentication) or [setSystemAuthentication](../classes/core.PackDefinitionBuilder.md#setsystemauthentication).\n\n[]\n\nnav: \"PropertyIdentifier\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PropertyIdentifier<K\\>": "[core](../modules/core.md).PropertyIdentifier\n\n **PropertyIdentifier**<`K`\\>: `K` \\| `string` \\| [`PropertyIdentifierDetails`](../interfaces/core.PropertyIdentifierDetails.md)\n\nAn identifier for an object schema property that is comprised of either an exact property match with the top-level\n`properties or a json path (https://github.com/json-path/JsonPath) to a nested property.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` = `string` |\n\n[]\n\nnav: \"PropertyOptionsMetadataFunction\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PropertyOptionsMetadataFunction<ResultT\\>": "[core](../modules/core.md).PropertyOptionsMetadataFunction\n\n **PropertyOptionsMetadataFunction**<`ResultT`\\>: (`context`: [`PropertyOptionsExecutionContext`](../interfaces/core.PropertyOptionsExecutionContext.md)) => `Promise`<[`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\\> \\| [`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ResultT` | extends [`PackFormulaResult`](core.PackFormulaResult.md)[] |\n\nType declaration\n\n (`context`): `Promise`<[`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\\> \\| [`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\n\nA JavaScript function for property options.\n\nParameters\n\n| Name | Type |\n| :------ | :------ |\n| `context` | [`PropertyOptionsExecutionContext`](../interfaces/core.PropertyOptionsExecutionContext.md) |\n\nReturns\n\n`Promise`<[`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\\> \\| [`PropertyOptionsMetadataResult`](core.PropertyOptionsMetadataResult.md)<`ResultT`\\>\n\n[]\n\nnav: \"PropertyOptionsMetadataResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PropertyOptionsMetadataResult<ResultT\\>": "[core](../modules/core.md).PropertyOptionsMetadataResult\n\n **PropertyOptionsMetadataResult**<`ResultT`\\>: `ResultT` \\| { `cacheTtlSecs?`: `number` ; `result`: `ResultT`  }\n\nThe result of a property options formula. This is either an array, or an array combined with\ncacheTtlSecs to indicate how long the results can be cached for. The default cacheTtlSecs\nis about 5 minutes, if unspecified.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ResultT` | extends [`PackFormulaResult`](core.PackFormulaResult.md)[] |\n\n[]\n\nnav: \"PropertySchemaOptions\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: PropertySchemaOptions<T\\>": "[core](../modules/core.md).PropertySchemaOptions\n\n **PropertySchemaOptions**<`T`\\>: [`PropertyOptionsMetadataFunction`](core.PropertyOptionsMetadataFunction.md)<`T`[]\\> \\| `T`[] \\| [`OptionsType`](../enums/core.OptionsType.md) \\| `OptionsReference`\n\nA function or set of values to return for property options.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`PackFormulaResult`](core.PackFormulaResult.md) |\n\n[]\n\nnav: \"Schema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: Schema": "[core](../modules/core.md).Schema\n\n **Schema**: [`BooleanSchema`](../interfaces/core.BooleanSchema.md) \\| [`NumberSchema`](core.NumberSchema.md) \\| [`StringSchema`](core.StringSchema.md) \\| [`ArraySchema`](../interfaces/core.ArraySchema.md) \\| `GenericObjectSchema`\n\nThe union of all of the schema types supported for return values and object properties.\n\n[]\n\nnav: \"SchemaType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SchemaType<T\\>": "[core](../modules/core.md).SchemaType\n\n **SchemaType**<`T`\\>: `T` extends [`BooleanSchema`](../interfaces/core.BooleanSchema.md) ? `boolean` : `T` extends [`NumberSchema`](core.NumberSchema.md) ? `number` : `T` extends [`StringSchema`](core.StringSchema.md) ? `StringHintTypeToSchemaType`<`T`[``\"codaType\"``]\\> : `T` extends [`ArraySchema`](../interfaces/core.ArraySchema.md) ? [`SchemaType`](core.SchemaType.md)<`T`[``\"items\"``]\\>[] : `T` extends `GenericObjectSchema` ? `ObjectSchemaType`<`T`\\> : `never`\n\nA TypeScript helper that parses the expected `execute` function return type from a given schema.\nThat is, given a schema, this utility will produce the type that an `execute` function should return\nin order to fulfill the schema.\n\nFor example, `SchemaType<NumberSchema>` produces the type `number`.\n\nFor an object schema, this will for the most part return an object matching the schema\nbut if the schema uses [fromKey](../interfaces/core.ObjectSchemaProperty.md#fromkey) then this utility will be unable to infer\nthat the return value type should use the property names given in the `fromKey`\nattribute, and will simply relax any property name type-checking in such a case.\n\nThis utility is very optional and only useful for advanced cases of strong typing.\nIt can be helpful for adding type-checking for the return value of an `execute` function\nto ensure that it matches the schema you have declared for that formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`Schema`](core.Schema.md) |\n\n[]\n\nnav: \"SetEndpointDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SetEndpointDef": "[core](../modules/core.md).SetEndpointDef\n\n **SetEndpointDef**: `Omit`<[`SetEndpoint`](../interfaces/core.SetEndpoint.md), ``\"getOptions\"`` \\| ``\"getOptionsFormula\"``\\> & { `getOptions?`: [`MetadataFormulaDef`](core.MetadataFormulaDef.md) ; `getOptionsFormula?`: [`MetadataFormulaDef`](core.MetadataFormulaDef.md)  }\n\nSimplified configuration for [SetEndpoint](../interfaces/core.SetEndpoint.md) that a pack developer can specify when calling\n[setUserAuthentication](../classes/core.PackDefinitionBuilder.md#setuserauthentication) or [setSystemAuthentication](../classes/core.PackDefinitionBuilder.md#setsystemauthentication).\n\n[]\n\nnav: \"StringFormulaDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: StringFormulaDef<ParamDefsT\\>": "[core](../modules/core.md).StringFormulaDef\n\n **StringFormulaDef**<`ParamDefsT`\\>: [`BaseFormulaDef`](../interfaces/core.BaseFormulaDef.md)<`ParamDefsT`, `string`\\> & { `resultType`: [`String`](../enums/core.ValueType.md#string) ; `execute`: (`params`: [`ParamValues`](core.ParamValues.md)<`ParamDefsT`\\>, `context`: [`ExecutionContext`](../interfaces/core.ExecutionContext.md)) => `string` \\| `Promise`<`string`\\>  } & { `schema?`: [`StringSchema`](core.StringSchema.md)  } \\| { `codaType?`: [`StringHintTypes`](core.StringHintTypes.md)  }\n\nA definition accepted by [makeFormula](../functions/core.makeFormula.md) for a formula that returns a string.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"StringHintTypes\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: StringHintTypes": "[core](../modules/core.md).StringHintTypes\n\n **StringHintTypes**: typeof `StringHintValueTypes`[`number`]\n\nThe subset of [ValueHintType](../enums/core.ValueHintType.md) that can be used with a string value.\n\n[]\n\nnav: \"StringPackFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: StringPackFormula<ParamDefsT\\>": "[core](../modules/core.md).StringPackFormula\n\n **StringPackFormula**<`ParamDefsT`\\>: [`BaseFormula`](core.BaseFormula.md)<`ParamDefsT`, [`SchemaType`](core.SchemaType.md)<[`StringSchema`](core.StringSchema.md)\\>\\> & { `schema?`: [`StringSchema`](core.StringSchema.md)  }\n\nA pack formula that returns a string.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n\n[]\n\nnav: \"StringSchema\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: StringSchema": "[core](../modules/core.md).StringSchema\n\n **StringSchema**: [`StringDateSchema`](../interfaces/core.StringDateSchema.md) \\| [`StringTimeSchema`](../interfaces/core.StringTimeSchema.md) \\| [`StringDateTimeSchema`](../interfaces/core.StringDateTimeSchema.md) \\| `CodaInternalRichTextSchema` \\| [`DurationSchema`](../interfaces/core.DurationSchema.md) \\| [`EmailSchema`](../interfaces/core.EmailSchema.md) \\| [`ImageSchema`](../interfaces/core.ImageSchema.md) \\| [`LinkSchema`](../interfaces/core.LinkSchema.md) \\| [`StringEmbedSchema`](../interfaces/core.StringEmbedSchema.md) \\| [`SimpleStringSchema`](../interfaces/core.SimpleStringSchema.md) \\| [`StringWithOptionsSchema`](../interfaces/core.StringWithOptionsSchema.md)\n\nThe union of schema definition types whose underlying value is a string.\n\n[]\n\nnav: \"SuggestedValueType\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SuggestedValueType<T\\>": "[core](../modules/core.md).SuggestedValueType\n\n **SuggestedValueType**<`T`\\>: `T` extends [`ArrayType`](../interfaces/core.ArrayType.md)<[`date`](../enums/core.Type.md#date)\\> ? `TypeOfMap`<`T`\\> \\| [`PrecannedDateRange`](../enums/core.PrecannedDateRange.md) : `TypeOfMap`<`T`\\>\n\nThe type of values that are allowable to be used as a [suggestedValue](../interfaces/core.ParamDef.md#suggestedvalue) for a parameter.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends `UnionType` |\n\n[]\n\nnav: \"Sync\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: Sync<SyncContinuationT, IncrementalCheckpointContinuationT, IncrementalSyncContinuationT\\>": "[core](../modules/core.md).Sync\n\n **Sync**<`SyncContinuationT`, `IncrementalCheckpointContinuationT`, `IncrementalSyncContinuationT`\\>: [`SyncFull`](../interfaces/core.SyncFull.md)<`SyncContinuationT`\\> \\| [`SyncIncremental`](../interfaces/core.SyncIncremental.md)<`IncrementalSyncContinuationT`, `IncrementalCheckpointContinuationT`\\>\n\nInformation about the current sync, part of the [SyncExecutionContext](../interfaces/core.SyncExecutionContext.md) passed to the\n`execute` function of every sync formula.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `SyncContinuationT` | [`Continuation`](../interfaces/core.Continuation.md) |\n| `IncrementalCheckpointContinuationT` | `SyncContinuationT` |\n| `IncrementalSyncContinuationT` | `SyncContinuationT` |\n\n[]\n\nnav: \"SyncFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SyncFormula<K, L, ParamDefsT, SchemaT, ContextT\\>": "[core](../modules/core.md).SyncFormula\n\n **SyncFormula**<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\>: [`SyncFormulaDef`](../interfaces/core.SyncFormulaDef.md)<`K`, `L`, `ParamDefsT`, `SchemaT`, `ContextT`\\> & { `isSyncFormula`: ``true`` ; `resultType`: `TypeOf`<[`SchemaType`](core.SchemaType.md)<`SchemaT`\\>\\> ; `schema?`: [`ArraySchema`](../interfaces/core.ArraySchema.md) ; `supportsUpdates?`: `boolean`  }\n\nThe result of defining the formula that implements a sync table.\n\nThere is no need to use this type directly. You provide a [SyncFormulaDef](../interfaces/core.SyncFormulaDef.md) as an\ninput to [makeSyncTable](../functions/core.makeSyncTable.md) which outputs definitions of this type.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `ParamDefsT` | extends [`ParamDefs`](core.ParamDefs.md) |\n| `SchemaT` | extends `ObjectSchema`<`K`, `L`\\> |\n| `ContextT` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<`any`, `any`\\> |\n\n[]\n\nnav: \"SyncTable\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SyncTable": "[core](../modules/core.md).SyncTable\n\n **SyncTable**: [`GenericSyncTable`](core.GenericSyncTable.md) \\| [`GenericDynamicSyncTable`](core.GenericDynamicSyncTable.md)\n\nUnion of type definitions for sync tables..\nShould not be necessary to use directly, see [makeSyncTable](../functions/core.makeSyncTable.md) or [makeDynamicSyncTable](../functions/core.makeDynamicSyncTable.md)\nfor defining a sync table.\n\n[]\n\nnav: \"SyncUpdateSingleResult\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SyncUpdateSingleResult<K, L, SchemaT\\>": "[core](../modules/core.md).SyncUpdateSingleResult\n\n **SyncUpdateSingleResult**<`K`, `L`, `SchemaT`\\>: `ObjectSchemaDefinitionType`<`K`, `L`, `SchemaT`\\> \\| `Error`\n\nType definition for a single update result returned by a sync table update function.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `K` | extends `string` |\n| `L` | extends `string` |\n| `SchemaT` | extends [`ObjectSchemaDefinition`](../interfaces/core.ObjectSchemaDefinition.md)<`K`, `L`\\> |\n\n[]\n\nnav: \"SystemAuthentication\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SystemAuthentication": "[core](../modules/core.md).SystemAuthentication\n\n **SystemAuthentication**: [`HeaderBearerTokenAuthentication`](../interfaces/core.HeaderBearerTokenAuthentication.md) \\| [`CustomHeaderTokenAuthentication`](../interfaces/core.CustomHeaderTokenAuthentication.md) \\| [`MultiHeaderTokenAuthentication`](../interfaces/core.MultiHeaderTokenAuthentication.md) \\| [`QueryParamTokenAuthentication`](../interfaces/core.QueryParamTokenAuthentication.md) \\| [`MultiQueryParamTokenAuthentication`](../interfaces/core.MultiQueryParamTokenAuthentication.md) \\| [`WebBasicAuthentication`](../interfaces/core.WebBasicAuthentication.md) \\| [`AWSAccessKeyAuthentication`](../interfaces/core.AWSAccessKeyAuthentication.md) \\| [`AWSAssumeRoleAuthentication`](../interfaces/core.AWSAssumeRoleAuthentication.md) \\| `GoogleServiceAccountAuthentication` \\| [`CustomAuthentication`](../interfaces/core.CustomAuthentication.md) \\| [`OAuth2ClientCredentialsAuthentication`](../interfaces/core.OAuth2ClientCredentialsAuthentication.md)\n\nThe union of authentication methods that are supported for system authentication,\nwhere the pack author provides credentials used in HTTP requests rather than the user.\n\n[]\n\nnav: \"SystemAuthenticationDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SystemAuthenticationDef": "[core](../modules/core.md).SystemAuthenticationDef\n\n **SystemAuthenticationDef**: `AsAuthDef`<[`HeaderBearerTokenAuthentication`](../interfaces/core.HeaderBearerTokenAuthentication.md)\\> \\| `AsAuthDef`<[`CustomHeaderTokenAuthentication`](../interfaces/core.CustomHeaderTokenAuthentication.md)\\> \\| `AsAuthDef`<[`MultiHeaderTokenAuthentication`](../interfaces/core.MultiHeaderTokenAuthentication.md)\\> \\| `AsAuthDef`<[`QueryParamTokenAuthentication`](../interfaces/core.QueryParamTokenAuthentication.md)\\> \\| `AsAuthDef`<[`MultiQueryParamTokenAuthentication`](../interfaces/core.MultiQueryParamTokenAuthentication.md)\\> \\| `AsAuthDef`<[`WebBasicAuthentication`](../interfaces/core.WebBasicAuthentication.md)\\> \\| `AsAuthDef`<[`AWSAccessKeyAuthentication`](../interfaces/core.AWSAccessKeyAuthentication.md)\\> \\| `AsAuthDef`<[`AWSAssumeRoleAuthentication`](../interfaces/core.AWSAssumeRoleAuthentication.md)\\> \\| `AsAuthDef`<`GoogleServiceAccountAuthentication`\\> \\| `AsAuthDef`<[`CustomAuthentication`](../interfaces/core.CustomAuthentication.md)\\> \\| `AsAuthDef`<[`OAuth2ClientCredentialsAuthentication`](../interfaces/core.OAuth2ClientCredentialsAuthentication.md)\\>\n\nThe union of supported system authentication definitions. These represent simplified\nconfigurations a pack developer can specify when calling [setSystemAuthentication](../classes/core.PackDefinitionBuilder.md#setsystemauthentication)\nwhen using a pack definition builder. The builder massages these definitions into the form of\nan [SystemAuthentication](core.SystemAuthentication.md) value, which is the value Coda ultimately cares about.\n\n[]\n\nnav: \"TypedPackFormula\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: TypedPackFormula": "[core](../modules/core.md).TypedPackFormula\n\n **TypedPackFormula**: [`Formula`](core.Formula.md) \\| [`GenericSyncFormula`](core.GenericSyncFormula.md)\n\nThe union of types that represent formula definitions, including standard formula definitions,\nmetadata formulas, and the formulas that implement sync tables.\n\nIt should be very uncommon to need to use this type, it is most common in meta analysis of the\ncontents of a pack for for Coda internal use.\n\n[]\n\nnav: \"UserAuthenticationDef\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: UserAuthenticationDef": "[core](../modules/core.md).UserAuthenticationDef\n\n **UserAuthenticationDef**: [`AuthenticationDef`](core.AuthenticationDef.md) & { `defaultConnectionRequirement?`: [`ConnectionRequirement`](../enums/core.ConnectionRequirement.md)  }\n\nA full definition of a pack's user authentication settings, used in\n[setUserAuthentication](../classes/core.PackDefinitionBuilder.md#setuserauthentication).\n\n[]\n\nnav: \"SyncExecutionContextAsMock\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Type alias: SyncExecutionContextAsMock<T\\>": "[testing](../modules/testing.md).SyncExecutionContextAsMock\n\n **SyncExecutionContextAsMock**<`T`\\>: `T` extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md)<infer ContinuationT, infer IncrementalContinuationT, infer IncrementalSyncContinuationT\\> ? [`MockSyncExecutionContext`](../interfaces/testing.MockSyncExecutionContext.md)<`ContinuationT`, `IncrementalContinuationT`, `IncrementalSyncContinuationT`\\> : `never`\n\nMock type of the specified `SyncExecutionContext`.\n\nType parameters\n\n| Name | Type |\n| :------ | :------ |\n| `T` | extends [`SyncExecutionContext`](../interfaces/core.SyncExecutionContext.md) |\n\n[]\n\nnav: \"PropertyLabelValueTemplate\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Variable: PropertyLabelValueTemplate": "[core](../modules/core.md).PropertyLabelValueTemplate\n\n `Const` **PropertyLabelValueTemplate**: ``\"{VALUE}\"``\n\nAn identifier for the value of a property for use in the [label](../interfaces/core.PropertyIdentifierDetails.md#label) field.\nWhen used, this will be substituted with the value of the property for the final output of the label.\n\nIf not present, the label will be used as-is in the default label format of '{label}: {VALUE}'.\n\n[]\n\nnav: \"DarkModeFragmentId\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Variable: DarkModeFragmentId": "[core](../modules/core.md).[SvgConstants](../modules/core.SvgConstants.md).DarkModeFragmentId\n\n `Const` **DarkModeFragmentId**: ``\"DarkMode\"``\n\nID of the node in a returned SVG file that is targeted when Dark Mode is enabled in Coda.\n\n[]\n\nnav: \"DataUrlPrefix\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Variable: DataUrlPrefix": "[core](../modules/core.md).[SvgConstants](../modules/core.SvgConstants.md).DataUrlPrefix\n\n `Const` **DataUrlPrefix**: ``\"data:image/svg+xml;base64,\"``\n\nPrefix to use for base-64 encoded SVGs returned by formulas.\n\n[]\n\nnav: \"DataUrlPrefixWithDarkModeSupport\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Variable: DataUrlPrefixWithDarkModeSupport": "[core](../modules/core.md).[SvgConstants](../modules/core.SvgConstants.md).DataUrlPrefixWithDarkModeSupport\n\n `Const` **DataUrlPrefixWithDarkModeSupport**: ``\"data:image/svg+xml;supportsDarkMode=1;base64,\"``\n\nPrefix to use for base-64 encoded SVGs (that support Dark Mode) returned by formulas.\n\n[]\n\nnav: \"ValidFetchMethods\"\nnote: \"This file is autogenerated from TypeScript definitions. Make edits to the comments in the TypeScript file and then run `make docs` to regenerate this file.\"\nsearch:\nboost: 0.1\n\n[]",
  "Variable: ValidFetchMethods": "[core](../modules/core.md).ValidFetchMethods\n\n `Const` **ValidFetchMethods**: readonly [``\"GET\"``, ``\"PATCH\"``, ``\"POST\"``, ``\"PUT\"``, ``\"DELETE\"``, ``\"HEAD\"``]\n\nThe HTTP methods (verbs) supported by the fetcher.\n\n[]\n\nnav: Cats\ndescription: A Pack that generates images of cats.\nicon: fontawesome/solid/cat\n\n[]",
  "Cats sample": "This Pack allows you to fetch random cat photos using the [Cat-as-a-service API][cataas]. You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides:\n\n['A formula for fetching a cat photo.', 'A column format that displays the text on top of a cat photo.', 'A sync table that retrieves all available cat photos.']\n\n[cataas]: https://cataas.com/\n\n=== \"pack.ts\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"cataas.com\");\n\n// Tag parameter, shared across multiple formulas.\nconst TagParameter = coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"tag\",\n  description: \"Only cats with this tag will be selected.\",\n  optional: true,\n  // Pull the list of tags to use for autocomplete from the API.\n  autocomplete: async function (context, search) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://cataas.com/api/tags\",\n    });\n    let tags = response.body;\n    // Convert the tags into a list of autocomplete options.\n    return coda.simpleAutocomplete(search, tags);\n  },\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size of the text, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The color of the text. Any valid CSS color can be used.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"width\",\n      description: \"The width of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"height\",\n      description: \"The height of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n    TagParameter,\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function (\n    [text, size, color, width, height, filter, tag],\n    context,\n    ) {\n    let url = \"https://cataas.com/cat\";\n    if (tag) {\n      url += \"/\" + tag;\n    }\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      size: size,\n      color: color,\n      width: width,\n      height: height,\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n});\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  properties: {\n    image: {\n      description: \"The cat image.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      description: \"The tags used to categorize this cat.\",\n      type: coda.ValueType.Array,\n      items: coda.makeSchema({ type: coda.ValueType.String }),\n    },\n    created: {\n      description: \"When the cat image was added.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"image\",\n  idProperty: \"id\",\n  featuredProperties: [\"tags\"],\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [TagParameter],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag,\n        limit: 10000,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat._id,\n          tags: cat.tags,\n          created: cat.createdAt,\n          id: cat._id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});\n```\n\n\n\n\n[]\n\nnav: Daylight\ndescription: A Pack that fetches data about the expected hours of daylight at a location.\nicon: fontawesome/regular/sun\n\n[]",
  "Daylight sample": "This Pack provides a `Daylight` formula that determines the daylight, sunrise,\nand sunset at a given location using the [Sunrise Sunset API][api]. It accepts\na latitude, longitude, an optional date and returns a rich object (schema) as\na result. It uses the `Fetcher` to pull data from an external API.\n\n[api]: https://sunrise-sunset.org/api\n\n=== \"pack.ts\"\n```ts\n/**\n* This Pack provides a \"Daylight\" formula that determines the daylight,\n* sunrise, and sunset at a given location using the Sunrise Sunset API.\n* The results are returns as a rich object.\n* @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API}\n*/\n\n// This import statement provides access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates the new Pack.\nexport const pack = coda.newPack();\n\n// The domain that the Pack will match fetcher requests to.\npack.addNetworkDomain(\"sunrise-sunset.org\");\n\n// Define a schema that will be used to bundle up the multiple pieces of data\n// our formula will return. In the Coda doc this will be displayed as a chip.\nconst SunSchema = coda.makeObjectSchema({\n  properties: {\n    // The values we return are simple strings, but we use the codaType field to\n    // to tell Coda to interpret them as durations and time values.\n    daylight: {\n      description: \"How much daylight there will be.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunrise: {\n      description: \"When the sun will rise (in the document's timezone).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunset: {\n      description: \"When the sun will set (in the document's timezone).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  displayProperty: \"daylight\",\n});\n\n// Add a \"Daylight\" formula to the Pack.\npack.addFormula({\n  name: \"Daylight\",\n  description: \"Returns the sunrise and sunset for a given location.\",\n\n  // This formula takes two required numeric inputs (the latitude and longitude)\n  // and one optional date.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lat\",\n      description: \"The latitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lng\",\n      description: \"The longitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date to use. Defaults to today.\",\n      // This date parameter is an optional input.\n      optional: true,\n    }),\n  ],\n\n  // In this formula, we're returning an object with multiple properties.\n  resultType: coda.ValueType.Object,\n\n  // This object will be defined according to the schema written above.\n  schema: SunSchema,\n\n  // Everything inside this execute statement will happen anytime the Coda\n  // formula is called in a doc. An array of all user inputs is passed as the\n  // first parameter. The context object is always the second parameter and is\n  // used for fetching data.\n  execute: async function ([lat, lng, date], context) {\n    // Default to today if no date is provided.\n    let lookupDate = date || new Date();\n\n    // Format the date parameter to a date string in the correct timezone.\n    let formattedDate = lookupDate.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n    });\n\n    // Create the URL to fetch, using the helper function coda.withQueryParams\n    // to add on query parameters (ex: \"?lat=40.123...\").\n    let url = coda.withQueryParams(\"https://api.sunrise-sunset.org/json\", {\n      lat: lat,\n      lng: lng,\n      date: formattedDate,\n      formatted: 0,\n    });\n\n    // Fetch the URL and get the response.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // The JSON returned by the API is parsed automatically and available in\n    // `response.body`. Here we pull out the content in the \"results\" key.\n    let results = response.body.results;\n\n    // Return the final object. The keys here must match with the properties\n    // defined above in the schema.\n    return {\n      daylight: results.day_length + \" seconds\",\n      sunrise: results.sunrise,\n      sunset: results.sunset,\n    };\n  },\n});\n```\n\n\n\n\n[]\n\nnav: Dungeons &amp; Dragons\ndescription: A Pack that uses an API to retrieve information about the game Dungeons &amp; Dragons.\nicon: fontawesome/solid/dragon\n\n[]",
  "Dungeons &amp; Dragons sample": "This Pack allows you to fetch information about spells in th game Dungeons and Dragons using the [D&D 5e API][dnd]. The Pack provides:\n\n['A formula for looking up a spell by name.', 'A column format that displays information about the spell name in the cell.', 'A sync table that retrieves all available spells.']\n\n[dnd]: http://www.dnd5eapi.co/\n\n=== \"pack.ts\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// How many spells to fetch in each sync formula execution.\nconst BATCH_SIZE = 20;\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Schema that defines the metadata to return for each spell. Shared by the\n// formula, column format, and sync table.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table fields.\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n  // Card fields.\n  subtitleProperties: [\n    \"level\",\n    \"range\",\n    \"duration\",\n    \"damage_type\",\n  ],\n  snippetProperty: \"description\",\n});\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}\n\n// A formula that looks up a spell given a name, returning the first result.\npack.addFormula({\n  name: \"Spell\",\n  description: \"Gets information about a spell, given its name.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the spell.\",\n      suggestedValue: \"Acid Arrow\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: SpellSchema,\n  execute: async function ([name], context) {\n    // Search for spells that match the name provided.\n    let searchUrl = coda.withQueryParams(\n      \"https://www.dnd5eapi.co/api/spells/\",\n      { name: name },\n      );\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: searchUrl,\n    });\n    let results = response.body.results;\n\n    // If no spells match, throw an error.\n    if (!results?.length) {\n      throw new coda.UserVisibleError(\"Unknown spell: \" + name);\n    }\n\n    // Fetch the spell details for the first result.\n    let topResult = results.slice(0, 1);\n    let spells = await fetchSpells(context.fetcher, topResult);\n\n    // Return the spell data for the result.\n    return spells[0];\n  },\n});\n\n// A column format that displays information about the spell with the given\n// name.\npack.addColumnFormat({\n  name: \"Spell\",\n  instructions: \"Displays information about the spell with this name.\",\n  formulaName: \"Spell\",\n});\n\n// A sync table that displays all spells available in the API.\npack.addSyncTable({\n  name: \"Spells\",\n  identityName: \"Spell\",\n  schema: SpellSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncSpells\",\n    description: \"Sync all the spells.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the list of all spells.\n      let listUrl = \"https://www.dnd5eapi.co/api/spells\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: listUrl,\n      });\n      let results = response.body.results;\n\n      // If there is a previous continuation, start from the index contained\n      // within, otherwise start at zero.\n      let index: number = (context.sync.continuation?.index as number) || 0;\n\n      // Get a batch of results, starting from the index determined above.\n      let batch = results.slice(index, index + BATCH_SIZE);\n\n      // Fetch the spells for the batch of results.\n      let spells = await fetchSpells(context.fetcher, batch);\n\n      // Move the index forward.\n      index += BATCH_SIZE;\n\n      // If there are more results to process, create a new continuation.\n      let continuation;\n      if (index <= results.length) {\n        continuation = {\n          index: index,\n        };\n      }\n\n      // Return the batch of spells and the next continuation, if any.\n      return {\n        result: spells,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}\n```\n\n\n\n\n[]\n\nnav: GitHub\ndescription: A Pack that integrates with GitHub.\nicon: fontawesome/brands/github\n\n[]",
  "GitHub sample": "This Pack demonstrates a lightweight integration with [GitHub][github]. There is a lot of functionality provided by the GitHub API, but this sample just provides a few features related to repositories (repos):\n\n['A formula that provides rich data about a repo given its URL.', 'A column format that automatically applies that formula to matching URLs.', 'An action formula (button) that stars a repo given its URL.', \"A sync table that pulls in all of the user's repos.\"]\n\nThe Pack uses OAuth2 to connect to a user's GitHub account. A more extensive GitHub sample that is deployed via the CLI is available in the [`packs-examples` repo][github_example].\n\n[github]: https://github.com/\n[github_example]: https://github.com/coda/packs-examples/tree/main/examples/github\n\n=== \"pack.ts\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression used to parse repo URLs.\nconst RepoUrlRegex = new RegExp(\"^https://github.com/([^/]+)/([^/]+)\");\n\n// How many items to fetch per-page when making API list requests.\nconst PageSize = 50;\n\n// Allow the Pack to access the GitHub domain.\npack.addNetworkDomain(\"github.com\");\n\n// Setup per-user authentication using GitHub's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://docs.github.com/en/developers/apps/building-oauth-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://github.com/login/oauth/authorize\",\n  tokenUrl: \"https://github.com/login/oauth/access_token\",\n  tokenPrefix: \"token\",\n  scopes: [\"repo\", \"user\"],\n\n  // Determines the name of the GitHub account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.github.com/user\",\n    });\n    return response.body.login;\n  },\n});\n\n// A schema that defines a repo object.\nconst RepoSchema = coda.makeObjectSchema({\n  properties: {\n    id: { type: coda.ValueType.Number },\n    name: { type: coda.ValueType.String },\n    fullName: { type: coda.ValueType.String, fromKey: \"full_name\" },\n    description: { type: coda.ValueType.String },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n      fromKey: \"html_url\",\n    },\n    watchers: { type: coda.ValueType.Number, fromKey: \"watchers_count\" },\n    forks: { type: coda.ValueType.Number, fromKey: \"forks_count\" },\n    stars: { type: coda.ValueType.Number, fromKey: \"stargazers_count\" },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"watchers\", \"forks\", \"stars\"],\n});\n\n// A formula to fetch information about a repo.\npack.addFormula({\n  name: \"Repo\",\n  description: \"Get information about a repo from it's URL.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the repo.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: RepoSchema,\n  execute: async function ([url], context) {\n    let { owner, name } = parseRepoUrl(url);\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: `https://api.github.com/repos/${owner}/${name}`,\n    });\n    let repo = response.body;\n    return repo;\n  },\n});\n\n// A column format that automatically applies the Repo() formula.\npack.addColumnFormat({\n  name: \"Repo\",\n  instructions: \"Show details about a GitHub repo, given a URL.\",\n  formulaName: \"Repo\",\n  matchers: [RepoUrlRegex],\n});\n\n// An action formula that allows a user to star a repo.\npack.addFormula({\n  name: \"Star\",\n  description: \"Add a star to a repo.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the repo.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  isAction: true,\n  execute: async function ([url], context) {\n    let { owner, name } = parseRepoUrl(url);\n    let response = await context.fetcher.fetch({\n      method: \"PUT\",\n      url: `https://api.github.com/user/starred/${owner}/${name}`,\n    });\n    return true;\n  },\n});\n\n// A sync table that lists all of the user's repos.\npack.addSyncTable({\n  name: \"Repos\",\n  description: \"All of the repos that the user has access to.\",\n  identityName: \"Repo\",\n  schema: RepoSchema,\n  formula: {\n    name: \"SyncRepos\",\n    description: \"Sync the repos.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the page to start from.\n      let page = (context.sync.continuation?.page as number) || 1;\n\n      // Fetch a page of repos from the GitHub API.\n      let url = coda.withQueryParams(\"https://api.github.com/user/repos\", {\n        page: page,\n        per_page: PageSize,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let repos = response.body;\n\n      // If there were some results, re-run this formula for the next page.\n      let continuation;\n      if (repos.length > 0) {\n        continuation = { page: page + 1 };\n      }\n\n      // Return the repos and the continuation (if any).\n      return {\n        result: repos,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// A helper function that parses a repo URL and returns the owner and name.\nfunction parseRepoUrl(url) {\n  let match = url.match(RepoUrlRegex);\n  if (!match) {\n    throw new coda.UserVisibleError(\"Invalid repo URL: \" + url);\n  }\n  return {\n    owner: match[1],\n    name: match[2],\n  };\n}\n```\n\n\n\n\n[]\n\nnav: Hello World\ndescription: A simple &quot;Hello World&quot; Pack.\nicon: material/hand-wave-outline\n\n[]",
  "Hello World sample": "This is an example which creates a single formula called `Hello`, that takes in a string called `name` and returns `Hello, <name>!`.\n\n=== \"Hello World\"\n```ts\n/*\nStart making Packs!\nTry out the hello world sample below to create your first build.\n*/\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates your new Pack.\nexport const pack = coda.newPack();\n\n// Here, we add a new formula to this Pack.\npack.addFormula({\n  // This is the name that will be called in the formula builder.\n  // Remember, your formula name cannot have spaces in it.\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n\n  // If your formula requires one or more inputs, youll define them here.\n  // Here, we're creating a string input called name.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name you would like to say hello to.\",\n    }),\n  ],\n\n  // The resultType defines what will be returned in your Coda doc. Here, we're\n  // returning a simple text string.\n  resultType: coda.ValueType.String,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // formula is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([name], context) {\n    return \"Hello \" + name + \"!\";\n  },\n});\n```\n\n\n\n\n[]\n\nnav: Math\ndescription: A Pack that provides various math operations.\nicon: material/calculator-variant\n\n[]",
  "Math sample": "This Pack contains a few mathematical formulas, including the [greatest common divisor][wikipedia_gcd] (GCD) and [least common multiple][wikipedia_lcm] (LCM).\n\n[wikipedia_gcd]: https://en.wikipedia.org/wiki/Greatest_common_divisor\n[wikipedia_lcm]: https://en.wikipedia.org/wiki/Least_common_multiple\n\n=== \"pack.ts\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A \"numbers\" parameter shared by both formulas.\nconst NumbersParameter = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"numbers\",\n  description: \"The numbers to perform the calculation on.\",\n});\n\npack.addFormula({\n  name: \"GCD\",\n  description: \"Returns the greatest common divisor for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where all the numbers are zeros.\n    if (numbers.every(number => number === 0)) {\n      throw new coda.UserVisibleError(\n        \"The list must contain a non-zero number.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = gcd(number, result);\n    }\n    return result;\n  },\n});\n\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where the list contains a zero.\n    if (numbers.some(number => number === 0)) {\n      throw new coda.UserVisibleError(\"The list must not contain a zero.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = Math.abs(number * result) / gcd(number, result);\n    }\n    return result;\n  },\n});\n\n// Helper function that calculates the greatest common divisor of two\n// numbers.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}\n```\n\n\n\n\n[]\n\nnav: Todoist\ndescription: A Pack that integrates with the application Todoist.\nicon: octicons/tasklist-16\n\n[]",
  "Todoist sample": "This Pack provides an integration with the task tracking app [Todoist][todoist]. It uses a variety of building blocks to allow users to work with their projects and tasks, including:\n\n['Formulas that provide rich data about an item given its URL.', 'Column formats that automatically apply those formulas to matching URLs.', 'Action formulas that create and update items, for use in button and automations.', \"Sync tables for pulling in all of the user's items.\"]\n\nThe Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free.\n\n[todoist]: https://todoist.com/\n\n=== \"pack.ts\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\n\n// #region Constants\n\nconst ProjectUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showProject\\\\?id=([0-9]+)\"),\n];\n\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n// #endregion\n\n\n// #region Pack setup\n\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n  scopeDelimiter: \",\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// #endregion\n\n\n// #region Schemas\n\nconst DueSchema = coda.makeObjectSchema({\n  properties: {\n    date: {\n      description: \"The date the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n    },\n    time: {\n      description: \"The specific moment the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n      fromKey: \"datetime\",\n    },\n    display: {\n      description: \"The display value for the due date.\",\n      type: coda.ValueType.String,\n      fromKey: \"string\",\n    },\n  },\n  displayProperty: \"display\",\n});\n\nconst ProjectSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      mutable: true,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    shared: {\n      description: \"Is the project is shared.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_shared\",\n    },\n    favorite: {\n      description: \"Is the project a favorite.\",\n      type: coda.ValueType.Boolean,\n      mutable: true,\n      fromKey: \"is_favorite\",\n    },\n    id: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    parentProjectId: {\n      description: \"For sub-projects, the ID of the parent project.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"id\",\n  featuredProperties: [\"url\", \"favorite\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  subtitleProperties: [\"shared\", \"favorite\"],\n});\n\n// Create a reference schema for projects, to use for relation columns.\nconst ProjectReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(ProjectSchema, \"Project\");\n\n// Using the reference schema, add a property for the parent project.\n(ProjectSchema.properties as coda.ObjectSchemaProperties)\n  .parentProject = ProjectReferenceSchema;\n\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Markdown,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    order: {\n      description: \"The position of the task in the project or parent task.\",\n      type: coda.ValueType.Number,\n      mutable: true,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      options: [\"P1\", \"P2\", \"P3\", \"P4\"],\n      mutable: true,\n    },\n    due: {\n      description: \"When the task is due.\",\n      ...DueSchema,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    projectId: {\n      description: \"The ID of the project that the task belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"project_id\",\n    },\n    parentTaskId: {\n      description: \"For sub-tasks, the ID of the parent task it belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n    // A reference to the project (for sync tables only).\n    project: {\n      ...ProjectReferenceSchema,\n      mutable: true,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"id\",\n  featuredProperties: [\"project\", \"url\", \"completed\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  snippetProperty: \"description\",\n  subtitleProperties: [\n    \"priority\",\n    \"completed\",\n    { label: \"Due\", property: \"due.display\" },\n  ],\n});\n\n// Create a reference schema for tasks, to use for relation columns.\nconst TaskReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(TaskSchema, \"Task\");\n\n// Using the reference schema, add a property for the parent task.\n(TaskSchema.properties as coda.ObjectSchemaProperties)\n  .parentTask = TaskReferenceSchema;\n\n// Format a project from the API and return an object matching the schema.\nfunction formatProjectForSchema(project: any, withReferences = false) {\n  let result: any = {\n    ...project,\n  };\n  if (withReferences && project.parent_id) {\n    result.parentProject = {\n      id: project.parent_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n  }\n  return result;\n}\n\n// Format a task from the API and return an object matching the Task schema.\nfunction formatTaskForSchema(task: any, withReferences = false) {\n  let result: any = {\n    ...task,\n    // Convert the priority to a string like \"P1\".\n    priority: \"P\" + (5 - task.priority),\n  };\n  if (withReferences) {\n    // Add a reference to the corresponding row in the Projects sync table.\n    result.project = {\n      id: task.project_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n    if (task.parent_id) {\n      // Add a reference to the corresponding row in the Tasks sync table.\n      result.parentTask = {\n        id: task.parent_id,\n        name: \"Not found\", // If sync'ed, the real name will be shown instead.\n      };\n    }\n  }\n  return result;\n}\n\n// Format a task from a sync table and return an object matching the API.\nfunction formatTaskForAPI(task: any) {\n  let result: any = {\n    ...task,\n  };\n  if (result.priority) {\n    // Convert the priority back to a number.\n    result.priority = 5 - Number(result.priority.substring(1));\n  }\n  return result;\n}\n\n// #endregion\n\n\n// #region Formulas\n\npack.addFormula({\n  name: \"Project\",\n  description: \"Gets a Todoist project by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the project\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProjectSchema,\n  execute: async function ([url], context) {\n    let projectId = extractProjectId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects/\" + projectId,\n      method: \"GET\",\n    });\n    return formatProjectForSchema(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Column Formats\n\npack.addColumnFormat({\n  name: \"Project\",\n  formulaName: \"Project\",\n  matchers: ProjectUrlPatterns,\n});\n\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"Task\",\n  matchers: TaskUrlPatterns,\n});\n\n// #endregion\n\n\n// #region Actions\n\npack.addFormula({\n  name: \"AddProject\",\n  description: \"Add a new Todoist project\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the new project\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        name: name,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"projectId\",\n      description: \"The ID of the project to add it to. If blank, \" +\n        \"it will be added to the user's Inbox.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name, projectId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n        project_id: projectId,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"SetDueDate\",\n  description: \"Change the due date of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date the task is due.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"endOfDay\",\n      description:\n        \"If the task is due at the end of the day (vs a specific time).\",\n      suggestedValue: true,\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  // To update the existing row in a sync table, return the schema with an\n  // identity matching the identityName on the sync table being updated, using\n  // the helper function coda.withIdentity().\n  schema: coda.withIdentity(TaskSchema, \"Task\"),\n  isAction: true,\n  execute: async function ([taskId, date, endOfDay = false], context) {\n    let url = \"https://api.todoist.com/rest/v2/tasks/\" + taskId;\n    let payload: any = {\n      id: taskId,\n    };\n    if (endOfDay) {\n      payload.due_date = date.toISOString().split(\"T\")[0];\n    } else {\n      payload.due_datetime = date.toISOString();\n    }\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(payload),\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Sync tables\n\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let project of response.body) {\n        results.push(formatProjectForSchema(project, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates one at a time.\n    maxUpdateBatchSize: 1,\n    executeUpdate: async function (args, updates, context) {\n      let update = updates[0];\n      let project = update.newValue;\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: `https://api.todoist.com/rest/v2/projects/${project.id}`,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(project),\n      });\n      let updated = formatProjectForSchema(response.body, true);\n\n      return {\n        result: [updated],\n      };\n    },\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A supported filter string. See the Todoist help center.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"project\",\n        description: \"Limit tasks to a specific project.\",\n        optional: true,\n        autocomplete: async function (context, search) {\n          let url = \"https://api.todoist.com/rest/v2/projects\";\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: url,\n          });\n          let projects = response.body;\n          return coda.autocompleteSearchObjects(search, projects, \"name\", \"id\");\n        },\n      }),\n    ],\n    execute: async function ([filter, project], context) {\n      let url = coda.withQueryParams(\"https://api.todoist.com/rest/v2/tasks\", {\n        filter: filter,\n        project_id: project,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push(formatTaskForSchema(task, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates in batches.\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Generate the set of commands needed to process each update.\n      let commandSets = updates.map(update => generateTaskCommands(update));\n\n      // Send all of the commands to the sync endpoint.\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.todoist.com/sync/v9/sync\",\n        form: {\n          commands: JSON.stringify(commandSets.flat()),\n        },\n      });\n      let statuses = response.body.sync_status;\n\n      // Process the results, returning either an error or the updated task.\n      // This is done async, so the fetches can be done in parallel.\n      let jobs = updates.map(async (update, i) => {\n        let taskId = update.newValue.id;\n        let commands = commandSets[i];\n        for (let command of commands) {\n          let status = statuses[command.uuid];\n          if (status.error) {\n            return new coda.UserVisibleError(status.error);\n          }\n        }\n        // If there were no errors, fetch the updated task and return it.\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n          cacheTtlSecs: 0,\n        });\n        return formatTaskForSchema(response.body, true);\n      });\n      let results = await Promise.all(jobs);\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Generate a list of API commands from a Task row update.\nfunction generateTaskCommands(update: coda.GenericSyncUpdate): any[] {\n  let commands: any[] = [];\n  let { previousValue, newValue, updatedFields } = update;\n\n  // Update the task.\n  commands.push({\n    type: \"item_update\",\n    uuid: getUniqueId(),\n    args: formatTaskForAPI(newValue),\n  });\n\n  // Update the parent project, if it has changed.\n  if (updatedFields.includes(\"project\")) {\n    commands.push({\n      type: \"item_move\",\n      args: {\n        id: newValue.id,\n        project_id: newValue.project?.id,\n      },\n      uuid: getUniqueId(),\n    });\n  }\n\n  // Update the completion status, if it's changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    commands.push({\n      type: newValue.is_completed ? \"item_complete\" : \"item_uncomplete\",\n      uuid: getUniqueId(),\n      args: {\n        id: newValue.id,\n      },\n    });\n  }\n  return commands;\n}\n\n// #endregion\n\n\n// #region Helper functions\n\nfunction extractProjectId(projectUrl: string) {\n  for (let pattern of ProjectUrlPatterns) {\n    let matches = projectUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid project URL: \" + projectUrl);\n}\n\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\nfunction getUniqueId() {\n  return Math.random().toString(36);\n}\n\n// #endregion\n```\n\n\n\n\n[]\n\nnav: Samples\ndescription: An index of code examples to browse through.\nhide:\n\n['toc']\n\n[]",
  "Sample code": {
    "{{section.title}}": {
      "{% if child.meta.icon %}:{{child.meta.icon|replace(\"/\", \"-\")}}:{% endif %} {{ child.meta.get(\"nav\", child.title) }}": "{{child.meta.description}}\n\n[View]({{getRelativePath(child,page)}}){ .md-button }\n\n</div>\n\n{% endfor %}\n\n</section>\n\n{% endfor %}\n\n[packs_examples]: https://github.com/coda/packs-examples\n\n[]\n\nnav: Actions\ndescription: Samples that show how to create an action formula, for use in a button or automation.\nicon: material/cursor-default-click-outline\n\n[]"
    }
  },
  "Action samples": {
    "Template": "The basic structure of an action. This sample takes in a single string parameter and returns the string &quot;OK&quot; when the action is complete.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyAction\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Do something.\n    return \"OK\";\n  },\n});\n{% endraw %}\n```",
    "Random value": "A formula that returns a random value. This sample rolls virtual dice and returns the results.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Rolls virtual dice and returns the resulting numbers. Use it with a button in\n// table and store the results in another column.\npack.addFormula({\n  name: \"RollDice\",\n  description: \"Roll some virtual dice.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many dice to roll.\",\n      suggestedValue: 1,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"sides\",\n      description: \"How many sides the dice have.\",\n      suggestedValue: 6,\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.Number,\n  }),\n  isAction: true,\n  execute: async function ([quantity, sides], context) {\n    let results = [];\n    for (let i = 0; i < quantity; i++) {\n      let roll = Math.ceil(Math.random() * sides);\n      results.push(roll);\n    }\n    return results;\n  },\n});\n{% endraw %}\n```",
    "Post to API": "A formula that posts data to an external API. This sample creates a new task in the Todoist app.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Action formula (for buttons and automations) that adds a new task in Todoist.\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Return values are optional but recommended. Returning a URL or other\n    // unique identifier is recommended when creating a new entity.\n    return response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "Update row in sync table": "A formula that updates an item on the server, and the existing row in a sync table if it exists. This sample updates the name of a task in the Todoist app.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"url\"],\n});\n\n// Action formula (for buttons and automations) that updates an existing task,\n// and by returning the schema also updates the existing row in the sync table.\npack.addFormula({\n  name: \"UpdateTask\",\n  description: \"Updates the name of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to update.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The new name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  // For schemas returned by actions to update rows in a sync table, set the\n  // identity on the schema to match the identityName on the sync table being\n  // updated, using the helper function coda.withIdentity().\n  schema: coda.withIdentity(TaskSchema, \"Task\"),\n  isAction: true,\n\n  execute: async function ([taskId, name], context) {\n    let url = \"https://api.todoist.com/rest/v2/tasks/\" + taskId;\n    await context.fetcher.fetch({\n      url: url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Get the updated Task and return it, which will update the row in the sync\n    // table.\n    let response = await context.fetcher.fetch({\n      url: url,\n      method: \"GET\",\n      cacheTtlSecs: 0, // Ensure we are getting the latest data.\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      id: task.id,\n    };\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          id: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```\n\n[]\n\nnav: API setup\ndescription: Samples that show how to configure a Pack to connect to various popular APIs.\nicon: material/api\n\n[]"
  },
  "API setup samples": {
    "Asana": "The Asana API uses OAuth2 to authenticate users, and requires the use of PKCE.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Asana API, using OAuth2.\n// See https://developers.asana.com/docs/oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://app.asana.com/-/oauth_authorize\",\n  tokenUrl: \"https://app.asana.com/-/oauth_token\",\n\n  // Enable PKCE (required).\n  useProofKeyForCodeExchange: true,\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://app.asana.com/api/1.0/users/me\",\n    });\n    let user = response.body.data;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Asana.\npack.addNetworkDomain(\"asana.com\");\n{% endraw %}\n```",
    "AWS S3": "The Amazon Web Services (AWS) S3 service uses their custom signature method.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the AWS S3 service, using AWS Signature Version 4.\n// The user provides the URL of their S3 bucket as the endpoint, along with an\n// access key and secret.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  instructionsUrl:\n    \"https://aws.amazon.com/premiumsupport/knowledge-center/create-access-key/\",\n\n  // The AWS service to connect to.\n  service: \"s3\",\n\n  // Prompt the user from their S3 bucket URL.\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n\n  // Use the bucket name as the display name for the account.\n  getConnectionName: async function (context) {\n    return context.endpoint.split(\"//\")[1].split(\".\")[0];\n  },\n});\n{% endraw %}\n```",
    "Battle.net": "Blizzard&#x27;s Battle.net APIs use the Client Credentials OAuth2 flow.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to Blizzard's Battle.net APIs, using the OAuth2\n// client_credentials flow.\n// eslint-disable-next-line max-len\n// See https://develop.battle.net/documentation/guides/using-oauth/client-credentials-flow.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.OAuth2ClientCredentials,\n  tokenUrl: \"https://oauth.battle.net/token\",\n});\n\n// Allow the pack to make requests to Battle.net.\npack.addNetworkDomain(\"blizzard.com\");\n{% endraw %}\n```",
    "Board Game Atlas": "The Board Game Atlas API requires the developer to provide their client ID as query parameter.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Authenticate using a client ID.\n// See: https://www.boardgameatlas.com/api/docs/apps\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"client_id\",\n});\n\npack.addNetworkDomain(\"boardgameatlas.com\");\n{% endraw %}\n```",
    "ClickUp": "The ClickUp API uses OAuth2 to authenticate users.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the ClickUp API, using OAuth2.\n// See https://clickup.com/api\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://app.clickup.com/api\",\n  tokenUrl: \"https://app.clickup.com/api/v2/oauth/token\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.clickup.com/api/v2/user\",\n    });\n    let user = response.body.user;\n    return user.username;\n  },\n});\n\n// Allow the pack to make requests to the ClickUp.\npack.addNetworkDomain(\"clickup.com\");\n{% endraw %}\n```",
    "Coda API": "The Coda API requires the user to provide an API token, passed in an Authorization header. Packs include a specific authentication type optimized for the Coda API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Coda API, using a token in the Authorization\n// header.\n// See https://coda.io/developers/apis/v1\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CodaApiHeaderBearerToken,\n\n  // Creates the token automatically when the Pack is installed.\n  shouldAutoAuthSetup: true,\n});\n\n// Allow the pack to make requests to Coda.\npack.addNetworkDomain(\"coda.io\");\n{% endraw %}\n```",
    "Copper API": "The Copper API requires the user to provide an API key and their email address, passed in custom HTTP headers.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Copper API, using multiple HTTP headers.\n// See https://developer.copper.com/introduction/requests.html#headers.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiHeaderToken,\n  headers: [\n    { name: \"X-PW-AccessToken\", description: \"API key\" },\n    { name: \"X-PW-UserEmail\", description: \"Email address\" },\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.copper.com/developer_api/v1/account\",\n      headers: {\n        \"X-PW-Application\": \"developer_api\",\n      },\n    });\n    let account = response.body;\n    return account.name;\n  },\n});\n\n// Allow the pack to make requests to Copper.\npack.addNetworkDomain(\"copper.com\");\n{% endraw %}\n```",
    "Dropbox": "The Dropbox API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Set per-user authentication using Dropbox's OAuth2.\n// See https://developers.dropbox.com/oauth-guide\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.dropbox.com/oauth2/authorize\",\n  tokenUrl: \"https://api.dropbox.com/oauth2/token\",\n  scopes: [\"files.content.read\"],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    token_access_type: \"offline\",\n  },\n});\n\n// Allow access to the Dropbox domain.\npack.addNetworkDomain(\"dropboxapi.com\");\n{% endraw %}\n```",
    "Facebook (Meta)": "The Facebook (Meta) APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Facebook (Meta) APIs, using OAuth2.\n// eslint-disable-next-line max-len\n// See https://developers.facebook.com/docs/facebook-login/guides/advanced/manual-flow\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.facebook.com/v14.0/dialog/oauth\",\n  tokenUrl: \"https://graph.facebook.com/v14.0/oauth/access_token\",\n\n  // All scopes: https://developers.facebook.com/docs/permissions/reference\n  scopes: [\n    \"public_profile\",\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://graph.facebook.com/v14.0/me\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Facebook.\npack.addNetworkDomain(\"facebook.com\");\n{% endraw %}\n```",
    "Giphy": "The Giphy API requires the developer to provide their API key as query parameter.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to the Giphy API, using an API key in the query\n// string. See https://support.giphy.com/hc/en-us/articles/360020283431.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\n// Allow the pack to make requests to Giphy.\npack.addNetworkDomain(\"giphy.com\");\n{% endraw %}\n```",
    "GitHub": "The GitHub API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. The authorization header uses the non-standard prefix &quot;token&quot; instead of the default &quot;Bearer&quot;.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Setup per-user authentication using GitHub's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://docs.github.com/en/developers/apps/building-oauth-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://github.com/login/oauth/authorize\",\n  tokenUrl: \"https://github.com/login/oauth/access_token\",\n  tokenPrefix: \"token\",\n  scopes: [\"repo\", \"user\"],\n\n  // Determines the name of the GitHub account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.github.com/user\",\n    });\n    return response.body.login;\n  },\n});\n\n// Allow the Pack to access the GitHub domain.\npack.addNetworkDomain(\"github.com\");\n{% endraw %}\n```",
    "Google": "The Google APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted. Note: It currently isn&#x27;t possible to complete Google&#x27;s OAuth verification process with a Pack. See the [FAQ](https://coda.io/packs/build/latest/guides/faq/#google) for more information.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Google APIs, using OAuth2.\n// See https://developers.google.com/identity/protocols/oauth2/web-server\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n\n  // All scopes: https://developers.google.com/identity/protocols/oauth2/scopes\n  scopes: [\n    \"profile\",\n  ],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://www.googleapis.com/oauth2/v1/userinfo\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Google.\npack.addNetworkDomain(\"googleapis.com\");\n{% endraw %}\n```",
    "Jira": "The Jira API uses OAuth2 to authenticate users. After authenticating users must select which Jira instance to associate the account with, and all further API requests are sent to that instance&#x27;s URL.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Jira Cloud API, using OAuth2 with a\n// post-submit step to select the instance to connect to. Note that this code\n// isn't compatible with Jira Data Center.\n// See https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://auth.atlassian.com/authorize\",\n  tokenUrl: \"https://auth.atlassian.com/oauth/token\",\n  scopes: [\"offline_access\", \"read:jira-user\", \"read:jira-work\"],\n  additionalParams: {\n    audience: \"api.atlassian.com\",\n    prompt: \"consent\",\n  },\n\n  // After approving access, the user should select which instance they want to\n  // connect to.\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: \"SelectEndpoint\",\n    description: \"Select the site to connect to:\",\n    // Determine the list of sites they have access to.\n    getOptions: async function (context) {\n      let url = \"https://api.atlassian.com/oauth/token/accessible-resources\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let sites = response.body;\n      return sites.map(site => {\n        // Constructing an endpoint URL from the site ID.\n        let url = \"https://api.atlassian.com/ex/jira/\" + site.id;\n        return { display: site.name, value: url };\n      });\n    },\n  }],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // This function is run twice: once before the site has been selected and\n    // again after. When the site hasn't been selected yet, return a generic\n    // name.\n    if (!context.endpoint) {\n      return \"Jira\";\n    }\n    // Include both the name of the user and server.\n    let server = await getServer(context);\n    let user = await getUser(context);\n    return `${user.displayName} (${server.serverTitle})`;\n  },\n});\n\n// Get information about the Jira server.\nasync function getServer(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/serverInfo\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Get information about the Jira user.\nasync function getUser(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/myself\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Jira.\npack.addNetworkDomain(\"atlassian.com\");\n{% endraw %}\n```",
    "Microsoft": "The Microsoft APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted, and PKCE is recommended.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Microsoft APIs, using OAuth2.\n// eslint-disable-next-line max-len\n// See https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl:\n    \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\",\n  tokenUrl: \"https://login.microsoftonline.com/common/oauth2/v2.0/token\",\n\n  // eslint-disable-next-line max-len\n  // Learn more: https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent\n  scopes: [\n    \"offline_access\",\n    \"user.read\",\n  ],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Enable PKCE (optional but recommended).\n  useProofKeyForCodeExchange: true,\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://graph.microsoft.com/v1.0/me\",\n    });\n    let user = response.body;\n    return user.displayName;\n  },\n});\n\n// Allow the pack to make requests to Microsoft.\npack.addNetworkDomain(\"microsoft.com\");\n{% endraw %}\n```",
    "Okta": "The Okta API requires the user to provide an API key, passed as an Authorization header with a custom prefix. The user must also specify which Okta domain to connect to.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Okta API, using a custom token prefix and\n// account-specific endpoints.\n// See https://developer.okta.com/docs/reference/core-okta-api/#authentication\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"Authorization\",\n  tokenPrefix: \"SSWS\",\n\n  // Ask users for their Okta subdomain.\n  requiresEndpointUrl: true,\n  endpointDomain: \"okta.com\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    // Retrieve the endpoint that the user set.\n    let endpoint = context.endpoint;\n    let url = endpoint + \"/api/v1/org\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.companyName;\n  },\n});\n\n// Allow the pack to make requests to Okta.\npack.addNetworkDomain(\"okta.com\");\n{% endraw %}\n```",
    "Rapid API": "Rapid APIs require that the developer provide an API key, passed in a custom header.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to RapidAPI, using an API key in a custom header.\n// See https://docs.rapidapi.com/docs/keys#how-to-find-your-api-key.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-RapidAPI-Key\",\n});\n\n// Allow the pack to make requests to RapidAPI.\npack.addNetworkDomain(\"rapidapi.com\");\n{% endraw %}\n```",
    "Salesforce": "The Salesforce API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted. The URL to send API requests is returned in the OAuth2 response, and passed to other formulas.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Salesforce API, using OAuth2 and an\n// automatically determined account-specific endpoint.\n// eslint-disable-next-line max-len\n// See https://help.salesforce.com/s/articleView?id=sf.remoteaccess_authenticate.htm&type=5\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://login.salesforce.com/services/oauth2/authorize\",\n  tokenUrl: \"https://login.salesforce.com/services/oauth2/token\",\n  scopes: [\"id\", \"api\", \"refresh_token\"],\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Each account is associated with an instance URL, returned in the OAuth\n  // token response.\n  requiresEndpointUrl: true,\n  endpointDomain: \"salesforce.com\",\n  endpointKey: \"instance_url\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // Relative URLs have the endpoint URL automatically prepended.\n    let url = \"/services/oauth2/userinfo\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.name;\n  },\n});\n\n// Allow the pack to make requests to Salesforce.\npack.addNetworkDomain(\"salesforce.com\");\n{% endraw %}\n```",
    "Slack": "The Slack API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional settings are required for compatibility with their non-standard implementation.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Slack API, using OAuth2.\n// See https://api.slack.com/authentication/oauth-v2\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://slack.com/oauth/v2/authorize\",\n  tokenUrl: \"https://slack.com/api/oauth.v2.access\",\n  scopes: [\"users.profile:read\"],\n\n  // Slack uses a comma as the scope delimiter.\n  scopeDelimiter: \",\",\n\n  // Slack uses the standard \"scope\" parameter for bot scopes.\n  // User scopes must be specified in the \"user_scope\" parameter instead.\n  scopeParamName: \"user_scope\",\n\n  // The user's OAuth tokens are returned in the nested object \"authed_user\".\n  nestedResponseKey: \"authed_user\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://slack.com/api/users.profile.get\",\n      cacheTtlSecs: 0,\n    });\n    let profile = response.body.profile;\n    return profile.display_name || profile.real_name;\n  },\n});\n\n// Allow the pack to make requests to Slack.\npack.addNetworkDomain(\"slack.com\");\n{% endraw %}\n```",
    "Todoist": "The Todoist API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using an OAuth2 flow.\n// See https://developer.todoist.com/guides/#oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n{% endraw %}\n```",
    "Typeform": "The Typeform API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Configure per-user authentication for the Typeform API, using OAuth2.\n// See: https://developer.typeform.com/get-started/applications/\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://api.typeform.com/oauth/authorize\",\n  tokenUrl: \"https://api.typeform.com/oauth/token\",\n\n  // See: https://developer.typeform.com/get-started/scopes/\n  scopes: [\"forms:read\", \"responses:read\", \"accounts:read\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = \"https://api.typeform.com/me\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let profile = response.body;\n    return profile.alias;\n  },\n});\n\n// Allow requests to Typeform.\npack.addNetworkDomain(\"typeform.com\");\n{% endraw %}\n```",
    "Twilio": "The Twilio API requires the user to provide the SID and token for their account, passed using the Web Basic scheme.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Twilio API, using an Account SID and token in\n// an \"Authorization: Basic ...\" header.\n// See https://www.twilio.com/docs/usage/requests-to-twilio\npack.setUserAuthentication({\n  type: coda.AuthenticationType.WebBasic,\n  instructionsUrl: \"https://www.twilio.com/docs/sms/api#sms-api-authentication\",\n\n  // Use Twilio-specific placeholders for the username and password fields.\n  uxConfig: {\n    placeholderUsername: \"Account SID\",\n    placeholderPassword: \"Auth Token\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.twilio.com/2010-04-01/Accounts.json\",\n    });\n    // Return the name of the main account.\n    return response.body.accounts[0].friendly_name;\n  },\n});\n\n// Allow the pack to make requests to Twilio.\npack.addNetworkDomain(\"twilio.com\");\n{% endraw %}\n```",
    "Webflow": "The Typeform API uses OAuth2 to authenticate users, and requires the developer to specify the API version in a custom header.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// The version of the Webflow API to use.\nconst WebflowApiVersion = \"1.0.0\";\n\n// Per-user authentication to the ClickUp API, using OAuth2.\n// See https://developers.webflow.com/oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://webflow.com/oauth/authorize\",\n  tokenUrl: \"https://api.webflow.com/oauth/access_token\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.webflow.com/user\",\n      headers: {\n        \"Accept-Version\": WebflowApiVersion,\n      },\n    });\n    let user = response.body.user;\n    return `${user.firstName} ${user.lastName}`;\n  },\n});\n\n// Allow the pack to make requests to Webflow.\npack.addNetworkDomain(\"webflow.com\");\n{% endraw %}\n```",
    "Yahoo": "The Yahoo APIs uses OAuth2 to authenticate users.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Setup per-user authentication using Yahoo's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://developer.yahoo.com/oauth2/guide/flows_authcode/\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://api.login.yahoo.com/oauth2/request_auth\",\n  tokenUrl: \"https://api.login.yahoo.com/oauth2/get_token\",\n  scopes: [\"openid\"],\n\n  // Determines the name of the Yahoo account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.login.yahoo.com/openid/v1/userinfo\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the Pack to access the Yahoo domain.\npack.addNetworkDomain(\"yahoo.com\");\n{% endraw %}\n```\n\n[]\n\nnav: Authentication\ndescription: Samples that show how to authenticate with an API.\nicon: material/account-key\n\n[]"
  },
  "Authentication samples": {
    "Authorization header": "Authentication that passes a long-lived token in the Authorization header using the &quot;Bearer&quot; scheme. This sample connects to the Todoist API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using a personal API token in\n// an \"Authorization: Bearer ...\" header.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n{% endraw %}\n```",
    "Custom header": "Authentication that passes a long-lived token in a custom header. This sample connects to RapidAPI.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to RapidAPI, using an API key in a custom header.\n// See https://docs.rapidapi.com/docs/keys#how-to-find-your-api-key.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-RapidAPI-Key\",\n});\n\n// Allow the pack to make requests to RapidAPI.\npack.addNetworkDomain(\"rapidapi.com\");\n{% endraw %}\n```",
    "Multiple headers": "Authentication that passes multiple long-lived token in a HTTP headers. This sample connects to the Copper API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Copper API, using multiple HTTP headers.\n// See https://developer.copper.com/introduction/requests.html#headers.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiHeaderToken,\n  headers: [\n    { name: \"X-PW-AccessToken\", description: \"API key\" },\n    { name: \"X-PW-UserEmail\", description: \"Email address\" },\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.copper.com/developer_api/v1/account\",\n      headers: {\n        \"X-PW-Application\": \"developer_api\",\n      },\n    });\n    let account = response.body;\n    return account.name;\n  },\n});\n\n// Allow the pack to make requests to Copper.\npack.addNetworkDomain(\"copper.com\");\n{% endraw %}\n```",
    "Query parameter": "Authentication that passes a long-lived token in a query parameter. This sample connects to the Giphy API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to the Giphy API, using an API key in the query\n// string. See https://support.giphy.com/hc/en-us/articles/360020283431.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\n// Allow the pack to make requests to Giphy.\npack.addNetworkDomain(\"giphy.com\");\n{% endraw %}\n```",
    "Multiple query parameters": "Authentication that passes multiple long-lived tokens in query parameters. This sample connects to the Smarty API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Smarty API, using multiple query parameters.\n// See https://www.smarty.com/docs/cloud/authentication#keypairs\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiQueryParamToken,\n  params: [\n    { name: \"auth-id\", description: \"The Auth ID of the secret key.\" },\n    { name: \"auth-token\", description: \"The Auth Token of the secret key.\" },\n  ],\n});\n\n// Allow the pack to make requests to Smarty.\npack.addNetworkDomain(\"smartystreets.com\");\n{% endraw %}\n```",
    "Custom tokens": "Authentication that passes any number of custom tokens in the URL, headers, or request body. This sample connects to the Vonage SMS API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Vonage API, using an API key and secret\n// in the request body.\n// See https://developer.vonage.com/en/api/sms\npack.setUserAuthentication({\n  type: coda.AuthenticationType.Custom,\n  params: [\n    { name: \"api_key\", description: \"API key.\" },\n    { name: \"api_secret\", description: \"API secret.\" },\n  ],\n});\n\npack.addFormula({\n  name: \"SendSMS\",\n  description: \"Sends an SMS message.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The phone number to send from.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"to\",\n      description: \"The phone number to send to.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text of the message.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([from, to, text], context) {\n    // Create the placeholders for the API key and secret.\n    let invocationToken = context.invocationToken;\n    let apiKeyPlaceholder = \"{{api_key-\" + invocationToken + \"}}\";\n    let apiSecretPlaceholder = \"{{api_secret-\" + invocationToken + \"}}\";\n\n    // Construct the JSON request body.\n    let body = {\n      from: from,\n      to: to,\n      text: text,\n      // These placeholders will be automatically replaced with the user's key\n      // and secret before the request is made.\n      api_key: apiKeyPlaceholder,\n      api_secret: apiSecretPlaceholder,\n    };\n\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://rest.nexmo.com/sms/json\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n\n    let message = response.body.messages[0];\n    if (message.status !== \"0\") {\n      throw new coda.UserVisibleError(message[\"error-text\"]);\n    }\n    return message[\"message-id\"];\n  },\n});\n\n// Allow the pack to make requests to Vonage (former Nexmo).\npack.addNetworkDomain(\"nexmo.com\");\n{% endraw %}\n```",
    "Username and password": "Authentication that passes a username and password in the Authorization header using the &quot;Basic&quot; scheme. This sample connects to the Twilio API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Twilio API, using an Account SID and token in\n// an \"Authorization: Basic ...\" header.\n// See https://www.twilio.com/docs/usage/requests-to-twilio\npack.setUserAuthentication({\n  type: coda.AuthenticationType.WebBasic,\n  instructionsUrl: \"https://www.twilio.com/docs/sms/api#sms-api-authentication\",\n\n  // Use Twilio-specific placeholders for the username and password fields.\n  uxConfig: {\n    placeholderUsername: \"Account SID\",\n    placeholderPassword: \"Auth Token\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.twilio.com/2010-04-01/Accounts.json\",\n    });\n    // Return the name of the main account.\n    return response.body.accounts[0].friendly_name;\n  },\n});\n\n// Allow the pack to make requests to Twilio.\npack.addNetworkDomain(\"twilio.com\");\n{% endraw %}\n```",
    "Coda API token": "Authentication optimized for connecting to the Coda API, which is a token passed in the Authorization header.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Coda API, using a token in the Authorization\n// header.\n// See https://coda.io/developers/apis/v1\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CodaApiHeaderBearerToken,\n\n  // Creates the token automatically when the Pack is installed.\n  shouldAutoAuthSetup: true,\n});\n\n// Allow the pack to make requests to Coda.\npack.addNetworkDomain(\"coda.io\");\n{% endraw %}\n```",
    "AWS Signature Version 4": "Authentication that supports Amazon Web Services (AWS), using an access key and secret. This sample connects to the S3 service.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the AWS S3 service, using AWS Signature Version 4.\n// The user provides the URL of their S3 bucket as the endpoint, along with an\n// access key and secret.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  instructionsUrl:\n    \"https://aws.amazon.com/premiumsupport/knowledge-center/create-access-key/\",\n\n  // The AWS service to connect to.\n  service: \"s3\",\n\n  // Prompt the user from their S3 bucket URL.\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n\n  // Use the bucket name as the display name for the account.\n  getConnectionName: async function (context) {\n    return context.endpoint.split(\"//\")[1].split(\".\")[0];\n  },\n});\n{% endraw %}\n```",
    "OAuth2": "Authentication that uses the Authorization Code OAuth2 flow. This sample connects to the Todoist API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using an OAuth2 flow.\n// See https://developer.todoist.com/guides/#oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n{% endraw %}\n```",
    "OAuth2 client credentials": "Authentication that uses the Client Credentials OAuth2 flow. This sample connects to Blizzard&#x27;s Battle.net APIs.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to Blizzard's Battle.net APIs, using the OAuth2\n// client_credentials flow.\n// eslint-disable-next-line max-len\n// See https://develop.battle.net/documentation/guides/using-oauth/client-credentials-flow.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.OAuth2ClientCredentials,\n  tokenUrl: \"https://oauth.battle.net/token\",\n});\n\n// Allow the pack to make requests to Battle.net.\npack.addNetworkDomain(\"blizzard.com\");\n{% endraw %}\n```",
    "Manual endpoint": "Authentication that requires users to enter the endpoint URL for their account. This sample connects to the Okta API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Okta API, using a custom token prefix and\n// account-specific endpoints.\n// See https://developer.okta.com/docs/reference/core-okta-api/#authentication\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"Authorization\",\n  tokenPrefix: \"SSWS\",\n\n  // Ask users for their Okta subdomain.\n  requiresEndpointUrl: true,\n  endpointDomain: \"okta.com\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    // Retrieve the endpoint that the user set.\n    let endpoint = context.endpoint;\n    let url = endpoint + \"/api/v1/org\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.companyName;\n  },\n});\n\n// Allow the pack to make requests to Okta.\npack.addNetworkDomain(\"okta.com\");\n{% endraw %}\n```",
    "Automatic endpoint": "Authentication that automatically determines the account-specific endpoint URL during the OAuth2 flow. This sample connects to the Salesforce API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Salesforce API, using OAuth2 and an\n// automatically determined account-specific endpoint.\n// eslint-disable-next-line max-len\n// See https://help.salesforce.com/s/articleView?id=sf.remoteaccess_authenticate.htm&type=5\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://login.salesforce.com/services/oauth2/authorize\",\n  tokenUrl: \"https://login.salesforce.com/services/oauth2/token\",\n  scopes: [\"id\", \"api\", \"refresh_token\"],\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Each account is associated with an instance URL, returned in the OAuth\n  // token response.\n  requiresEndpointUrl: true,\n  endpointDomain: \"salesforce.com\",\n  endpointKey: \"instance_url\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // Relative URLs have the endpoint URL automatically prepended.\n    let url = \"/services/oauth2/userinfo\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.name;\n  },\n});\n\n// Allow the pack to make requests to Salesforce.\npack.addNetworkDomain(\"salesforce.com\");\n{% endraw %}\n```",
    "User-selected endpoint": "Authentication that presents a list of endpoints to the user for them to select one. This sample connects to the Jira API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Jira Cloud API, using OAuth2 with a\n// post-submit step to select the instance to connect to. Note that this code\n// isn't compatible with Jira Data Center.\n// See https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://auth.atlassian.com/authorize\",\n  tokenUrl: \"https://auth.atlassian.com/oauth/token\",\n  scopes: [\"offline_access\", \"read:jira-user\", \"read:jira-work\"],\n  additionalParams: {\n    audience: \"api.atlassian.com\",\n    prompt: \"consent\",\n  },\n\n  // After approving access, the user should select which instance they want to\n  // connect to.\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: \"SelectEndpoint\",\n    description: \"Select the site to connect to:\",\n    // Determine the list of sites they have access to.\n    getOptions: async function (context) {\n      let url = \"https://api.atlassian.com/oauth/token/accessible-resources\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let sites = response.body;\n      return sites.map(site => {\n        // Constructing an endpoint URL from the site ID.\n        let url = \"https://api.atlassian.com/ex/jira/\" + site.id;\n        return { display: site.name, value: url };\n      });\n    },\n  }],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // This function is run twice: once before the site has been selected and\n    // again after. When the site hasn't been selected yet, return a generic\n    // name.\n    if (!context.endpoint) {\n      return \"Jira\";\n    }\n    // Include both the name of the user and server.\n    let server = await getServer(context);\n    let user = await getUser(context);\n    return `${user.displayName} (${server.serverTitle})`;\n  },\n});\n\n// Get information about the Jira server.\nasync function getServer(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/serverInfo\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Get information about the Jira user.\nasync function getUser(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/myself\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Jira.\npack.addNetworkDomain(\"atlassian.com\");\n{% endraw %}\n```\n\n[]\n\nnav: Autocomplete\ndescription: Samples that show how to provide autocomplete options for a parameter.\nicon: material/form-dropdown\n\n[]"
  },
  "Autocomplete samples": {
    "Simple autocomplete": "A formula with a parameter that provides autocomplete for acceptable values. This sample returns the noise that an animal makes, for a limited set of animals.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the noise an animal makes. Ex) \"cow\" => \"moo\".\npack.addFormula({\n  name: \"AnimalNoise\",\n  description: \"Gets the noise than an animal makes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"animal\",\n      description: \"The selected animal.\",\n      autocomplete: [\"cow\", \"pig\", \"sheep\"],\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([animal], context) {\n    switch (animal) {\n      case \"cow\":\n        return \"moo\";\n      case \"pig\":\n        return \"oink\";\n      case \"sheep\":\n        return \"baa\";\n      default:\n        throw new coda.UserVisibleError(\"Unknown animal: \" + animal);\n    }\n  },\n});\n{% endraw %}\n```",
    "Dynamic autocomplete": "A formula with a parameter that provides autocomplete for acceptable values, where the options are pulled dynamically from an API. This sample returns the price for a board game listed on the site Board Game Atlas.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Gets the price of a board game by ID, with autocomplete on the ID.\npack.addFormula({\n  name: \"GetPrice\",\n  description: \"Gets the price of a board game.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"gameId\",\n      description: \"The ID of the game on boardgameatlas.com\",\n      autocomplete: async function (context, search, parameters) {\n        let url = coda.withQueryParams(\n          \"https://api.boardgameatlas.com/api/search\",\n          { fuzzy_match: true, name: search });\n        let response = await context.fetcher.fetch({ method: \"GET\", url: url });\n        let results = response.body.games;\n        // Generate an array of autocomplete objects, using the game's name as\n        // the label and its ID for the value.\n        return coda.autocompleteSearchObjects(search, results, \"name\", \"id\");\n      },\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([gameId], context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.boardgameatlas.com/api/search?ids=\" + gameId,\n    });\n    return response.body.games[0].price;\n  },\n});\n\npack.addNetworkDomain(\"boardgameatlas.com\");\n\n// Authenticate using a client ID.\n// See: https://www.boardgameatlas.com/api/docs/apps\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"client_id\",\n});\n{% endraw %}\n```",
    "Autocomplete on previous parameter": "A formula with a parameter that provides autocomplete for acceptable values, where the options depend on the value of a previous parameter. This sample generates a greeting in either English or Spanish.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Greet someone in their language, with the greeting autocomplete adjusting\n// based on the language selected.\npack.addFormula({\n  name: \"Greeting\",\n  description: \"Greet someone.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"language\",\n      description: \"The language to greet them in.\",\n      autocomplete: [\n        { display: \"English\", value: \"en\" },\n        { display: \"Spanish\", value: \"es\" },\n      ],\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"greeting\",\n      description: \"The greeting to use.\",\n      autocomplete: async function (context, search, { language }) {\n        let options;\n        if (language === \"es\") {\n          options = [\"Hola\", \"Buenos das\"];\n        } else {\n          options = [\"Hello\", \"Howdy\"];\n        }\n        return coda.simpleAutocomplete(search, options);\n      },\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name to greet.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  execute: async function ([language, greeting, name], context) {\n    let result = greeting + \" \" + name + \"!\";\n    if (language === \"es\") {\n      // Add upside-down exclamation point in the front.\n      result = \"\" + result;\n    }\n    return result;\n  },\n});\n{% endraw %}\n```",
    "Autocomplete on vararg key-value pairs": "A formula with vararg parameters that represent key-value pairs, which provides autocomplete for available keys and for acceptable values based on the selected key. This sample generates a fictitious ice cream order. Note: This technique will not work when using vararg parameters in the builder UIs.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Generates a fictitious ice cream order, using a flexible set of choices.\npack.addFormula({\n  name: \"OrderIcecream\",\n  description: \"Put in your ice cream order.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"scoops\",\n      description: \"How many scoops do you want?\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"choice\",\n      description: \"Which choice to set.\",\n      autocomplete: [\"flavor\", \"topping\", \"vessel\"],\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"value\",\n      description: \"The value of that choice.\",\n      autocomplete: async function (context, search, params) {\n        switch (params.choice) {\n          case \"flavor\":\n            return [\"vanilla\", \"chocolate\", \"strawberry\"];\n          case \"topping\":\n            return [\"sprinkles\", \"whipped cream\", \"chocolate shell\"];\n          case \"vessel\":\n            return [\"cone\", \"cup\"];\n          default:\n            return [];\n        }\n      },\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([scoops, ...args], context) {\n    let result = `${scoops}: scoops`;\n    let choice, value;\n    while (args.length > 0) {\n      [choice, value, ...args] = args;\n      result += `, ${choice}: ${value}`;\n    }\n    return result;\n  },\n});\n{% endraw %}\n```\n\n[]\n\nnav: Cards\ndescription: Samples that show how to create cards to preview content.\nicon: material/card-text\n\n[]"
  },
  "Card samples": {
    "Template": "The basic structure of a card.\n\n```\n{% raw %}\n// A schema that defines the data shown in the card.\nconst ThingSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    description: { type: coda.ValueType.String },\n    picture: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    link: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    // TODO: Add more properties.\n  },\n  displayProperty: \"$2\",\n  titleProperty: \"$2\",\n  snippetProperty: \"$3\",\n  imageProperty: \"$4\",\n  linkProperty: \"$5\",\n  subtitleProperties: [\n    // TODO: List the properties to show under the title.\n  ],\n});\n\n// A formula that accepts a URL and returns an object matching the schema above.\npack.addFormula({\n  name: \"$1\",\n  description: \"My description.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \" My parameter description.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: $1Schema,\n  execute: async function (args, context) {\n    let [url] = args;\n    // TODO: Fetch information about the item represented by the URL.\n    return {\n      // TODO: Populate with fetched information.\n      $5: url,\n    };\n  },\n});\n\n// A column format that defines which URL patterns the formula should match.\npack.addColumnFormat({\n  name: \"$1\",\n  instructions: \"My instructions.\",\n  formulaName: \"$1\",\n  matchers: [\n    new RegExp(\"https://example.com/.*\"),\n    // TODO: Optionally add more URL patterns.\n  ],\n});\n{% endraw %}\n```",
    "Basic card": "A formula that returns a card containing an title, subtitle, and snippet. This sample returns a card with information about a spell in the game Dungeons &amp; Dragons.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the card, including all of metadata what specifically to\n// highlight in the card.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table fields.\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n  // Card fields.\n  subtitleProperties: [\n    \"level\",\n    \"range\",\n    \"duration\",\n    \"damage_type\",\n  ],\n  snippetProperty: \"description\",\n});\n\n// Formula that renders a card for a spell given it's name. This will be shown\n// a \"Card\" in the Pack's list of building blocks, but is also a regular formula\n// that can be used elsewhere.\npack.addFormula({\n  name: \"Spell\",\n  description: \"Gets information about a spell, given its name.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the spell.\",\n      suggestedValue: \"Acid Arrow\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: SpellSchema,\n  execute: async function ([name], context) {\n    // Search for spells that match the name provided.\n    let searchUrl = coda.withQueryParams(\n      \"https://www.dnd5eapi.co/api/spells/\",\n      { name: name },\n      );\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: searchUrl,\n    });\n    let results = response.body.results;\n\n    // If no spells match, throw an error.\n    if (!results?.length) {\n      throw new coda.UserVisibleError(\"Unknown spell: \" + name);\n    }\n\n    // Fetch the spell details for the first result.\n    let topResult = results.slice(0, 1);\n    let spells = await fetchSpells(context.fetcher, topResult);\n\n    // Return the spell data for the result.\n    return spells[0];\n  },\n});\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}\n\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}\n{% endraw %}\n```",
    "With image": "A formula that returns a card that includes an image. This samples returns a card with the current weather at a given location in the United States.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Define the schema that will be used to render the card.\nconst WeatherSchema = coda.makeObjectSchema({\n  properties: {\n    summary: { type: coda.ValueType.String, fromKey: \"shortForecast\" },\n    forecast: { type: coda.ValueType.String, fromKey: \"detailedForecast\" },\n    temperature: { type: coda.ValueType.String },\n    wind: { type: coda.ValueType.String, fromKey: \"windSpeed\" },\n    icon: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    link: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n  },\n  displayProperty: \"summary\",\n  subtitleProperties: [\n    // Only show the value for the temperature property.\n    { property: \"temperature\", label: \"\" },\n    \"wind\",\n  ],\n  snippetProperty: \"forecast\",\n  imageProperty: \"icon\",\n  linkProperty: \"link\",\n});\n\n// Add a formula that fetches the weather and returns it as a card.\npack.addFormula({\n  name: \"CurrentWeather\",\n  description: \"Get the current weather at a specific location (US only).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"latitude\",\n      description: \"The latitude of the location.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"longitude\",\n      description: \"The longitude of the location.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"isMetric\",\n      description: \"Whether to use metric units. Default: false.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: WeatherSchema,\n  execute: async function ([latitude, longitude, isMetric], context) {\n    let url = await getForecastUrl(latitude, longitude, context);\n    if (isMetric) {\n      url = coda.withQueryParams(url, { units: \"si\" });\n    }\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let data = response.body;\n    let weather = data.properties.periods[0];\n    // Add the unit onto the temperature.\n    weather.temperature = `${weather.temperature}${weather.temperatureUnit}`;\n    weather.link =\n      coda.withQueryParams(\"https://forecast.weather.gov/MapClick.php\", {\n        lat: latitude,\n        lon: longitude,\n      });\n    return weather;\n  },\n});\n\n// A helper function that gets the forecast URL for a given location.\nasync function getForecastUrl(latitude: number, longitude: number,\n  context: coda.ExecutionContext): Promise<string> {\n  try {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: `https://api.weather.gov/points/${latitude},${longitude}`,\n    });\n    let data = response.body;\n    return data.properties.forecast;\n  } catch (error) {\n    // Check if the error is due to the location being outside the US.\n    if (error.statusCode === 404) {\n      let statusError = error as coda.StatusCodeError;\n      let message = statusError.body?.detail;\n      if (message) {\n        throw new coda.UserVisibleError(message);\n      }\n    }\n    throw error;\n  }\n}\n\npack.addNetworkDomain(\"weather.gov\");\n{% endraw %}\n```",
    "With link matching": "A card that can be created manually or automatically when pasting a link. This sample returns a card with the details of a task in Todoist.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the card, including all of metadata what specifically to\n// highlight in the card.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  // Which property's content to show in the title of the card.\n  displayProperty: \"name\",\n  // Which property contains the link to open when the card is clicked.\n  linkProperty: \"url\",\n  // Which property's content to show in the body of the card.\n  snippetProperty: \"description\",\n  // Which properties' content to show in the subtitle of the card.\n  subtitleProperties: [\"priority\"],\n});\n\n// Formula that renders a card for a task given it's URL. This will be shown a\n// \"Card\" in the Pack's list of building blocks, but is also a regular formula\n// that can be used elsewhere.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      priority: task.priority,\n      id: task.id,\n    };\n  },\n});\n\n// Regular expressions that match Todoist task URLs. Used to match and parse\n// relevant URLs.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n// Add a column format for the Task formula, to define which URLs it should\n// trigger for. This also makes it easier to use the formula in a table column.\npack.addColumnFormat({\n  // How the option will show in the link and column type dialogs.\n  name: \"Task\",\n  // The formula that generates the card.\n  formulaName: \"Task\",\n  // The set of regular expressions that match Todoist task URLs.\n  matchers: TaskUrlPatterns,\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```\n\n[]\n\nnav: Column formats\ndescription: Samples that show how to create a column format.\nicon: material/table-column\n\n[]"
  },
  "Column format samples": {
    "Template": "The basic structure of a column format.\n\n```\n{% raw %}\npack.addColumnFormat({\n  name: \"My Column Format\",\n  instructions: \"My description.\",\n  formulaName: \"MyFormula\",\n  matchers: [\n    // TODO: If formatting a URL, add a regular expression that matches it.\n  ],\n});\n{% endraw %}\n```",
    "Text (Reverse)": "A column format that formats text. This sample displays the text in the cell in reverse.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column in reverse order.\npack.addColumnFormat({\n  name: \"Reversed Text\",\n  instructions: \"Whatever text you enter into this column will be reversed.\",\n  // The formula \"Reverse()\" (defined below) will be run on the content of the\n  // column to determine it's display value.\n  formulaName: \"Reverse\",\n});\n\n// Adds a formula to this Pack to reverse text. It is used by the column format\n// above, but can also be used on it's own anywhere in the doc.\npack.addFormula({\n  resultType: coda.ValueType.String,\n  name: \"Reverse\",\n  description: \"Reverses text.\",\n  parameters: [\n    // Formulas used in column formats can have only one required parameter.\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"input\",\n      description: \"The text to reverse.\",\n    }),\n    // Optional parameters can't be set when run as a column format.\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"byWord\",\n      description: \"Reverse the text word-by-word.\",\n      suggestedValue: false,\n      optional: true,\n    }),\n  ],\n  execute: async function ([input, byWord = false]) {\n    let separator = \"\";\n    if (byWord) {\n      separator = \" \";\n    }\n    return input.split(separator).reverse().join(separator);\n  },\n});\n{% endraw %}\n```",
    "Text (Roman Numeral)": "A column format that formats a number as text. This sample displays the number in the cell as a Roman numeral.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as Roman numerals.\npack.addColumnFormat({\n  name: \"Roman Numeral\",\n  instructions: \"Displays the number as a Roman numeral.\",\n  formulaName: \"RomanNumeral\",\n});\n\n// Adds a formula to this Pack to convert a number to a Roman numeral. It is\n// used by the column format above, but can also be used on it's own anywhere in\n// the doc.\npack.addFormula({\n  name: \"RomanNumeral\",\n  description: \"Converts a number to the equivalent Roman numeral.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"value\",\n      description: \"The number to convert.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([value], context) {\n    let pairs = Object.entries(NumberMapping);\n    // Sort the pairs by the number, largest to smallest.\n    pairs.sort((a, b) => b[1] - a[1]);\n    let result = \"\";\n    for (let [roman, num] of pairs) {\n      while (value >= num) {\n        result += roman;\n        value -= num;\n      }\n    }\n    return result;\n  },\n});\n\nconst NumberMapping = {\n  I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400,\n  D: 500, CM: 900, M: 1000,\n};\n{% endraw %}\n```",
    "Text (Progress Bar)": "A column format that formats a number as graphic. This sample displays the number in the cell as a progress bar.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as a progress bar.\npack.addColumnFormat({\n  name: \"Progress Bar\",\n  instructions: \"Draws a progress bar with the given percentage.\",\n  formulaName: \"ProgressBar\",\n});\n\n// Adds a formula to this Pack to draw a number as a progress bar. It is used by\n// the column format above, but can also be used on it's own anywhere in the\n// doc.\npack.addFormula({\n  name: \"ProgressBar\",\n  description: \"Draws a progress bar.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"percentage\",\n      description: \"The percentage complete, as a number between 0 and 1.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([percentage], context) {\n    if (percentage < 0 || percentage > 1) {\n      throw new coda.UserVisibleError(\"Percentage must be between 0 and 1.\");\n    }\n    let chars = Math.floor(percentage * 10);\n    return \"\".repeat(chars) + \"\".repeat(10 - chars);\n  },\n});\n{% endraw %}\n```",
    "Image (Cats)": "A column format that formats text as an image. This sample displays the text in the cell as an overlay on a random image of a cat.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text], context) {\n    let url = \"https://cataas.com/cat/says/\" + encodeURIComponent(text);\n    url = coda.withQueryParams(url, {\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");\n{% endraw %}\n```",
    "Rich data (Todoist)": "A column format that formats a URL as rich data. This sample displays the URL of the Todoist task in the cell as a rich data chip.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\n\n// Regular expressions that match Todoist task URLs. Used by the column format\n// and also the formula that powers it.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\nexport const pack = coda.newPack();\n\n// Add a column format that displays a task URL as rich metadata.\npack.addColumnFormat({\n  name: \"Task\",\n  // The formula \"Task\" below will get run on the cell value.\n  formulaName: \"Task\",\n  // If the first values entered into a new column match these patterns then\n  // this column format will be automatically applied.\n  matchers: TaskUrlPatterns,\n});\n\n// A schema defining the rich metadata to be returned.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n});\n\n// Formula that looks up rich metadata about a task given it's URL. This is used\n// by the \"Task\" column format above, but is also a regular formula that can be\n// used elsewhere.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      id: task.id,\n    };\n  },\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```\n\n[]\n\nnav: Data types\ndescription: Samples that show how to return values of various data types.\nicon: material/order-alphabetical-ascending\n\n[]"
  },
  "Data type samples": {
    "Template (String)": "The basic structure of a formula that returns a string.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return \"\";\n  },\n});\n{% endraw %}\n```",
    "Template (Number)": "The basic structure of a formula that returns a number.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return 0;\n  },\n});\n{% endraw %}\n```",
    "Template (Boolean)": "The basic structure of a formula that returns a boolean.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return true;\n  },\n});\n{% endraw %}\n```",
    "Template (Array)": "The basic structure of a formula that returns an array.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.String,\n  }),\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return [];\n  },\n});\n{% endraw %}\n```",
    "Template (Object)": "The basic structure of a formula that returns an object.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ThingSchema,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return {};\n  },\n});\n{% endraw %}\n```",
    "Percent": "A formula that returns a number formatted as a percent value. This sample converts a number of slices of pizza into a percentage eaten.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that converts slices of a pizza into a percentage eaten.\npack.addFormula({\n  name: \"PizzaEaten\",\n  description: \"Calculates what percentage of a pizza was eaten.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"slices\",\n      description: \"How many slices were eaten.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Percent,\n  execute: async function ([slices], context) {\n    return slices / 8;\n  },\n});\n{% endraw %}\n```",
    "Currency": "A formula that returns a number formatted as a currency value. This sample converts from another currency to US dollars.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"exchangerate.host\");\n\npack.addFormula({\n  name: \"ToUSD\",\n  description: \"Convert from a different currency to US dollars.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"amount\",\n      description: \"The amount to convert.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The currency to convert from.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  schema: {\n    type: coda.ValueType.Number,\n    codaType: coda.ValueHintType.Currency,\n    // Ensure the currency symbol displayed with the result is \"$\".\n    currencyCode: \"USD\",\n    // Only show two decimal places (no fractional pennies).\n    precision: 2,\n  },\n  execute: async function ([amount, from], context) {\n    let url = coda.withQueryParams(\"https://api.exchangerate.host/latest\", {\n      base: from,\n      amount: amount,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let rates = response.body.rates;\n    return rates.USD;\n  },\n});\n{% endraw %}\n```",
    "Date and time": "A formula that returns a date and time, passed as a string. This sample adds five minutes onto the given date and time.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that adds five minutes to an input date and time.\npack.addFormula({\n  name: \"FiveMinsLate\",\n  description: \"Adds five minutes to the input date and time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"input\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  // Return the result as the number of seconds since the epoch.\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Time,\n  execute: async function ([input], context) {\n    let seconds = input.getTime() / 1000;\n    seconds += 5 * 60; // Add five minutes, as seconds.\n    return seconds;\n  },\n});\n{% endraw %}\n```",
    "Markdown": "A formula that returns markdown content. This sample returns the contents of the README.md file from a GitHub repository.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the contents of GitHub repo's README.md file as markdown.\npack.addFormula({\n  name: \"GetReadme\",\n  description: \"Gets the content of a GitHub repo's README.md file.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"repo\",\n      description: \"The repo to read from.\",\n      suggestedValue: \"coda/packs-sdk\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Markdown,\n  execute: async function ([repo], context) {\n    let url = `https://raw.githubusercontent.com/${repo}/HEAD/README.md`;\n    let result = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return result.body;\n  },\n});\n\npack.addNetworkDomain(\"raw.githubusercontent.com\");\n{% endraw %}\n```",
    "HTML": "A formula that returns HTML content. This sample returns HTML with every word of the input string bolded.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns HTML with every other word of the input text bolded.\npack.addFormula({\n  name: \"AlternatingBold\",\n  description: \"Bold every other word.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to bold.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Html,\n  execute: async function ([text], context) {\n    let words = text.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n      if (i % 2 === 0) {\n        words[i] = `<b>${words[i]}</b>`;\n      }\n    }\n    return words.join(\" \");\n  },\n});\n{% endraw %}\n```",
    "Embed": "A formula that a URL to embed. This sample returns an embed of the infamous YouTube video for &quot;Never Gonna Give You Up&quot; by Rick Astley.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the infamous YouTube video by Rick Astley as an embed.\npack.addFormula({\n  name: \"Rickroll\",\n  description: \"Embeds the video \\\"Never Gonna Give You Up\\\".\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Embed,\n  execute: async function ([], context) {\n    return \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n  },\n});\n{% endraw %}\n```",
    "Image": "A formula that returns an image, as a reference. This sample returns a random photo of a cat.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");\n{% endraw %}\n```\n\n[]\n\nnav: Dates and times\ndescription: Samples that show how to work with dates and times.\nicon: material/calendar-clock\n\n[]"
  },
  "Dates and time samples": {
    "Local date": "A formula that requires getting a date in the document&#x27;s timezone. This sample determines if the year of a given date would make for good New Years Eve glasses (has two or more zeros).\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"GoodNYEGlasses\",\n  description: \"Determines if a date is good for New Years Eve glasses \" +\n    \"(the year contains two zeros).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The input date.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([date], context) {\n    // Format the JavaScript Date into a four-digit year.\n    let formatted = date.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      year: \"numeric\",\n    });\n    // Extract all of the zeros from the year.\n    let zeros = formatted.match(/0/g);\n    return zeros?.length >= 2;\n  },\n});\n{% endraw %}\n```",
    "Local time": "A formula that requires getting a time in the document&#x27;s timezone. This sample shows a time using the military format (ex: &quot;0900 hours&quot;).\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Displays a time using military conventions. The result is a string (text)\n// value.\npack.addFormula({\n  name: \"ToMilitaryTime\",\n  description: \"Displays a time in military time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"time\",\n      description: \"The input time.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([time], context) {\n    // Format the JavaScript Date into 2-digit, 24 hour time.\n    let formatted = time.toLocaleTimeString(\"en-US\", {\n      timeZone: context.timezone,  // Use the timezone of the doc (important!).\n      hour12: false, // Use 24 hour time.\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n    // Remove the colon separating the hours and minutes.\n    formatted = formatted.replace(\":\", \"\");\n    return formatted + \" hours\";\n  },\n});\n{% endraw %}\n```",
    "Local date and time": "A formula that requires getting a date and time in the document&#x27;s timezone. This sample determines if all of the digits are the same (ex: 1/1/11 1:11).\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"SameDigit\",\n  description: \"Determines if a date and time only contain a single digit.\" +\n    \"For example, 1/1/11 1:11.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"dateAndTime\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([dateAndTime], context) {\n    // Format the JavaScript Date to only include the monday, day, year, hour\n    // and minute as numbers.\n    let formatted = dateAndTime.toLocaleString(\"en-US\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      month: \"numeric\",\n      day: \"numeric\",\n      year: \"2-digit\",\n      hour: \"numeric\",\n      minute: \"numeric\",\n    });\n    // Extract the digits from the formatted date.\n    let digits = formatted.match(/\\d/g);\n    // Get the unique set of digits.\n    let unique = new Set(digits);\n    return unique.size === 1;\n  },\n});\n{% endraw %}\n```",
    "Send to API": "A formula that requires sending a date to an API. This sample use the Calendarific API to get the holidays on a given date.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema to represent a holiday.\nconst HolidaySchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    description: { type: coda.ValueType.String },\n    locations: { type: coda.ValueType.String },\n    type: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n  },\n  displayProperty: \"name\",\n});\n\n// Gets the holidays happening in the selected country on a given day.\npack.addFormula({\n  name: \"Holidays\",\n  description: \"Get the holidays (if any) on a given day.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"country\",\n      description: \"Which country's holidays to return (ex: US).\",\n      // Auto-complete the valid country identifiers using the API.\n      autocomplete: async function (context, search) {\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://calendarific.com/api/v2/countries\",\n        });\n        let countries = response.body.response.countries;\n        return coda.autocompleteSearchObjects(\n          search,\n          countries,\n          \"country_name\",\n          \"iso-3166\",\n          );\n      },\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"Which date to lookup.\",\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: HolidaySchema,\n  execute: async function ([country, date], context) {\n    // Create a formatter that outputs a numeric day, month, and year.\n    let formatter = new Intl.DateTimeFormat(\"en\", {\n      timeZone: context.timezone, // Use the doc's timezone (important!)\n      year: \"numeric\",\n      month: \"numeric\",\n      day: \"numeric\",\n    });\n\n    // Format the date into individual parts.\n    let parts = formatter.formatToParts(date);\n\n    // Find the day, month, and year parts.\n    let day = parts.find(part => part.type === \"day\").value;\n    let month = parts.find(part => part.type === \"month\").value;\n    let year = parts.find(part => part.type === \"year\").value;\n\n    // Make a request to the Calendarific API.\n    let url = coda.withQueryParams(\"https://calendarific.com/api/v2/holidays\", {\n      country: country,\n      year: year,\n      month: month,\n      day: day,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // Return the results.\n    return response.body.response.holidays;\n  },\n});\n\n// Calendarific requires an API key as a query parameter.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\npack.addNetworkDomain(\"calendarific.com\");\n{% endraw %}\n```",
    "Time math": "A formula that computes a relative time. This sample adds five minutes onto an input date and time.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that adds five minutes to an input date and time.\npack.addFormula({\n  name: \"FiveMinsLate\",\n  description: \"Adds five minutes to the input date and time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"input\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  // Return the result as the number of seconds since the epoch.\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Time,\n  execute: async function ([input], context) {\n    let seconds = input.getTime() / 1000;\n    seconds += 5 * 60; // Add five minutes, as seconds.\n    return seconds;\n  },\n});\n{% endraw %}\n```\n\n[]\n\nnav: Dynamic sync tables\ndescription: Samples that show how to create a dynamic sync table.\nicon: material/cloud-sync-outline\n\n[]"
  },
  "Dynamic sync table samples": {
    "Template": "```\n{% raw %}\npack.addDynamicSyncTable({\n  name: \"MyThings\",\n  description: \"My description.\",\n  identityName: \"${1}\",\n  listDynamicUrls: async function (context) {\n    // TODO: Fetch the list of datasets the user can connect to.\n    let datasets = [];\n    // TODO: Replace \"name\" and \"url\" below with correct JSON keys.\n    return coda.autocompleteSearchObjects(undefined, datasets, \"name\", \"url\");\n  },\n  getName: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and return the name.\n    return \"Table Name\";\n  },\n  getSchema: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and use it to construct a schema.\n    let schema = coda.makeObjectSchema({\n      properties: {},\n      displayProperty: \"\",\n      idProperty: \"\",\n      featuredProperties: [],\n    });\n    return schema;\n  },\n  getDisplayUrl: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and return a user-friendly URL.\n    return \"\";\n  },\n  formula: {\n    name: \"Sync$1\",\n    description: \"Syncs the data.\",\n    parameters: [\n      // TODO: Add parameters.\n    ],\n    execute: async function (args, context) {\n      let datasetUrl = context.sync.dynamicUrl!;\n      // TODO: Unpack the parameter values.\n      let [] = args;\n      // TODO: Fetch the rows.\n      let rows = [];\n      for (let row of rows) {\n        // TODO: If required, adjust the row to match the schema.\n      }\n      return {\n        result: rows,\n      };\n    },\n  },\n});\n{% endraw %}\n```",
    "With URL list": "A sync table that presents a list of URLs to select from. This sample shows responses to a Typeform form.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When listing forms, the maximum to return.\nconst MaxForms = 200;\n\n// How many responses to fetch per-page.\nconst PageSize = 100;\n\n// Add a dynamic sync table for form responses.\npack.addDynamicSyncTable({\n  name: \"FormResponses\",\n  description: \"Responses to a form.\",\n  identityName: \"FormResponse\",\n\n  // Returns the URLs of the available forms. The user will select one when they\n  // add the table to their doc. The selected URL will be passed as\n  // `context.sync.dynamicUrl` to other methods.\n  listDynamicUrls: async function (context) {\n    let forms = await getForms(context);\n    let results = [];\n    for (let form of forms) {\n      // Each result should include the name and URL of the form.\n      results.push({\n        display: form.title,\n        // Using the API URL of the form, not the browser URL. This makes it\n        // easier to use the URL in the code, and `getDisplayUrl` below can\n        // show the browser URL to the user.\n        value: form.self.href,\n      });\n    }\n    return results;\n  },\n\n  // Like listDynamicUrls above, but to allow the user to search for a form by\n  // name. The second parameter is the search term the user entered.\n  searchDynamicUrls: async function (context, search) {\n    let forms = await getForms(context, search);\n    let results = [];\n    for (let form of forms) {\n      results.push({\n        display: form.title,\n        value: form.self.href,\n      });\n    }\n    return results;\n  },\n\n  // Returns the name of the table, given the selected URL.\n  getName: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form.title;\n  },\n\n  // Returns the display version of the selected URL.\n  getDisplayUrl: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form._links.display;\n  },\n\n  // Returns the schema of the table, given the selected URL.\n  getSchema: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n\n    // These properties are the same for all forms.\n    let properties: coda.ObjectSchemaProperties = {\n      submittedAt: {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.DateTime,\n      },\n      responseId: {\n        type: coda.ValueType.String,\n      },\n    };\n    // Use them as the display value and ID of the rows.\n    let displayProperty = \"submittedAt\";\n    let idProperty = \"responseId\";\n\n    // For each field in the form, add a property to the schema.\n    let featuredProperties = [];\n    for (let field of form.fields) {\n      // Format the field name into a valid property name.\n      let name = getPropertyName(field);\n      // Generate a schema for the field and add it to the set of properties.\n      properties[name] = getPropertySchema(field);\n      // Mark the property as featured (included in the table by default).\n      featuredProperties.push(name);\n    }\n\n    // Return the schema for each row.\n    return coda.makeObjectSchema({\n      properties: properties,\n      displayProperty: displayProperty,\n      idProperty: idProperty,\n      featuredProperties: featuredProperties,\n    });\n  },\n\n  // The formula that syncs the records.\n  formula: {\n    name: \"SyncResponses\",\n    description: \"Sync the form responses\",\n    parameters: [],\n    execute: async function ([], context) {\n      let formUrl = context.sync.dynamicUrl;\n\n      // Retrieve the token to continue from, if any.\n      let pageToken = context.sync.continuation?.token || null;\n\n      // Construct the API URL.\n      let url = coda.withQueryParams(formUrl + \"/responses\", {\n        page_size: PageSize,\n        before: pageToken,\n      });\n\n      // Fetch a page of responses.\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n        // Disable HTTP caching, so we always get the latest results.\n        cacheTtlSecs: 0,\n      });\n      let formResponses = response.body.items;\n\n      // Reformat each response to match the schema.\n      let rows = [];\n      for (let formResponse of formResponses) {\n        // Include the metadata common to all forms.\n        let row = {\n          submittedAt: formResponse.submitted_at,\n          responseId: formResponse.response_id,\n        };\n\n        // For each answer, add it to the row.\n        for (let answer of formResponse.answers) {\n          // Get the key to return the value in.\n          let key = getPropertyKey(answer.field);\n          let value = getPropertyValue(answer);\n          row[key] = value;\n        }\n        rows.push(row);\n      }\n\n      // Determine if we need to fetch more pages.\n      let continuation;\n      if (formResponses.length > 0) {\n        // Continue onward from the token of the last response.\n        let lastToken = formResponses[formResponses.length - 1].token;\n        continuation = {\n          token: lastToken,\n        };\n      }\n\n      // Return the rows and the continuation, if any.\n      return {\n        result: rows,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Gets the available forms, optionally filtered by a search string.\nasync function getForms(context: coda.ExecutionContext, search?: string) {\n  let url = coda.withQueryParams(\"https://api.typeform.com/forms\", {\n    search: search,\n    page_size: MaxForms,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.items;\n}\n\n// Get metadata about a form given it's URL.\nasync function getForm(context, url) {\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n    // Disable HTTP caching, so we always get the latest result.\n    cacheTtlSecs: 0,\n  });\n  return response.body;\n}\n\n// Generates a property name given a field title.\nfunction getPropertyName(field) {\n  return (\n    field.title\n      // Replace placeholders with an X.\n      .replace(/\\{\\{.*?\\}\\}/g, \"X\")\n  );\n}\n\n// Generates a property schema based on a Typeform field.\nfunction getPropertySchema(field): coda.Schema & coda.ObjectSchemaProperty {\n  let schema: any = {\n    // Use the field's full title as the column name.\n    displayName: field.title,\n    // The sync formula will return the value keyed using the field's ID.\n    fromKey: getPropertyKey(field),\n  };\n\n  // Set the schema type depending on the field type.\n  switch (field.type) {\n    case \"yes_no\":\n      schema.type = coda.ValueType.Boolean;\n      break;\n    case \"number\":\n    case \"opinion_scale\":\n    case \"rating\":\n      schema.type = coda.ValueType.Number;\n      break;\n    case \"date\":\n      schema.type = coda.ValueType.String;\n      schema.codaType = coda.ValueHintType.Date;\n      break;\n    case \"multiple_choice\":\n      let isMultiselect = field.properties.allow_multiple_selection;\n      if (isMultiselect) {\n        schema.type = coda.ValueType.Array;\n        schema.items = {\n          type: coda.ValueType.String,\n        };\n      } else {\n        schema.type = coda.ValueType.String;\n      }\n      break;\n    default:\n      // Default to strings.\n      schema.type = coda.ValueType.String;\n  }\n\n  return schema;\n}\n\n// Gets the key to use for this field when returning the value in the sync\n// formula.\nfunction getPropertyKey(field) {\n  return field.id;\n}\n\n// Gets the value from a Typeform answer.\nfunction getPropertyValue(answer) {\n  switch (answer.type) {\n    case \"choice\":\n      return answer.choice.label;\n    case \"choices\":\n      return answer.choices.labels;\n    default:\n      // The value is stored in a field with the same name as the type of the\n      // answer.\n      return answer[answer.type];\n  }\n}\n\n// Configure per-user authentication, using OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // See: https://developer.typeform.com/get-started/applications/\n  authorizationUrl: \"https://api.typeform.com/oauth/authorize\",\n  tokenUrl: \"https://api.typeform.com/oauth/token\",\n  // See: https://developer.typeform.com/get-started/scopes/\n  scopes: [\"forms:read\", \"responses:read\", \"accounts:read\"],\n\n  // Get the name of the account from the Typeform API.\n  getConnectionName: async function (context) {\n    let url = \"https://api.typeform.com/me\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let profile = response.body;\n    return profile.alias;\n  },\n});\n\n// Allow requests to the typeform.com domain.\npack.addNetworkDomain(\"typeform.com\");\n{% endraw %}\n```",
    "With grouped URL list": "A sync table that presents a list of URLs to select from, grouped into folders. This sample shows data from Open Data NY (data.ny.gov), which is powered by Socrata.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// The domain to connect to. Can be swapped for other domains hosting Socrata.\nconst Domain = \"data.ny.gov\";\n\n// The max number of columns to include in the sync table by default.\nconst MaxFeaturedColumns = 50;\n\n// How many rows to scan when determining the which columns to feature.\nconst TableScanMaxRows = 100;\n\n// How many rows to fetch per-page.\nconst PageSize = 100;\n\n// The maximum number of datasets to return in a search.\nconst MaxDatasets = 10000;\n\n// A regular expression matching a dataset.\nconst DatasetUrlRegex = new RegExp(`^https?://${Domain}/.*/([^?#]+)`);\n\n// Schema for an address (part of a location).\nconst AddressSchema = coda.makeObjectSchema({\n  properties: {\n    address: { type: coda.ValueType.String },\n    city: { type: coda.ValueType.String },\n    state: { type: coda.ValueType.String },\n    zip: { type: coda.ValueType.String },\n  },\n  displayProperty: \"address\",\n});\n\n// Schema for a location (used for locations and points).\nconst LocationSchema = coda.makeObjectSchema({\n  properties: {\n    coordinates: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.Number },\n    },\n    latitude: { type: coda.ValueType.Number },\n    longitude: { type: coda.ValueType.Number },\n    address: { ...AddressSchema, fromKey: \"human_address\" },\n  },\n  displayProperty: \"coordinates\",\n});\n\n// A mapping from Socrata types to Coda schemas.\nconst TypeSchemaMap: Record<string, coda.Schema> = {\n  text: { type: coda.ValueType.String },\n  number: { type: coda.ValueType.Number },\n  checkbox: { type: coda.ValueType.Boolean },\n  calendar_date: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Date,\n  },\n  location: LocationSchema,\n  point: LocationSchema,\n  url: { type: coda.ValueType.String, codaType: coda.ValueHintType.Url },\n};\n\n// A base row schema, extended for each dataset.\nconst BaseRowSchema = coda.makeObjectSchema({\n  properties: {\n    rowId: { type: coda.ValueType.String, fromKey: \":id\" },\n  },\n  idProperty: \"rowId\",\n  displayProperty: \"rowId\",\n});\n\n\n// Allow requests to the domain.\npack.addNetworkDomain(Domain);\n\n// Use a system-wide application token to get additional quota.\n// https://dev.socrata.com/docs/app-tokens.html\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-App-Token\",\n});\n\n// A dynamic sync table for the rows of a dataset.\npack.addDynamicSyncTable({\n  name: \"PublicDataset\",\n  identityName: \"DatasetRow\",\n  entityName: \"Row\",\n  // If new columns are added later, don't automatically feature them.\n  defaultAddDynamicColumns: false,\n\n  // Allow the user to browse the datasets by category.\n  listDynamicUrls: async function (context, category) {\n    if (!category) {\n      // Return the list of categories.\n      let categories = await getCategories(context);\n      return categories.map(category => {\n        return {\n          display: category,\n          value: category,\n          hasChildren: true,\n        };\n      });\n    }\n\n    // Return all the datasets in that category.\n    let datasets = await searchDatasets(context, {\n      categories: category,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"page_views_last_month\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  searchDynamicUrls: async function (context, search) {\n    let datasets = await searchDatasets(context, {\n      q: search,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"relevance\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  getName: async function (context) {\n    let dataset = await getDataset(context);\n    return dataset.name;\n  },\n\n  getSchema: async function (context) {\n    let dataset = await getDataset(context);\n\n    // Copy the base schema.\n    let schema: coda.GenericObjectSchema = {\n      ...BaseRowSchema,\n    };\n\n    // Add a schema property for each column.\n    for (let column of dataset.columns) {\n      let name = column.name;\n      let fieldName = column.fieldName;\n      let dataType = column.dataTypeName;\n      let description = column.description;\n\n      if (fieldName.startsWith(\":\")) {\n        // Skip internal fields.\n        continue;\n      }\n\n      let fieldSchema = TypeSchemaMap[dataType];\n      if (!fieldSchema) {\n        throw new Error(\"Couldn't find schema for column type: \" + dataType);\n      }\n\n      schema.properties[fieldName] = {\n        ...fieldSchema,\n        displayName: name,\n        description: description,\n      };\n    }\n\n    // Determine which columns to feature.\n    schema.featuredProperties = await getFeatured(dataset, context);\n\n    // Add attribution information.\n    schema.attribution = getAttribution(dataset);\n\n    return schema;\n  },\n\n  getDisplayUrl: async function (context) {\n    return context.sync.dynamicUrl;\n  },\n\n  formula: {\n    name: \"SyncDataset\",\n    description: \"Syncs the dataset.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"search\",\n        description: \"If specified, only rows containing this search term \" +\n          \"will be included.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A SoQL $where clause to use to filter the results. \" +\n          \"https://dev.socrata.com/docs/queries/where.html\",\n        optional: true,\n      }),\n    ],\n    execute: async function ([search, filter], context) {\n      let dataset = await getDataset(context);\n      let offset = context.sync.continuation?.offset as number || 0;\n\n      // Only fetch the selected columns.\n      let fields = coda.getEffectivePropertyKeysFromSchema(context.sync.schema);\n\n      // Fetch the row data.\n      let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n      let url = coda.withQueryParams(baseUrl, {\n        $select: fields.join(\",\"),\n        $q: search,\n        $where: filter,\n        $limit: PageSize,\n        $offset: offset,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let rows = response.body;\n\n      // Transform the rows to match the schema.\n      for (let row of rows) {\n        for (let [key, value] of Object.entries(row)) {\n          row[key] = formatValue(value);\n        }\n      }\n\n      let continution = null;\n      if (rows.length > 0) {\n        // Keep fetching rows until we get an empty page.\n        continution = { offset: offset + PageSize };\n      }\n\n      return {\n        result: rows,\n        continuation: continution,\n      };\n    },\n  },\n});\n\n/**\n * Reformat a row value to match the schema.\n */\nfunction formatValue(value) {\n  if (typeof value === \"object\") {\n    let obj = value as Record<string, any>;\n    if (obj.url) {\n      // Pull up the URL.\n      value = obj.url;\n    } else if (obj.type === \"Point\") {\n      // Format point to LocationSchema.\n      value = {\n        latitude: obj.coordinates[1],\n        longitude: obj.coordinates[0],\n        // A point's coordinates are returned as x,y instead of lat,long.\n        coordinates: obj.coordinates.reverse(),\n      };\n    } else if (obj.latitude && obj.longitude) {\n      // Format location to LocationSchema.\n      value = {\n        ...obj,\n        coordinates: [obj.latitude, obj.longitude],\n      };\n    }\n  }\n  return value;\n}\n\n/**\n * Get the list of dataset categories.\n */\nasync function getCategories(context: coda.ExecutionContext):\n  Promise<string[]> {\n  let baseUrl = `https://${Domain}/api/catalog/v1/domain_categories`;\n  let url = coda.withQueryParams(baseUrl, {\n    domains: Domain,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => result.domain_category);\n}\n\n/**\n * Search for datasets, using a flexible set of parameters.\n */\nasync function searchDatasets(context: coda.ExecutionContext,\n  params: Record<string, any>): Promise<DatasetResult[]> {\n  let url = coda.withQueryParams(`https://${Domain}/api/catalog/v1`, params);\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => {\n    return {\n      ...result.resource,\n      ...result,\n    };\n  });\n}\n\n/**\n * Get a dataset by ID.\n */\nasync function getDataset(context: coda.SyncExecutionContext):\n  Promise<Dataset> {\n  let datasetUrl = context.sync.dynamicUrl;\n  let datasetId = getDatasetId(datasetUrl);\n  let url = `https://${Domain}/api/views/${datasetId}.json`;\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n/**\n * Extract the ID of the dataset from it's URL.\n */\nfunction getDatasetId(url: string): string {\n  let match = url.match(DatasetUrlRegex);\n  if (!match) {\n    throw new coda.UserVisibleError(\"Invalid dataset URL: \" + url);\n  }\n  return match[1];\n}\n\n/**\n * Determine which rows to feature (include in the table by default) for a given\n * dataset.\n */\nasync function getFeatured(dataset: Dataset, context: coda.ExecutionContext):\n  Promise<string[]> {\n  // Fetch some of the first rows from the dataset.\n  let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n  let url = coda.withQueryParams(baseUrl, {\n    $limit: TableScanMaxRows,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  let rows = response.body;\n\n  // Count how many times each column has a value.\n  let columnCount: Record<string, number> = {};\n  for (let row of rows) {\n    for (let [key, value] of Object.entries(row)) {\n      if (!columnCount[key]) {\n        columnCount[key] = 0;\n      }\n      if (value) {\n        columnCount[key]++;\n      }\n    }\n  }\n\n  // Return the list of columns that have at least one value in the scanned\n  // rows, up to a defined maximum.\n  return dataset.columns.map(column => column.fieldName)\n    .filter(column => columnCount[column] > 0)\n    .filter(column => !column.startsWith(\":\"))\n    .slice(0, MaxFeaturedColumns);\n}\n\n/**\n * Get the attribution node for a given dataset.\n */\nfunction getAttribution(dataset: Dataset): coda.AttributionNode[] {\n  if (!dataset.attribution) {\n    return null;\n  }\n  let node;\n  if (dataset.attributionLink) {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Link,\n      anchorText: dataset.attribution,\n      anchorUrl: dataset.attributionLink,\n    });\n  } else {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Text,\n      text: dataset.attribution,\n    });\n  }\n  return [node];\n}\n\n\n// A dataset search result.\ninterface DatasetResult {\n  name: string;\n  link: string;\n}\n\n// The dataset metadata.\ninterface Dataset {\n  id: string;\n  name: string;\n  description: string;\n  columns: DatasetColumn[];\n  attribution: string;\n  attributionLink: string;\n}\n\n// A dataset column definition.\ninterface DatasetColumn {\n  name: string;\n  description: string;\n  fieldName: string;\n  dataTypeName: string;\n}\n{% endraw %}\n```\n\n[]\n\nnav: Fetcher\ndescription: Samples that show how to fetch data from an external source.\nicon: fontawesome/solid/cloud-arrow-down\n\n[]"
  },
  "Fetcher samples": {
    "Template (GET)": "The basic structure of a GET request.\n\n```\n{% raw %}\nlet response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://example.com\",\n});\nlet data = response.body;\n{% endraw %}\n```",
    "Template (POST)": "The basic structure of a JSON POST request.\n\n```\n{% raw %}\nlet payload = {\n  // TODO: Construct the JSON that the API expects.\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://example.com\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(payload),\n});\nlet data = response.body;\n{% endraw %}\n```",
    "Fetch JSON": "A formula that gets a JSON value. This sample generates random bacon-themed Lorem Ipsum text.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When using the fetcher, this is the domain of the API that your pack makes\n// fetcher requests to.\npack.addNetworkDomain(\"baconipsum.com\");\n\n// This line adds a new formula to this Pack.\npack.addFormula({\n  name: \"BaconIpsum\",\n  description: \"Returns meat-themed lorem ipsum copy.\",\n  parameters: [], // No parameters required.\n  resultType: coda.ValueType.String,\n\n  // This function is declared async to that is can wait for the fetcher to\n  // complete. The context parameter provides access to the fetcher.\n  execute: async function ([], context) {\n    let url = \"https://baconipsum.com/api/?type=meat-and-filler\";\n\n    // The fetcher's fetch method makes the request. The await keyword is used\n    // to wait for the API's response before continuing on through the code.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // The API returns an array of strings, which is automatically parsed by\n    // the fetcher into a JavaScript object.\n    let paragraphs = response.body;\n\n    // Return the paragraphs separated by a blank line.\n    return paragraphs.join(\"\\n\\n\");\n  },\n});\n{% endraw %}\n```",
    "Fetch binary data": "A formula that fetches binary data. This sample gets image data and calculates the file size.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// Formula that calculates the file size of an image.\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an image, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description:\n        \"The image to operate on. Not compatible with Image URL columns.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([imageUrl], context) {\n    // Throw an error if the image isn't Coda-hosted. Image URL columns can\n    // contain images on any domain, but by default Packs can only access image\n    // attachments hosted on codahosted.io.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n    // Fetch the image content.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true, // Required when fetching binary content.\n    });\n    // The binary content of the response is returned as a Node.js Buffer.\n    // See: https://nodejs.org/api/buffer.html\n    let buffer = response.body as Buffer;\n    // Return the length, in bytes.\n    return buffer.length;\n  },\n});\n{% endraw %}\n```",
    "GraphQL query": "A sync table that queries a GraphQL API. This sample lists the products in a mock online store.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\nconst PageSize = 20;\nconst OneDaySecs = 24 * 60 * 60;\n\nconst ProductSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      type: coda.ValueType.String,\n      fromKey: \"title\",\n    },\n    description: { type: coda.ValueType.String },\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageAttachment,\n    },\n    link: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n      fromKey: \"onlineStoreUrl\",\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"image\", \"link\"],\n});\n\npack.addNetworkDomain(\"mock.shop\");\n\npack.addSyncTable({\n  name: \"Products\",\n  description: \"Lists the products available in the store.\",\n  identityName: \"Product\",\n  schema: ProductSchema,\n  formula: {\n    name: \"SyncProducts\",\n    description: \"Syncs the data.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"name\",\n        description: \"If specified, only matching products will be included.\",\n        optional: true,\n      }),\n    ],\n    execute: async function (args, context) {\n      let [name] = args;\n      let cursor = context.sync.continuation?.cursor;\n\n      let filters = [\n        `first: ${PageSize}`,\n      ];\n      if (name) {\n        filters.push(`query: \"title:${name}\"`);\n      }\n      if (cursor) {\n        filters.push(`after: \"${cursor}\"`);\n      }\n\n      let payload = {\n        query: `{\n          products(${filters.join(\" \")}) {\n            edges {\n              cursor\n              node {\n                id\n                title\n                description\n                onlineStoreUrl\n                featuredImage {\n                  url\n                }\n              }\n            }\n          }\n        }\n        `,\n      };\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://mock.shop/api\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n        // Force caching of a POST response.\n        forceCache: true,\n        cacheTtlSecs: OneDaySecs,\n      });\n      let edges = response.body.data.products.edges;\n\n      let products = edges.map(edge => edge.node);\n      for (let product of products) {\n        product.image = product.featuredImage.url;\n      }\n\n      let continuation;\n      if (products.length > 0) {\n        let lastCursor = edges.at(-1).cursor;\n        continuation = { cursor: lastCursor };\n      }\n\n      return {\n        result: products,\n        continuation: continuation,\n      };\n    },\n  },\n});\n{% endraw %}\n```",
    "Send form-encoded data": "An action formula that sends application/x-www-form-urlencoded data. This sample uploads an image to Imgur.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"Upload\",\n  description: \"Uploads an image to Imgur.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description: \"The image to upload.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"title\",\n      description: \"The title of the image.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function (args, context) {\n    let [imageUrl, title] = args;\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://api.imgur.com/3/image\",\n      // Use the form field to generate a application/x-www-form-urlencoded\n      // payload and set the correct headers.\n      form: {\n        image: imageUrl,\n        type: \"url\",\n        title: title,\n      },\n    });\n    return response.body.data.link;\n  },\n});\n\npack.addNetworkDomain(\"imgur.com\");\n\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"Authentication\",\n  tokenPrefix: \"Client-ID\",\n});\n{% endraw %}\n```\n\n[]\n\nnav: Formulas\ndescription: Samples that show how to create a formula.\nicon: material/function\n\n[]"
  },
  "Formula samples": {
    "Template": "The basic structure of a formula. This sample takes in a single string parameter and returns a string result.\n\n```\n{% raw %}\npack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return \"\";\n  },\n});\n{% endraw %}\n```",
    "Image result": "A formula that returns an image. This sample gets a random cat image with an optional text overlay or filter applied.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");\n{% endraw %}\n```",
    "Rich data result": "A formula that returns rich data (a schema). This sample gets information about a task in the Todoist application.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the rich metadata to be returned about each task.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n});\n\n// Formula that looks up rich metadata about a task given it's ID.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by ID\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([taskId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      id: task.id,\n    };\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "With examples": "A formula that includes examples of how to use it. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\".\npack.addFormula({\n  name: \"Scream\",\n  description: \"Make text uppercase and add exclamation points.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to scream.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"volume\",\n      description: \"The number of exclamation points to add.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"character\",\n      description: \"The character to repeat.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  examples: [\n    { params: [\"Hello\"], result: \"HELLO!!!\" },\n    { params: [\"Hello\", 5], result: \"HELLO!!!!!\" },\n    { params: [\"Hello\", undefined, \"?\"], result: \"HELLO???\" },\n    { params: [\"Hello\", 5, \"?\"], result: \"HELLO?????\" },\n  ],\n  execute: async function ([text, volume = 3, character = \"!\"], context) {\n    return text.toUpperCase() + character.repeat(volume);\n  },\n});\n{% endraw %}\n```\n\n[]\n\nnav: Images &amp; files\ndescription: Samples that show how to work with images and files.\nicon: material/image\n\n[]"
  },
  "Images &amp; file samples": {
    "Image parameter": "A formula that takes an image as a parameter. This sample returns the file size of an image.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// Formula that calculates the file size of an image.\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an image, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description:\n        \"The image to operate on. Not compatible with Image URL columns.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([imageUrl], context) {\n    // Throw an error if the image isn't Coda-hosted. Image URL columns can\n    // contain images on any domain, but by default Packs can only access image\n    // attachments hosted on codahosted.io.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n    // Fetch the image content.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true, // Required when fetching binary content.\n    });\n    // The binary content of the response is returned as a Node.js Buffer.\n    // See: https://nodejs.org/api/buffer.html\n    let buffer = response.body as Buffer;\n    // Return the length, in bytes.\n    return buffer.length;\n  },\n});\n{% endraw %}\n```",
    "Image result": "A formula that return an external image. This sample returns a random photo of a cat.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");\n{% endraw %}\n```",
    "Image result from temporary URL": "A formula that returns an image uploaded to &#x60;temporaryBlobStorage&#x60;. This sample returns a random avatar using an API that returns SVG code used to generate an avatar. You could also imagine procedurally generating a SVG or image in your packs code and uploading it to &#x60;temporaryBlobStorage&#x60;.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"boringavatars.com\");\n\npack.addFormula({\n  name: \"BoringAvatar\",\n  description: \"Get a boring avatar image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size to generate the avatar in pixels.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageAttachment,\n  execute: async function ([size], context) {\n    let resp = await context.fetcher.fetch({ \n      method: \"GET\", \n      url: `https://source.boringavatars.com/beam/${size}`,\n      // Formats response as binary to get a Buffer of the svg data\n      isBinaryResponse: true, \n    });\n    // This API returns direct SVG code used to generate the avatar.\n    let svg = resp.body;\n\n    let url = await context.temporaryBlobStorage\n                      .storeBlob(svg, \"image/svg+xml\");\n    return url;\n  },\n});\n{% endraw %}\n```",
    "Upload images": "An action that downloads images from Coda and uploads them to another service. This sample uploads a list of files to Google Photos.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// A custom type that bundles together the image buffer and content type.\ninterface ImageData {\n  buffer: Buffer,\n  contentType: string,\n}\n\n// Action that uploads a list of images to Google Photos.\npack.addFormula({\n  name: \"Upload\",\n  description: \"Uploads images to Google Photos.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.ImageArray,\n      name: \"images\",\n      description: \"The images to upload.\",\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Url,\n  },\n  isAction: true,\n  execute: async function ([imageUrls], context) {\n    // Download the images from Coda.\n    let images = await downloadImages(imageUrls, context);\n    // Upload the images to Google Photos, getting temporary tokens.\n    let uploadTokens = await uploadImages(images, context);\n    // Add the images to the user's library, using the tokens.\n    let urls = await addImages(uploadTokens, context);\n    // Return the URLs of the uploaded images.\n    return urls;\n  },\n});\n\n// Download the images from Coda, in parallel. For each image it returns a\n// buffer of image data and the MIME type of the image.\nasync function downloadImages(imageUrls, context: coda.ExecutionContext):\n    Promise<ImageData[]> {\n  let requests = [];\n  for (let imageUrl of imageUrls) {\n    // Reject images not hosted in Coda, since we can't download them.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n\n    // Start the download.\n    let request = context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true,\n      disableAuthentication: true,\n    });\n    requests.push(request);\n  }\n  // Wait for all the downloads to finish.\n  let responses = await Promise.all(requests);\n\n  // Extract the data from the responses.\n  let images: ImageData[] = [];\n  for (let response of responses) {\n    let data = {\n      buffer: response.body,\n      contentType: response.headers[\"content-type\"] as string,\n    };\n    images.push(data);\n  }\n  return images;\n}\n\n// Uploads the images to Google Photos, in parallel. For each image it returns a\n// temporary upload token.\nasync function uploadImages(images: ImageData[],\n    context: coda.ExecutionContext): Promise<string[]> {\n  let requests = [];\n  for (let image of images) {\n    // Start the upload.\n    let request = context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://photoslibrary.googleapis.com/v1/uploads\",\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n        \"X-Goog-Upload-Content-Type\": image.contentType,\n        \"X-Goog-Upload-Protocol\": \"raw\",\n      },\n      body: image.buffer,\n    });\n    requests.push(request);\n  }\n  // Wait for all the uploads to finish.\n  let responses = await Promise.all(requests);\n\n  // Extract the upload tokens from the responses.\n  let uploadTokens = [];\n  for (let response of responses) {\n    let uploadToken = response.body;\n    uploadTokens.push(uploadToken);\n  }\n  return uploadTokens;\n}\n\n// Adds uploaded images to the user's library. For each image it returns the URL\n// of the image in Google Photos.\nasync function addImages(uploadTokens: string[],\n    context: coda.ExecutionContext): Promise<string[]> {\n  // Construct the request payload.\n  let items = [];\n  for (let uploadToken of uploadTokens) {\n    let item  = {\n      simpleMediaItem: {\n        uploadToken: uploadToken,\n      },\n    };\n    items.push(item);\n  }\n  let payload = {\n    newMediaItems: items,\n  };\n\n  // Make the request to add all the images.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: \"https://photoslibrary.googleapis.com/v1/mediaItems:batchCreate\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(payload),\n  });\n  let results = response.body.newMediaItemResults;\n\n  // Extract the URLs from the results.\n  let urls = [];\n  for (let [i, result] of results.entries()) {\n    // Throw an error if any of the uploads failed.\n    if (result.status.message !== \"Success\") {\n      throw new coda.UserVisibleError(\n        `Upload failed for image ${i + 1}: ${result.status.message}`);\n    }\n    let url = result.mediaItem.productUrl;\n    urls.push(url);\n  }\n  return urls;\n}\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n  scopes: [\n    \"https://www.googleapis.com/auth/photoslibrary.appendonly\",\n  ],\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n});\n\npack.addNetworkDomain(\"googleapis.com\");\n{% endraw %}\n```",
    "Attach image data": "A sync table that includes images sourced from raw data. This sample syncs files from Dropbox, including their thumbnail images.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema defining the fields to sync for each file.\nconst FileSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    path: { type: coda.ValueType.String, fromKey: \"path_display\" },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    thumbnail: {\n      type: coda.ValueType.String,\n      // ImageAttachments instructs Coda to ingest the image and store it in the\n      // doc. This is required, since the thumbnail image URLs returned by\n      // TemporaryBlobStorage expire.\n      codaType: coda.ValueHintType.ImageAttachment,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"thumbnail\", \"url\"],\n});\n\n// Sync table for files.\npack.addSyncTable({\n  name: \"Files\",\n  identityName: \"File\",\n  schema: FileSchema,\n  formula: {\n    name: \"SyncFiles\",\n    description: \"Sync the files.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get a batch of files.\n      let filesResponse = await getFiles(context);\n      let files = filesResponse.entries\n        .filter(entry => entry[\".tag\"] === \"file\");\n      let hasMore = filesResponse.has_more;\n\n      // Get the URL for each file.\n      let fileIds = files.map(file => file.id);\n      let fileUrls = await getFileUrls(fileIds, context);\n      for (let i = 0; i < files.length; i++) {\n        files[i].url = fileUrls[i];\n      }\n\n      // Get the thumbnail for each file.\n      let paths = files.map(file => file.path_lower);\n      let thumbnails = await getThumbnails(paths, context);\n\n      // The thumbnail images are returned as base64-encoded strings in the\n      // response body, but the doc can only ingest an image URL. We'll parse\n      // the image data and store it in temporary blob storage, and return those\n      // URLs.\n\n      // Collect the all of the temporary blob storage jobs that are started.\n      let jobs = [];\n      for (let thumbnail of thumbnails) {\n        let job;\n        if (thumbnail) {\n          // Parse the base64 thumbnail content.\n          let buffer = Buffer.from(thumbnail, \"base64\");\n          // Store it in temporary blob storage.\n          job = context.temporaryBlobStorage.storeBlob(buffer, \"image/png\");\n        } else {\n          // The file has no thumbnail, have the job return undefined.\n          job = Promise.resolve(undefined);\n        }\n        jobs.push(job);\n      }\n\n      // Wait for all the jobs to complete, then copy the temporary URLs back\n      // into the file objects.\n      let temporaryUrls = await Promise.all(jobs);\n      for (let i = 0; i < files.length; i++) {\n        files[i].thumbnail = temporaryUrls[i];\n      }\n\n      // If there are more files to retrieve, create a continuation.\n      let continuation;\n      if (hasMore) {\n        continuation = {\n          cursor: filesResponse.cursor,\n        };\n      }\n\n      // Return the results.\n      return {\n        result: files,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Gets a batch of files from the API.\nasync function getFiles(context: coda.SyncExecutionContext): Promise<any> {\n  let url = \"https://api.dropboxapi.com/2/files/list_folder\";\n  let body;\n\n  // Retrieve the cursor to continue from, if any.\n  let cursor = context.sync.continuation?.cursor;\n  if (cursor) {\n    // Continue from the cursor.\n    url = coda.joinUrl(url, \"/continue\");\n    body = {\n      cursor: cursor,\n    };\n  } else {\n    // Starting a new sync, list all of the files.\n    body = {\n      path: \"\",\n      recursive: true,\n      limit: 25,\n    };\n  }\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  });\n  return response.body;\n}\n\n// Get the thumbnail metadata for a list of file paths.\nasync function getThumbnails(paths, context: coda.ExecutionContext):\n    Promise<string[]> {\n  // Use a batch URL to get all of the thumbnail metadata in one request.\n  let url = \"https://content.dropboxapi.com/2/files/get_thumbnail_batch\";\n\n  // Create a request entry for each file path.\n  let entries = [];\n  for (let path of paths) {\n    let entry = {\n      path: path,\n      format: \"png\",\n      size: \"w256h256\",\n    };\n    entries.push(entry);\n  }\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      entries: entries,\n    }),\n  });\n  return response.body.entries.map(entry => entry.thumbnail);\n}\n\n// Get the Dropbox URLs for a list of file IDs.\nasync function getFileUrls(fileIds, context: coda.ExecutionContext):\n    Promise<string[]> {\n  // Use a batch URL to get all of the thumbnail metadata in one request.\n  let url = \"https://api.dropboxapi.com/2/sharing/get_file_metadata/batch\";\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      files: fileIds,\n    }),\n  });\n  return response.body.map(metadata => metadata.result.preview_url);\n}\n\n// Set per-user authentication using Dropbox's OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.dropbox.com/oauth2/authorize\",\n  tokenUrl: \"https://api.dropbox.com/oauth2/token\",\n  scopes: [\"files.content.read\", \"sharing.read\"],\n  additionalParams: {\n    token_access_type: \"offline\",\n  },\n});\n\n// Allow access to the Dropbox domain.\npack.addNetworkDomain(\"dropboxapi.com\");\n{% endraw %}\n```",
    "Attach private images": "A sync table that includes images sourced from private URLs. This sample syncs files from Google Drive, including their thumbnail images.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema defining the fields to sync for each file.\nconst FileSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n      fromKey: \"webViewLink\",\n    },\n    thumbnail: {\n      type: coda.ValueType.String,\n      // ImageAttachments instructs Coda to ingest the image and store it in the\n      // doc.\n      codaType: coda.ValueHintType.ImageAttachment,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"thumbnail\", \"url\"],\n});\n\n// Sync table for files.\npack.addSyncTable({\n  name: \"Files\",\n  identityName: \"File\",\n  schema: FileSchema,\n  formula: {\n    name: \"SyncFiles\",\n    description: \"Sync the files.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Retrieve the page token to use from the previous sync, if any.\n      let pageToken = context.sync.continuation?.pageToken;\n\n      // Get a batch of files.\n      let url = \"https://www.googleapis.com/drive/v3/files\";\n      url = coda.withQueryParams(url, {\n        fields: \"files(id,name,webViewLink,thumbnailLink)\",\n        pageToken: pageToken,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let files = response.body.files;\n      let nextPageToken = response.body.nextPageToken;\n\n      // The thumbnail URLs that the Drive API returns require authentication\n      // credentials to access, so the doc won't be able to ingest them as-is.\n      // Instead, we'll download the thumbnails and store them in temporary\n      // blob storage, and return those URLs.\n\n      // Collect the all of the temporary blob storage jobs that are started.\n      let jobs = [];\n      for (let file of files) {\n        let job;\n        if (file.thumbnailLink) {\n          // Download the thumbnail (with credentials) and store it in temporary\n          // blob storage.\n          job = context.temporaryBlobStorage.storeUrl(file.thumbnailLink);\n        } else {\n          // The file has no thumbnail, have the job return undefined.\n          job = Promise.resolve(undefined);\n        }\n        jobs.push(job);\n      }\n\n      // Wait for all the jobs to complete, then copy the temporary URLs back\n      // into the file objects.\n      let temporaryUrls = await Promise.all(jobs);\n      for (let i = 0; i < files.length; i++) {\n        files[i].thumbnail = temporaryUrls[i];\n      }\n\n      // If there are more files to retrieve, create a continuation.\n      let continuation;\n      if (nextPageToken) {\n        continuation = { pageToken: nextPageToken };\n      }\n\n      // Return the results.\n      return {\n        result: files,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Set per-user authentication using Google's OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n  scopes: [\"https://www.googleapis.com/auth/drive.readonly\"],\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n  // Send the authentication information to all domains.\n  // Note: Using auth with multiple domains requires approval from Coda.\n  networkDomain: [\"googleapis.com\", \"docs.google.com\", \"googleusercontent.com\"],\n});\n\n// Allow access to the Google domains.\n// Note: Using multiple domains in a Pack requires approval from Coda.\npack.addNetworkDomain(\"googleapis.com\");\npack.addNetworkDomain(\"docs.google.com\");\npack.addNetworkDomain(\"googleusercontent.com\");\n{% endraw %}\n```",
    "Generated SVG": "A formula that generated an SVG, and returns it as a data URI. This sample generates an image from the text provided.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A formula that generates an image using some input text.\npack.addFormula({\n  name: \"TextToImage\",\n  description: \"Generates an image using the text provided.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to include in the image.\",\n      suggestedValue: \"Hello World!\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The desired color of the text. Defaults to black.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, color = \"black\"], context) {\n    // Calculate the width of the generated image required to fit the text.\n    // Using a fixed-width font to make this easy.\n    let width = text.length * 6;\n    // Generate the SVG markup. Prefer using a library for this when possible.\n    let svg = `\n      <svg viewBox=\"0 0 ${width} 10\" xmlns=\"http://www.w3.org/2000/svg\">\n        <text x=\"0\" y=\"8\" font-family=\"Courier\" font-size=\"10\" fill=\"${color}\">\n          ${text}\n        </text>\n      </svg>\n    `.trim();\n    // Encode the markup as base64.\n    let encoded = Buffer.from(svg).toString(\"base64\");\n    // Return the SVG as a data URL.\n    return coda.SvgConstants.DataUrlPrefix + encoded;\n  },\n});\n{% endraw %}\n```",
    "Dark mode SVG": "A formula that generates an SVG that adapts if dark mode is enabled. This sample generates an image with static text, which changes color when dark mode is enabled.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A formula that demonstrates how to generate an SVG that adapts to the user's\n// dark mode setting in Coda.\npack.addFormula({\n  name: \"HelloDarkMode\",\n  description: \"Generates an image that adapts to the dark mode setting.\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([], context) {\n    // When loading your image in dark mode, Coda will append the URL fragment\n    // \"#DarkMode\". Instead of hard-coding that value, it's safer to retrieve\n    // it from the SDK.\n    let darkModeId = coda.SvgConstants.DarkModeFragmentId;\n    // Generate the SVG markup. Prefer using a library for this when possible.\n    let svg = `\n      <svg viewBox=\"0 0 36 10\" xmlns=\"http://www.w3.org/2000/svg\">\n        <!-- Add the dark mode ID to the root of the SVG. -->\n        <g id=\"${darkModeId}\">\n          <text x=\"0\" y=\"8\" font-family=\"Courier\" font-size=\"10\" fill=\"black\">\n            Hello World!\n          </text>\n        </g>\n        <style>\n          /* Create a style rule that will be applied when the dark mode\n             fragment is applied. */\n          #${darkModeId}:target text { fill: white; }\n        </style>\n      </svg>\n    `.trim();\n    // Encode the markup as base64.\n    let encoded = Buffer.from(svg).toString(\"base64\");\n    // Return the SVG as a data URL (using the dark mode prefix).\n    return coda.SvgConstants.DataUrlPrefixWithDarkModeSupport + encoded;\n  },\n});\n{% endraw %}\n```",
    "File parameter": "A formula that takes an file as a parameter. This sample uploads the file to an AWS S3 bucket.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Action that uploads a file to Amazon S3.\npack.addFormula({\n  name: \"Upload\",\n  description: \"Upload a file to AWS S3.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.File,\n      name: \"file\",\n      description: \"The file to upload.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The target file name. Default: the original file name.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"path\",\n      description: \"The target directory path. Default: the root directory.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([fileUrl, name, path=\"/\"], context) {\n    // Fetch the file contents.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: fileUrl,\n      isBinaryResponse: true,\n      disableAuthentication: true,\n    });\n    let buffer = response.body;\n    let contentType = response.headers[\"content-type\"] as string;\n    let contentDisposition = response.headers[\"content-disposition\"] as string;\n\n    // Determine file name.\n    if (!name && contentDisposition) {\n      name = getFilename(contentDisposition);\n    }\n    if (!name) {\n      // Fallback to last segment of the URL.\n      name = fileUrl.split(\"/\").pop();\n    }\n\n    // Upload to S3.\n    let s3Url = coda.joinUrl(context.endpoint, path, name);\n    await context.fetcher.fetch({\n      method: \"PUT\",\n      url: s3Url,\n      headers: {\n        \"Content-Type\": contentType,\n        \"Content-Length\": buffer.length.toString(),\n      },\n      body: buffer,\n    });\n    return s3Url;\n  },\n});\n\n// Gets the filename from a Content-Disposition header value.\nfunction getFilename(contentDisposition) {\n  let match = contentDisposition.match(/filename=(.*?)(;|$)/);\n  if (!match) {\n    return;\n  }\n  let filename = match[1].trim();\n  // Remove quotes around the filename, if present.\n  filename = filename.replace(/^[\"'](.*)[\"']$/, \"$1\");\n  return filename;\n}\n\n// Set per-user authentication using AWS Signature Version 4 with an access key.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  service: \"s3\",\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n});\n\n// Allow the pack to make requests to AWS.\npack.addNetworkDomain(\"amazonaws.com\");\n{% endraw %}\n```\n\n[]\n\nnav: Parameters\ndescription: Samples that show how to accept parameters from the user.\nicon: material/format-textbox\n\n[]"
  },
  "Parameter samples": {
    "Template": "The basic structure of a parameter. This sample is for a string parameter.\n\n```\n{% raw %}\ncoda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"myParameter\",\n  description: \"My description.\",\n}),\n{% endraw %}\n```",
    "No parameters": "A formula without any parameters. This sample returns the name of the current day of the week.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that gets the current weekday, for example \"Monday\".\npack.addFormula({\n  name: \"CurrentWeekday\",\n  description: \"Get the current day of the week.\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  execute: async function ([], context) {\n    let now = new Date();\n    let formatter = Intl.DateTimeFormat(\"us-US\", {\n      timeZone: context.timezone,\n      weekday: \"long\",\n    });\n    return formatter.format(now);\n  },\n});\n{% endraw %}\n```",
    "String parameter": "A formula that takes plain text as a parameter. This sample returns a greeting to the name provided.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Say Hello to the given name.\npack.addFormula({\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The person's name you would like to say hello to.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([name]) {\n    return \"Hello \" + name + \"!\";\n  },\n});\n{% endraw %}\n```",
    "Number parameter": "A formula that takes a number as a parameter. This sample converts a number of slices of pizza into a percentage eaten.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that converts slices of a pizza into a percentage eaten.\npack.addFormula({\n  name: \"PizzaEaten\",\n  description: \"Calculates what percentage of a pizza was eaten.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"slices\",\n      description: \"How many slices were eaten.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Percent,\n  execute: async function ([slices], context) {\n    return slices / 8;\n  },\n});\n{% endraw %}\n```",
    "Date parameter": "A formula that takes a date as a parameter. This sample determines if the year of a given date would make for good New Years Eve glasses (has two or more zeros).\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"GoodNYEGlasses\",\n  description: \"Determines if a date is good for New Years Eve glasses \" +\n    \"(the year contains two zeros).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The input date.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([date], context) {\n    // Format the JavaScript Date into a four-digit year.\n    let formatted = date.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      year: \"numeric\",\n    });\n    // Extract all of the zeros from the year.\n    let zeros = formatted.match(/0/g);\n    return zeros?.length >= 2;\n  },\n});\n{% endraw %}\n```",
    "Image parameter": "A formula that takes an image as a parameter. This sample returns the file size of an image.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// Formula that calculates the file size of an image.\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an image, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description:\n        \"The image to operate on. Not compatible with Image URL columns.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([imageUrl], context) {\n    // Throw an error if the image isn't Coda-hosted. Image URL columns can\n    // contain images on any domain, but by default Packs can only access image\n    // attachments hosted on codahosted.io.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n    // Fetch the image content.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true, // Required when fetching binary content.\n    });\n    // The binary content of the response is returned as a Node.js Buffer.\n    // See: https://nodejs.org/api/buffer.html\n    let buffer = response.body as Buffer;\n    // Return the length, in bytes.\n    return buffer.length;\n  },\n});\n{% endraw %}\n```",
    "Array parameter": "A formula that takes a string array as a parameter. This sample returns the longest string in the list.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"Longest\",\n  description: \"Given a list of strings, returns the longest one.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.StringArray,\n      name: \"strings\",\n      description: \"The input strings.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([strings], context) {\n    if (strings.length === 0) {\n      throw new coda.UserVisibleError(\"No options provided.\");\n    }\n    let result;\n    for (let str of strings) {\n      if (!result || str.length > result.length) {\n        result = str;\n      }\n    }\n    return result;\n  },\n});\n{% endraw %}\n```",
    "Sparse array parameter": "A formula that takes sparse number arrays as a parameter, useful when passing table columns. This sample returns the total cost for an order of items.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"TotalCost\",\n  description: \"Calculates the total cost for an order.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"prices\",\n      description: \"The prices for each item.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"quantities\",\n      description: \"The quantities of each item. Default: 1.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"taxRates\",\n      description: \"The tax rates for each item. Default: 0.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([prices, quantities=[], taxRates=[]], context) {\n    if ((quantities.length > 0 && quantities.length !== prices.length) ||\n        (taxRates.length > 0 && taxRates.length !== prices.length)) {\n      throw new coda.UserVisibleError(\"All lists must be the same length.\");\n    }\n    let result = 0;\n    for (let i = 0; i < prices.length; i++) {\n      let price = prices[i];\n      let quantity = quantities[i];\n      let taxRate = taxRates[i];\n      if (price == null) {\n        // If the price is blank, continue on to the next row.\n        continue;\n      }\n      if (quantity != null) {\n        price *= quantity;\n      }\n      if (taxRate != null) {\n        price += price * taxRate;\n      }\n      result += price;\n    }\n    return result;\n  },\n});\n{% endraw %}\n```",
    "Optional parameters": "A formula with some required and some optional parameters. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\".\npack.addFormula({\n  name: \"Scream\",\n  description: \"Make text uppercase and add exclamation points.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to scream.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"volume\",\n      description: \"The number of exclamation points to add.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"character\",\n      description: \"The character to repeat.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  examples: [\n    { params: [\"Hello\"], result: \"HELLO!!!\" },\n    { params: [\"Hello\", 5], result: \"HELLO!!!!!\" },\n    { params: [\"Hello\", undefined, \"?\"], result: \"HELLO???\" },\n    { params: [\"Hello\", 5, \"?\"], result: \"HELLO?????\" },\n  ],\n  execute: async function ([text, volume = 3, character = \"!\"], context) {\n    return text.toUpperCase() + character.repeat(volume);\n  },\n});\n{% endraw %}\n```",
    "Parameter suggested value": "A formula with a parameter that defines a suggested value. This sample rolls virtual dice and returns the results.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Rolls virtual dice and returns the resulting numbers. Use it with a button in\n// table and store the results in another column.\npack.addFormula({\n  name: \"RollDice\",\n  description: \"Roll some virtual dice.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many dice to roll.\",\n      suggestedValue: 1,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"sides\",\n      description: \"How many sides the dice have.\",\n      suggestedValue: 6,\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.Number,\n  }),\n  isAction: true,\n  execute: async function ([quantity, sides], context) {\n    let results = [];\n    for (let i = 0; i < quantity; i++) {\n      let roll = Math.ceil(Math.random() * sides);\n      results.push(roll);\n    }\n    return results;\n  },\n});\n{% endraw %}\n```",
    "Variable argument parameters": "A formula that accepts a variable number of arguments. This sample draws a simple diagram using text, with an unknown number of arrow labels and steps.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Takes an unknown number of steps and labels and outputs a simple diagram.\n// Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\")\n// Result: Idea --Experiment--> Prototype --Refine--> Product\npack.addFormula({\n  name: \"Steps\",\n  description: \"Draws a simple step diagram using text.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"start\",\n      description: \"The starting step.\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"label\",\n      description: \"The label for the arrow.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"step\",\n      description: \"The next step.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([start, ...varargs], context) {\n    let result = start;\n    while (varargs.length > 0) {\n      let label; let step;\n      // Pull the first set of varargs off the list, and leave the rest.\n      [label, step, ...varargs] = varargs;\n      result += ` --${label}--> ${step}`;\n    }\n    return result;\n  },\n});\n{% endraw %}\n```",
    "Reusing parameters": "A Pack that reuses a parameter across multiple formulas. This sample includes mathematical formulas that operate on a list of numbers.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A \"numbers\" parameter shared by both formulas.\nconst NumbersParameter = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"numbers\",\n  description: \"The numbers to perform the calculation on.\",\n});\n\npack.addFormula({\n  name: \"GCD\",\n  description: \"Returns the greatest common divisor for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where all the numbers are zeros.\n    if (numbers.every(number => number === 0)) {\n      throw new coda.UserVisibleError(\n        \"The list must contain a non-zero number.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = gcd(number, result);\n    }\n    return result;\n  },\n});\n\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where the list contains a zero.\n    if (numbers.some(number => number === 0)) {\n      throw new coda.UserVisibleError(\"The list must not contain a zero.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = Math.abs(number * result) / gcd(number, result);\n    }\n    return result;\n  },\n});\n\n// Helper function that calculates the greatest common divisor of two\n// numbers.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}\n{% endraw %}\n```\n\n[]\n\nnav: Schemas\ndescription: Samples that show how to define a schema, to represent rich objects.\nicon: material/format-list-group\n\n[]"
  },
  "Schema samples": {
    "Template (Object Schema)": "The basic structure of an object schema.\n\n```\n{% raw %}\nconst ThingSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    // TODO: Add more properties.\n  },\n  displayProperty: \"$2\",\n});\n{% endraw %}\n```",
    "For formula": "An object schema used by a formula. This sample defines the schema for information about the daylight at a given location.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Define a schema for the information about the daylight at a given location.\nconst SunSchema = coda.makeObjectSchema({\n  properties: {\n    daylight: {\n      description: \"How much daylight there will be.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunriseUTC: {\n      description: \"When the sun will rise (in UTC).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunsetUTC: {\n      description: \"When the sun will set (in UTC).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  displayProperty: \"daylight\",\n});\n{% endraw %}\n```",
    "For sync table": "An object schema used by a sync table. This sample defines the schema for the information about a spell in Dungeons and Dragons.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema that defines the a spell object.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n});\n{% endraw %}\n```",
    "With self-reference": "An object schema used by a sync table, that includes a row reference to itself. This sample defines the schema for a task in Todoist, where tasks can have parent tasks.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A reference to a synced Task. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a task itself can contain\n// a reference to a parent task.\nconst TaskReferenceSchema = coda.makeObjectSchema({\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: { type: coda.ValueType.String, required: true },\n    id: { type: coda.ValueType.String, required: true },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  // For reference schemas, set identity.name the value of identityName on the\n  // sync table being referenced.\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// A schema defining a Task object.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    // Add a reference to the sync'ed row of the parent task.\n    // References only work in sync tables.\n    parentTask: TaskReferenceSchema,\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"url\"],\n});\n{% endraw %}\n```\n\n[]\n\nnav: Sync tables\ndescription: Samples that show how to create a sync table.\nicon: material/table-sync\n\n[]"
  },
  "Sync table samples": {
    "Template": "The basic structure of a sync table.\n\n```\n{% raw %}\npack.addSyncTable({\n  name: \"MyThings\",\n  description: \"Table description.\",\n  identityName: \"Thing\",\n  schema: ThingSchema,\n  formula: {\n    name: \"Sync$1\",\n    description: \"Syncs the data.\",\n    parameters: [\n      // TODO: Add parameters.\n    ],\n    execute: async function (args, context) {\n      // TODO: Unpack the parameter values.\n      let [] = args;\n      // TODO: Fetch the rows.\n      let rows = [];\n      for (let row of rows) {\n        // TODO: If required, adjust the row to match the schema.\n      }\n      return {\n        result: rows,\n      };\n    },\n  },\n});\n{% endraw %}\n```",
    "With parameter": "A sync table that uses a parameter. This sample syncs cat photos from the CatAAS API.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: coda.makeSchema({ type: coda.ValueType.String }),\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"image\",\n  idProperty: \"id\",\n  featuredProperties: [\"tags\"],\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"tag\",\n        description: \"Only cats with this tag will be selected.\",\n        optional: true,\n        // Pull the list of tags to use for autocomplete from the API.\n        autocomplete: async function (context, search) {\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: \"https://cataas.com/api/tags\",\n          });\n          let tags = response.body;\n          // Convert the tags into a list of autocomplete options.\n          return coda.simpleAutocomplete(search, tags);\n        },\n      }),\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag,\n        limit: 10000,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat._id,\n          tags: cat.tags,\n          created: cat.createdAt,\n          id: cat._id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");\n{% endraw %}\n```",
    "With continuation": "A sync table that uses continuations to sync data using multiple executions. This sample syncs the spells available in Dungeons and Dragons.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// How many spells to fetch in each sync formula execution.\nconst BATCH_SIZE = 20;\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Schema that defines the metadata to return for each spell. Shared by the\n// formula, column format, and sync table.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n});\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}\n\n// A sync table that displays all spells available in the API.\npack.addSyncTable({\n  name: \"Spells\",\n  identityName: \"Spell\",\n  schema: SpellSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncSpells\",\n    description: \"Sync all the spells.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the list of all spells.\n      let listUrl = \"https://www.dnd5eapi.co/api/spells\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: listUrl,\n      });\n      let results = response.body.results;\n\n      // If there is a previous continuation, start from the index contained\n      // within, otherwise start at zero.\n      let index: number = (context.sync.continuation?.index as number) || 0;\n\n      // Get a batch of results, starting from the index determined above.\n      let batch = results.slice(index, index + BATCH_SIZE);\n\n      // Fetch the spells for the batch of results.\n      let spells = await fetchSpells(context.fetcher, batch);\n\n      // Move the index forward.\n      index += BATCH_SIZE;\n\n      // If there are more results to process, create a new continuation.\n      let continuation;\n      if (index <= results.length) {\n        continuation = {\n          index: index,\n        };\n      }\n\n      // Return the batch of spells and the next continuation, if any.\n      return {\n        result: spells,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}\n{% endraw %}\n```",
    "With authentication": "A sync table that pulls from an API using authentication. This sample syncs the tasks from a user&#x27;s Todoist account.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"url\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A supported filter string. See the Todoist help center.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"project\",\n        description: \"Limit tasks to a specific project.\",\n        optional: true,\n        autocomplete: async function (context, search) {\n          let url = \"https://api.todoist.com/rest/v2/projects\";\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: url,\n          });\n          let projects = response.body;\n          return coda.autocompleteSearchObjects(search, projects, \"name\", \"id\");\n        },\n      }),\n    ],\n    execute: async function ([filter, project], context) {\n      let url = coda.withQueryParams(\"https://api.todoist.com/rest/v2/tasks\", {\n        filter: filter,\n        project_id: project,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          id: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "With row references": "A sync table that contains a reference to a row in another sync table. This sample syncs the tasks from a user&#x27;s Todoist account.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the Projects sync table.\nconst ProjectSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    id: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"url\"],\n});\n\n// A reference schema, allowing other sync tables to link to rows in the\n// Projects sync table. The second parameter must match the identityName field\n// of the sync table being referenced.\nconst ProjectReferenceSchema = coda.makeReferenceSchemaFromObjectSchema(\n  ProjectSchema, \"Project\");\n\n// A schema defining the data in the Tasks sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    // Reference a project from the Projects sync table.\n    project: ProjectReferenceSchema,\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"description\", \"url\", \"project\"],\n});\n\n// The definition and logic for the Projects sync table.\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let project of response.body) {\n        results.push({\n          name: project.name,\n          url: project.url,\n          id: project.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// The definition and logic for the Tasks sync table.\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        let item: any = {\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          id: task.id,\n        };\n        if (task.project_id) {\n          // Add a reference to the parent project in the Projects table.\n          item.project = {\n            id: task.project_id,\n            name: \"Not found\", // Placeholder name, if not synced yet.\n          };\n        }\n        results.push(item);\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```\n\n[]\n\nnav: Two-way sync\ndescription: Samples that show how to create sync tables with editable values.\nicon: material/card-text\n\n[]"
  },
  "Two-way sync samples": {
    "Simple two-way sync": "A sync table that supports user edits via two-way sync. It uses the default behavior of updating one row at a time. This sample syncs the tasks from a user&#x27;s Todoist account.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // By default only one row is processed at a time.\n      let update = updates[0];\n      let { previousValue, newValue } = update;\n      let taskId = newValue.id;\n\n      // Update the completion status, if it has changed.\n      if (previousValue.is_completed !== newValue.is_completed) {\n        let action = newValue.is_completed ? \"close\" : \"reopen\";\n        await context.fetcher.fetch({\n          method: \"POST\",\n          url: `https://api.todoist.com/rest/v2/tasks/${taskId}/${action}`,\n        });\n      }\n\n      // Update the other properties of the task.\n      let response = await context.fetcher.fetch({\n        url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(newValue),\n      });\n\n      // Return the updated task.\n      let updated = response.body;\n      return {\n        result: [updated],\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "With batched updates": "A sync table that supports user edits via two-way sync, batch processing multiple rows at once. This sample syncs the tasks from a user&#x27;s Todoist account.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    maxUpdateBatchSize: 10,\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // Create an async job for each update.\n      let jobs = updates.map(async update => {\n        return updateTask(context, update);\n      });\n      // Wait for all of the jobs to finish .\n      let completed = await Promise.allSettled(jobs);\n\n      // For each update, return either the updated row or an error if the\n      // update failed.\n      let results = completed.map(job => {\n        if (job.status === \"fulfilled\") {\n          return job.value;\n        } else {\n          return job.reason;\n        }\n      });\n\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\nasync function updateTask(context: coda.ExecutionContext,\n  update: coda.GenericSyncUpdate): Promise<any> {\n  let { previousValue, newValue } = update;\n  let taskId = newValue.id;\n\n  // Update the completion status, if it has changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    let action = newValue.is_completed ? \"close\" : \"reopen\";\n    await context.fetcher.fetch({\n      method: \"POST\",\n      url: `https://api.todoist.com/rest/v2/tasks/${taskId}/${action}`,\n    });\n  }\n\n  // Update the other properties of the task.\n  let response = await context.fetcher.fetch({\n    url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(newValue),\n  });\n\n  // Return the updated task.\n  return response.body;\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "Using a batch update endpoint": "A sync table that supports user edits via two-way sync, batch processing multiple rows at once using the API&#x27;s batch update endpoint. This sample syncs the tasks from a user&#x27;s Todoist account.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    // Process updates in batches of 10 rows at a time.\n    maxUpdateBatchSize: 10,\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // Generate the set of commands needed to process each update.\n      let commandSets = updates.map(update => generateCommands(update));\n\n      // Send all of the commands to the sync endpoint.\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.todoist.com/sync/v9/sync\",\n        form: {\n          commands: JSON.stringify(commandSets.flat()),\n        },\n      });\n      let statuses = response.body.sync_status;\n\n      // Process the results, returning either an error or the updated task.\n      // This is done async, so the fetches can be done in parallel.\n      let jobs = updates.map(async (update, i) => {\n        let taskId = update.newValue.id;\n        let commands = commandSets[i];\n        for (let command of commands) {\n          let status = statuses[command.uuid];\n          if (status.error) {\n            return new coda.UserVisibleError(status.error);\n          }\n        }\n        // If there were no errors, fetch the updated task and return it.\n        return getTask(context, taskId);\n      });\n      let results = await Promise.all(jobs);\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Generate a list of API commands from a row update.\nfunction generateCommands(update: coda.GenericSyncUpdate): any[] {\n  let commands = [];\n  let { previousValue, newValue } = update;\n  // Update the task.\n  commands.push({\n    type: \"item_update\",\n    uuid: Math.random().toString(36),\n    args: newValue,\n  });\n  // Update the completion status, if it's changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    commands.push({\n      type: newValue.is_completed ? \"item_complete\" : \"item_uncomplete\",\n      uuid: Math.random().toString(36),\n      args: {\n        id: newValue.id,\n      },\n    });\n  }\n  return commands;\n}\n\n// Fetch the current state of an individual task.\nasync function getTask(context: coda.ExecutionContext, id: string) {\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: `https://api.todoist.com/rest/v2/tasks/${id}`,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});\n{% endraw %}\n```",
    "With property options": "A sync table that supports user edits via two-way sync, with a defined set of options for certain properties. This sample syncs a user&#x27;s expenses in Splitwise.\n\n```\n{% raw %}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\nconst CategorySchema = coda.makeObjectSchema({\n  properties: {\n    id: {\n      description: \"A unique ID for the category.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n    name: {\n      description: \"The name of the category.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    icon: {\n      description: \"An icon representing the category.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n  },\n  displayProperty: \"name\",\n});\n\nconst ExpenseSchema = coda.makeObjectSchema({\n  properties: {\n    id: {\n      description: \"A unique ID for the expense.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"The description of the expense.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    date: {\n      description: \"The date the expense was made.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n      mutable: true,\n    },\n    cost: {\n      description: \"The total cost of the expense.\",\n      type: coda.ValueType.Number,\n      codaType: coda.ValueHintType.Currency,\n      mutable: true,\n    },\n    notes: {\n      description: \"Any notes on the expense.\",\n      type: coda.ValueType.String,\n      fromKey: \"details\",\n      mutable: true,\n    },\n    repeat: {\n      description: \"How often the expense automatically repeats.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      fromKey: \"repeat_interval\",\n      mutable: true,\n      // Static list of options.\n      options: [\"never\", \"weekly\", \"fortnightly\", \"monthly\", \"yearly\"],\n    },\n    currency: {\n      description: \"The code of the currency of the expense.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      fromKey: \"currency_code\",\n      mutable: true,\n      // Dynamic list of options.\n      options: async function (context) {\n        // Fetch the list of supported currencies.\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://secure.splitwise.com/api/v3.0/get_currencies\",\n        });\n        return response.body.currencies.map(currency => currency.currency_code);\n      },\n    },\n    category: {\n      ...CategorySchema,\n      codaType: coda.ValueHintType.SelectList,\n      mutable: true,\n      // Dynamic list of options, as objects.\n      options: async function (context) {\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://secure.splitwise.com/api/v3.0/get_categories\",\n        });\n        let categories = response.body.categories;\n        let result = [];\n        for (let category of categories) {\n          result.push(category);\n          let subcategories = category.subcategories || [];\n          for (let subcategory of subcategories) {\n            if (subcategory.name === \"Other\") {\n              // Add the parent category's name in front, to distinguish it.\n              subcategory.name = `${category.name} - ${subcategory.name}`;\n            }\n            result.push(subcategory);\n          }\n        }\n        return result;\n      },\n    },\n  },\n  displayProperty: \"description\",\n  idProperty: \"id\",\n  featuredProperties: [\n    \"date\", \"cost\", \"notes\", \"currency\", \"repeat\", \"category\",\n  ],\n});\n\npack.addSyncTable({\n  name: \"Expenses\",\n  description: \"Lists your expenses.\",\n  identityName: \"Expense\",\n  schema: ExpenseSchema,\n  formula: {\n    name: \"SyncExpenses\",\n    description: \"Syncs the data.\",\n    parameters: [],\n    execute: async function (args, context) {\n      let [] = args;\n      let offset = context.sync.continuation?.offset as number || 0;\n      let limit = 20;\n      let url = coda.withQueryParams(\n        \"https://secure.splitwise.com/api/v3.0/get_expenses\",\n        {\n          offset: offset,\n          limit: limit,\n        }\n      );\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let expenses = response.body.expenses;\n\n      let continuation;\n      if (expenses.length === limit) {\n        offset += limit;\n        continuation = { offset: offset };\n      }\n\n      return {\n        result: expenses,\n        continuation: continuation,\n      };\n    },\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Make all of the updates in parallel to improve performance.\n      let jobs = updates.map(async update => {\n        return updateExpense(context, update);\n      });\n      let completed = await Promise.allSettled(jobs);\n      let results = completed.map(job => {\n        if (job.status === \"fulfilled\") {\n          return job.value;\n        } else {\n          return job.reason;\n        }\n      });\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\nasync function updateExpense(context: coda.ExecutionContext,\n  update: coda.GenericSyncUpdate) {\n  let expense = update.newValue;\n\n  // Only include fields in the body that have been updated.\n  // The API will throw an error if you include fields that can't be modified.\n  let body: Record<string, any> = {};\n  for (let field of update.updatedFields) {\n    if (field === \"category\") {\n      // Only send the category ID when updating it.\n      body.category_id = expense.category.id;\n    } else {\n      body[field] = expense[field];\n    }\n  }\n\n  try {\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: `https://secure.splitwise.com/api/v3.0/update_expense/${expense.id}`,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n    let result = response.body;\n    return result.expenses[0];\n  } catch (e) {\n    // If the API returned an error, show that error to the user.\n    if (coda.StatusCodeError.isStatusCodeError(e)) {\n      let errors = Object.values(e.body.errors).flat();\n      if (errors?.length > 0) {\n        throw new coda.UserVisibleError(errors.join(\"\\n\"));\n      }\n    }\n    throw e;\n  }\n}\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://secure.splitwise.com/oauth/authorize\",\n  tokenUrl: \"https://secure.splitwise.com/oauth/token\",\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://secure.splitwise.com/api/v3.0/get_current_user\",\n    });\n    let user = response.body.user;\n    return `${user.first_name} ${user.last_name}`;\n  },\n});\n\npack.addNetworkDomain(\"splitwise.com\");\n{% endraw %}\n```\n\n[]\n\ntitle: Changes\ndescription: A log of the changes made to the SDK over time.\n\n[]\n\n--8<-- \"CHANGELOG.md\"\n\n[]\n\nnav: Contributing\ntitle: Contributing to the Coda Pack SDK\ndescription: Tips and policies for how to contribute to the SDK.\n\n[]\n\n--8<-- \"CONTRIBUTING.md\"\n\n[]\n\nnav: Style guide\ndescription: Rules and guidelines to be followed when writing documentation for the SDK.\n\n[]"
  },
  "Documentation Style Guide": {
    "Sample code": {
      "Use a single SDK import": "Import the entire SDK into a single variable named coda instead of using multiple, narrow imports.\n\n```\n// Yes\nimport * as coda from \"@codahq/packs-sdk\";\n```\n\n```\n// No\nimport {makeFormula} from '@codahq/packs-sdk';\nimport {makeParameter} from '@codahq/packs-sdk';\n```\n\nHaving all usages of the SDK prefixed with coda.{something} makes it easier to distinguish whats part of the SDK and whats not. It also makes it easier to copy and paste code from other places without having to worry about adding imports.",
      "Use double quotes": "Use double quotes whenever possible.\n\n```\n// Yes\ndescription: \"A Hello World example.\",\n```\n\n```\n// No\ndescription: 'A Hello World example.',\ndescription: `A Hello World example.`,\n```\n\nDouble quotes are required for JSON and often shown in example responses, and so it makes sense to standardize on them.",
      "Prefer string concatenation": "Prefer string concatenation over template strings for simple cases.\n\n```\n// Yes\nlet url = \"http://example.com/thing/\" + thingId;\n```\n\n```\n// No\nlet url = `http://example.com/thing/${thingId}`;\n```\n\nString concatenation is often easier to read and understand, and doesnt introduce an additional string delimiter. Template strings can be used if multiple variables are being inserted.",
      "Use `let` for variable declaration": "Prefer `let` over `const`, even in cases where the value is never re-assigned.\n\n```\n// Yes\nlet url = \"http://example.com\";\n```\n\n```\n// No\nconst url = \"http://example.com\";\n```\n\nThe distinction between `let` and `const` isnt always clear to newer coders, and the inflexibility of `const` can lead to more errors as users are playing around with code they copy and pasted.\n\n!!! note \"Exception: File-level constants\"\nFile-level constants such as enums and schemas, should use const.\n```ts\nconst MaxItems = 100;\nconst MySchema = coda.makeObjectSchema(...);\n```",
      "Avoid the ternary operator": "Use conditional blocks instead.\n\n```\n// Yes\nlet foo = \"bar\";\nif (isThing) {\n  foo = \"baz\";\n}\n```\n\n```\n// No\nlet foo = isThing ? \"bar\" : \"baz\";\n```\n\nThe ternary operator isnt widely known among newer coders, and the syntax is very opaque if you havent see it before.",
      "Avoid the spread operator": "Prefer a more concrete manipulation of objects, when feasible.\n\n```\n// Yes\nlet result = response.body;\nresult.foo = \"bar\";\nreturn result;\n```\n\n```\n// No\nreturn {\n  ...response.body,\n  foo: 'bar',\n}\n```\n\nThe syntax may not be familiar to newer coders, and more explicit assignments can make it clearer whats going on.",
      "Always set the key and value": "Even when the key and value are the same, always set both explicitly.\n\n```\n// Yes\ncontext.fetcher.fetch({\n  method: \"GET\",\n  url: url,\n});\n```\n\n```\n// No\ncontext.fetcher.fetch({\n  method: \"GET\",\n  url,\n});\n```\n\nThe shorthand notation that allows you to omit the value can be confusing to newer coders, especially when they need to adapt the code to work with different variable names.",
      "Avoid destructuring": "Prefer to pull values out of objects and arrays more explicitly.\n\n```\n// Yes\nlet items = response.body.items;\nlet pageToken = response.body.pageToken;\n```\n\n```\n// No\nlet {items, pageToken} = response.body;\n```\n\nThe destructuring syntax may not be familiar to newer coders, and it can easily be confused with creating an object or array.\n\n!!! note \"Exception: Parameters values\"\nDestructuring can be used to separate out the parameters of a formula, such as in the `execute` function.\n```ts\nexecute: async function([width, height], context) {\n// ...\n}\n```",
      "Always include `async` and `context` in formula execute methods": "Even when a formula doesnt require them, always declare the `execute` function as `async` and add `context` parameter.\n\n```\n// Yes\nexecute: async ([param], context) => {\n  return \"Hello World!\";\n},\n```\n\n```\n// No\nexecute: ([param]) => {\n  return \"Hello World!\";\n},\n```\n\nThis makes it easier to add in `fetcher` calls later without needing to understand asynchronous programming. While there is a slight performance impact to making a function `async` unnecessarily, and unused variables are discouraged, the benefits outweigh the costs for new users.",
      "Dont declare schemas inline": "Even if a schema is only used in one formula, declare it separately.\n\n```\n// Yes\nconst MySchema = coda.makeObjectSchema({ ... });\npack.addFormula({\n  // ...\n  schema: MySchema,\n});\n```\n\n```\n// No\npack.addFormula({\n  // ...\n  schema: coda.makeObjectSchema({ ... });\n});\n```\n\nA formula definition can already be quite long, and adding a schema can make it even harder to parse. Additionally, schemas are often reused in a pack (a formula and a sync table, for instance) so it is a best practice to separate them earlier.",
      "Use UpperCamelCase for schema variables": "Name schema constants using UpperCamelCase, like you would for a class.\n\n```\n// Yes\nconst MySchema = coda.makeObjectSchema({ ... });\n```\n\n```\n// No\nconst mySchema = coda.makeObjectSchema({ ... });\n```\n\nAlthough not technically a class, schemas are similar enough and should be treated similarly.",
      "Use the `function` keyword for most functions": "Define functions using the `function` keyword in most cases.\n\n```\n// Yes\npack.addFormula({\n  // ...\n  execute: function([a, b], context) {\n    // ...\n  },\n});\n```\n\n```\n// No\npack.addFormula({\n  // ...\n  execute: ([a, b], context) => {\n    // ...\n  },\n});\n\n// Also no\npack.addFormula({\n  // ...\n  execute([a, b], context) {\n    // ...\n  },\n});\n```\n\nThe `function` keyword makes it very clear to readers that you are defining a function. The arrow function syntax is not as obvious for newer coders, and the latter syntax is another form of object shorthand notation which is discouraged.\n\n!!! note \"Exception: Function as parameters\"\nArrow functions are allowed for anonymous functions used as parameters, like those used in `Array.filter()`, etc.\n```ts\nlet completed = items.filter(item => item.isComplete);\n```",
      "Formula key order": "The order of keys in the formula declaration should be:\n\n```\npack.addFormula({\n  name: ...,\n  description: ...,\n  parameters: ...,\n  resultType: ...,\n  // If required.\n  schema: ...,\n  items: ...,\n  isAction: ...,\n  // Anything else.\n  execute: ...,\n});\n```",
      "Object schema key order": "The order of keys in an object schema declaration should be:\n\n```\nconst MySchema = coda.makeObjectSchema({\n  properties: ...,\n  displayProperty: ...,\n  idProperty: ...,\n  featuredProperties: ...,\n  // If required.\n  identity: ...,\n  // Anything else.\n});\n```",
      "80 character max line length": "Limit lines to 80 characters. Horizontal space is limited in the Packs Editor side panel and in the Documentation, and lines more than 80 characters can lead to scroll or wrapping that makes it harder to read.\n\n[google_style]: https://developers.google.com/style\n\n[]\n\nnav: Errors\ndescription: A list of common errors your Pack can may encounter, and how to handle them.\n\n[]"
    }
  },
  "Common errors": {
    "Domain doesn't resolve to a public IP": [
      "`The given domain <domain> does not resolve to a public IP`"
    ],
    "Missing required developer tooling": [
      "`Error: not found: make`",
      "`g++: Permission denied`"
    ],
    "Invalid action": [
      "`Unable to execute invalid action`"
    ],
    "HTTP response too large {: #fetcherresponsesize}": "<!-- https://golinks.io/bug/22358 -->\n\n['`RESOURCE_EXHAUSTED: Received message larger than max`']\n\nThis error indicates that a fetcher request got back a response that is larger than the Packs runtime allows. If you are querying an external API for records, see if you can use a limit or paging parameter to get back a smaller response. If you need to work with large files you'll need to build an application outside of Packs that processes them. \n\nIf you only need a small increase in the size limit you can [contact support][support_approval] to request an adjustment.",
    "Can't upload from the CLI": [
      "`dyld: Symbol not found: _SecTrustEvaluateWithError`"
    ]
  },
  "Frequently asked questions": {
    "How do I verify ownership of the Packs redirect URI for Google OAuth verification? {: #google}": "To connect to a Google API from a Pack you need to use OAuth2 authentication. Many APIs require scopes that Google deems \"sensitive\", meaning that Google must approve your integration before other users can sign in. This approval process is known as [OAuth verification][google_verification], and involves many steps and checks.\n\n!!! info \"Exceptions\"\nThere are some [exceptions to Google's verification requirement][google_verification_exceptions], for example an app only used internally within a single organization. Check this list first before beginning the verification process.\n\nOne of the checks is that Google must verify you own the domain name for all of the domains used by the integration. This includes the redirect URI that users are sent to after they complete the approval screen. For Coda Packs this redirect URL follows the pattern:\n\n```\nhttps://coda.io/packsAuth/oauth2/{PACK ID}\n```\n\nTo meet Google's verification requirements you would need to verify ownership of the `coda.io` domain, which isn't possible. However [Google's FAQ][google_verification_line] includes this line:\n\n['Note: If you are using a third party service provider and your domain is owned by them, then you need to provide a detailed justification for us to validate it.']\n\nAlthough Google includes an exception for apps that don't own the domain of their redirect URL, it's outside the standard script the review team follows and may take some convincing. Here are some tips to help you get your integration approved:\n\n['Create a published doc for your Pack to act as the \"home page\". Ensure it, your Pack listing, and the Google consent screen branding all match (name, icon, etc).', \"Ensure you have a privacy policy published, even if it's just a minimal one. It can live in the published doc mentioned above.\", 'Record a video showing the installation and usage of the Pack.', 'In the verification form there is a field that asks for a similar app that has been verified, and you can refer them to the previously approved [Apps Script Pack][packs_apps_script], with project number 367090187070.', 'If they insist on proof of ownership of `coda.io`, quote the clause from the FAQ and mention that Coda requires that everyone uses a redirect URL hosted on `coda.io`. You can link them to [this section][oauth_redirect] of the OAuth documentation.', 'If they insist that a branded \"Google Sign-in\" button be used to start the OAuth flow, mention that the Coda platform controls these buttons and that you can\\'t change them.']\n\nWith enough persistence you should be able to get your Pack verified. The process may take a week or more to complete, so plan accordingly.",
    "Can formulas return dynamic schemas?": "No, unfortunately they can't. While [dynamic sync tables][dynamic_sync_tables] can flex their schema based upon the specific data source being connected to, this option isn't available for formulas. The schema for a formula must be declared statically, and there is no equivalent `getSchema()` function that formulas can provide.\n\nIf you have a formula that returns a dynamic set of custom fields, there are two common approaches:\n\n['Include an array of sub-objects representing the custom fields, with each containing a `name` and `value` property. Users can retrieve the value of a specific custom field using a formula like:', '```\\nTask.CustomFields.Filter(CurrentValue.Name=\"price\").First().Value\\n```', 'Include the custom fields as a block of JSON, like `{\"price\": 10}`. Users can retrieve a specific custom field using a formula like:', '```\\nTask.CustomFieldsJson.ParseJSON(\"price\")\\n```']",
    "How can I transfer ownership of a Pack?": "Packs don't have a specific owner role, so to transfer ownership you can take the following steps:\n\n['Share the Pack with the new owner, giving them **Pack admin** access.', \"[Transfer the Pack](#transfer-workspace) to the new owner's workspace, if different.\"]",
    "How can I determine which workspace a Pack belongs to?": "Although we don't display it in the Pack Studio, each Pack belongs to a specific workspace. The workspace is used by a variety of features, including determining which billing account to use when [selling a Pack][hc_selling]. The workspace is set when the Pack is created, and your default workspace is selected when using the [pack.new](https://pack.new) shortcut.\n\nTo determine which workspace your Pack belongs to open the following URL in your browser:\n\n```\nhttps://coda.io/apis/v1/packs/{PACK_ID}\n```\n\nReplace `{PACK_ID}` with the ID of your Pack. The response includes a `workspaceId` field with the ID of the workspace it belongs to. You can compare this ID with the one shown in the URL bar as you switch between workspaces in the doc list section of the UI.",
    "How can I move a Pack to another workspace? {: #transfer-workspace}": "Only the [Coda support][support_email] team can transfer a Pack to another workspace, so please reach out if you need to make a change. If the Pack already has billing enabled, transferring it to a different workspace will require additional steps, so please note it in your request to support.\n\n[google_verification]: https://support.google.com/cloud/answer/9110914\n[google_verification_exceptions]: https://support.google.com/cloud/answer/9110914#exceptions-ver-reqts&zippy=%2Cexceptions-to-verification-requirements\n[google_verification_line]: https://support.google.com/cloud/answer/9110914?hl=en#zippy=%2Chow-can-i-make-sure-the-verification-process-is-as-streamlined-as-possible\n[oauth_redirect]: ../guides/basics/authentication/oauth2.md#redirect-url\n[packs_apps_script]: https://coda.io/packs/apps-script-14470\n[dynamic_sync_tables]: ../guides/blocks/sync-tables/dynamic.md\n[support_email]: mailto:support+packstudio@coda.io\n[hc_selling]: https://help.coda.io/en/articles/6381607-selling-packs-on-coda\n\n[]\n\nnav: Support\ndescription: The support channels that exist for the Pack SDK.\n\n[]"
  },
  "How to get help": {
    "Quick questions": "For general questions about Packs, or advice on how to build them, we recommend you post in the [Coda Community \"Making Packs\" category][community_packs]. Codans actively monitor the community and answer questions, as well as other Pack makers that have experience with the platform. Posting questions and answers in a public forum helps build up a knowledge base of information that helps everyone.\n\n[Search existing questions][community_search]{: .md-button}\n[Post a new question][community_post]{: .md-button .md-button--primary}",
    "In-depth discussion": "For a deeper discussion about the specific challenges you are dealing with, we recommend booking a slot during the [Packs Office Hours][office_hours]. You'll get one-on-one time with a Coda Developer Advocate to explore new Pack ideas, talk through an issue, or share your screen and do some live debugging.\n\n[Book now][office_hours]{: .md-button .md-button--primary}",
    "Problems or bugs": "If you are experiencing a problem with your Pack or have identified a bug you can reach out to the Coda Support team. Send an email to [support+packstudio@coda.io][support_email], and include the following information:\n\n['The URL of your Pack in the Pack Studio.', 'The URL of a doc where the error occurred (make sure to [share it with support][hc_share]).', 'Any relevant error messages or snippets of code.']\n\n[Send email][support_email]{: .md-button .md-button--primary}",
    "Approvals and exemptions {: #approvals}": "<a name=\"network-domains\"></a><!-- Keep for backwards compatibility -->\n\nCertain Pack features are restricted by default and require approval before you can use them. Coda enforces these restrictions when you attempt to create a new version of your Pack. This means you can test your Pack locally using the CLI, but will need to have the approval granted before you can test in a real doc.\n\nThe following features require approval:\n\n['Sending fetcher requests to multiple [network domains][fetcher_network_domains].', 'Using [`OAuth2` authentication][authentication_url_limitations] with an authorization and token URL on different domains.', 'Using [`Custom` authentication][authentication_custom_tokens].', 'Increase the [maximum response size][errors_max_fetcher_response_size] for fetch requests.']\n\nTo request approval please fill out the form linked below. Ensure you are signed in with the same Coda account you are using to develop the Pack. We'll review your request and respond with a decision within a few business days.\n\n[Request approval][network_domains_form]{: .md-button .md-button--primary}\n\n[community_packs]: https://community.coda.io/c/15\n[community_search]: https://community.coda.io/search?q=%23making-packs\n[community_post]: https://community.coda.io/new-topic?category=making-packs\n[support_email]: mailto:support+packstudio@coda.io\n[hc_share]: https://help.coda.io/en/articles/1137949-sharing-your-doc#h_5061fdf96a\n[fetcher_network_domains]: ../guides/basics/fetcher.md#network-domains\n[network_domains_form]: https://coda.io/form/Pack-Network-Domains-Request_ddvuAhFq3IZ\n[office_hours]: https://calendly.com/ekoleda/packs-office-hours\n[authentication_custom_tokens]: ../guides/basics/authentication/index.md#custom-tokens\n[authentication_url_limitations]: ../guides/basics/authentication/oauth2.md#url-limitations\n[errors_max_fetcher_response_size]: errors.md#fetcherresponsesize\n\n[]\n\nnav: Migration\ndescription: How to upgrade to a new SDK version and what to look out for.\n\n[]"
  },
  "Migrating between SDK versions": {
    "Updating your SDK version": "The Pack Studio web editor always uses the latest release of the SDK when building Packs. To update your Pack to a new version of the SDK simply press the **Build** button to rebuild your Pack.\n\nIf you use the Pack CLI you'll need to manually update the SDK when a new version is released. To do so, run the command:\n\n```\nnpm install @codahq/packs-sdk@<version> --save\n```\n\nWhere `<version>` is the version you want to upgrade to.\n\nAfter updating the SDK locally you'll need to upload a new version of your Pack to Coda's servers:\n\n```\nnpx coda upload pack.ts\n```",
    "Deprecation warnings": "To determine if you are using a deprecated SDK feature:\n\n['If you build in the Pack Studio web editor, press the **Build** button to rebuild your Pack.', 'If you build using the Pack CLI, run the `coda validate` command on your Pack:', '```\\nnpx coda validate pack.ts\\n```']\n\nYou'll then get warnings about any deprecated features your Pack is using. Consult a migration guide or the changelog for alternatives.",
    "Migration guides": "The following sections walk you through the migration for specific versions of the SDK.\n\n['[Version 0.11.0][v0.11.0]']\n\n[changelog]: ../changes.md\n[v0.11.0]: v0.11.0.md\n\n[]\n\nnav: Version 0.11.0\ndescription: What changed and how to migrate to version 0.11.0.\n\n[]"
  },
  "Migrating to version 0.11.0": "In preparation for a public launch, we intentionally introduced a number of breaking changes to make the SDK easier to use and understand. We hope to avoid breaking changes on this scale in the future.\n\nRename schema fields `id`, `primary`, and `featured`\n\n**Affects**: Packs that define an [object schema][schemas_object].<br>\n**Action Required**: Rename only.\n\nTo better reflect their meaning, we've renamed certain fields in the schema definition. Specifically:\n\n['`id` --> `idProperty`', '`primary` --> `displayProperty`', '`featured` --> `featuredProperties`']\n\nOnly the names of these fields have changed, and it there should be no impact on the functionality of your Pack.\n\n```\nlet MovieSchema = coda.makeObjectSchema({\n  properties: {\n    title: { type: coda.ValueType.String },\n    year: { type: coda.ValueType.Number },\n    id: { type: coda.ValueType.String },\n    // ...\n  },\n  idProperty: \"id\",\n  displayProperty: \"title\",\n  featuredProperties: [\"year\"],\n  // ...\n});\n```\n\nAdd `identityName` to dynamic sync tables\n\n**Affects**: Packs that include a dynamic sync table.<br>\n**Action Required**: Add new code.\n\nLike regular sync tables, dynamic sync tables now require the `identityName` field to be set. This will be used along with the dynamic URL to set the identity of the table. You no longer need to set the `identity` field of the schema generated in the `getSchema` function, as it will be constructed for you automatically.\n\nTo avoid breaking user's existing tables, ensure you set the `identityName` field to the same value previously set in `identity.name`. If you were previously setting a different `identity.name` value depending on the `dynmaicUrl`, and your Pack uses references between dynamic sync tables, then this change will break those references. You users will need to remove the old tables from their docs and re-add them to restore the references.\n\n```\npack.addDynamicSyncTable({\n  name: \"Tasks\",\n  description: \"The tasks in the selected project.\",\n  identityName: \"Tasks\",\n  // ...\n});\n```\n\nRename `defaultValue` field of parameters\n\n**Affects**: Packs that have a parameter with a [suggested value][parameters_suggested].<br>\n**Action Required**: Rename only.\n\nTo better reflect it's meaning, we've renamed the `defaultValue` field of parameter definitions:\n\n['`defaultValue` --> `suggestedValue`']\n\nOnly the name of the field has changed, and it there should be no impact on the functionality of your Pack.\n\n```\ncoda.makeParameter({\n  type: coda.ParameterType.Number,\n  name: \"days\",\n  description: \"How many days of data to fetch.\",\n  suggestedValue: 30,\n})\n```\n\nMove `attribution` settings in schema\n\n**Affects**: Packs that define a schema that includes [`attribution`][schemas_attribution] information.<br>\n**Action Required**: Slight refactor.\n\nFor compatibility with other changes, we've relocated the attribution definitions within a schema.\n\n['`identity.attribution` --> `attribution`']\n\nOnly the location of the field has changed, and it there should be no impact on the functionality of your Pack.\n\n```\nlet TaskSchema = coda.makeObjectSchema({\n  // ...\n  attribution: [\n    {\n      type: coda.AttributionNodeType.Text,\n      text: \"Provided by Todoist\",\n    },\n  ],\n});\n```\n\nRename authentication option `SetEndpoint.getOptionsFormula`\n\n**Affects**: Packs that [prompt users for an account-specific endpoint][authentication_setendpoint].<br>\n**Action Required**: Rename only.\n\nFor consistency with the rest of the SDK we've renamed the `getOptionsFormula` of the [`SetEndpoint`][setendpoint] object:\n\n['`getOptionsFormula` --> `getOptions`']\n\nOnly the name of the field has changed, and it there should be no impact on the functionality of your Pack.\n\n```\npack.setUserAuthentication({\n  // ...\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: 'SelectEndpoint',\n    description: 'Select the site to connect to:',\n    getOptions: async function (context) {\n      // ...\n    },\n  }],\n});\n```\n\nUse new `File` parameter type for files\n\n**Affects**: Packs that accept files as parameters using the `Image` or `ImageArray` parameter types.<br>\n**Action Required**: Slight refactor.\n\nWhile previously there was no supported way to pass a non-image file as a parameter to a Pack formula, some developers may have noticed that using an `Image` or `ImageArray` parameter type would mostly work. We've now added a dedicated `File` and `FileArray` parameter for this purpose, and will eventually disable the previous loophole.\n\n```\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an file, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.File,\n      name: \"file\",\n      description: \"The file to operate on.\",\n    }),\n  ],\n  // ...\n});\n```\n\nRemove `varargsParameters` from sync tables\n\n**Affects**: Packs that have erroneously set [`varargsParameters`][parameters_vararg] on a sync table.<br>\n**Action Required**: Remove code.\n\nSync tables currently don't support [`varargsParameters`][parameters_vararg], as they aren't shown in the side panel. While we may fix this some day, for now we've introduced a validation rule to ensure they aren't set accidentally.\n\nIf any of your sync tables have `varargsParameters` set (unlikely) you'll need to remove them. Given that they weren't used anyway this should have no effect on your Pack's functionality.\n\nSet `networkDomain` on user authentication config (multi-domain only)\n\n**Affects**: Packs that use multiple [network domains][fetcher_network] (uncommon) and [per-user authentication][auth_user].<br>\n**Action Required**: Add new code.\n\nPacks that make requests to multiple network domains and have per-user authentication (`setUserAuthentication`) must now specify which domain their authentication configuration applies to. This is done to prevent credentials from leaking from one service to another. Packs using system-wide authentication (`setSystemAuthentication`) are not affected.\n\nFor affected Packs, set the [`networkDomain`][baseauthentication_networkdomain] field of the authentication config to the domain it should apply to.\n\n```\npack.addNetworkDomain(\"coda.io\");\npack.addNetworkDomain(\"example.com\");\n\npack.setUserAuthentication({\n  // ...\n  networkDomain: \"coda.io\",\n});\n```\n\nRemove manual HTTP response decompression\n\n**Affects**: Packs that receive compressed HTTP responses and are manually decompressing them.<br>\n**Action Required**: Remove code.\n\nSome external services and APIs return their responses compressed to save network bandwidth. This is indicated by the `Content-Encoding` HTTP header, which specifies the type of compression used (typically gzip or deflate). While many other HTTP libraries automatically decompress these responses for you, the Fetcher was returning the response body still in a compressed form. This required you to install a library to manually decompress the content before you could use it.\n\nAs of this SDK version the decompression will will be done automatically for you. You'll have to remove any code that was manually decompresses the responses.\n\n[parameters_vararg]: ../../guides/basics/parameters/index.md#vararg\n[fetcher_network]: ../../guides/basics/fetcher.md#network-domains\n[baseauthentication_networkdomain]: ../../reference/sdk/interfaces/core.BaseAuthentication.md#networkdomain\n[schemas_object]: ../../guides/advanced/schemas.md#object\n[setendpoint]: ../../reference/sdk/interfaces/core.SetEndpoint.md\n[authentication_setendpoint]: ../../guides/basics/authentication/index.md#setendpoint\n[schemas_attribution]: ../../guides/advanced/schemas.md#attribution\n[parameters_suggested]: ../../guides/basics/parameters/index.md#suggested\n[sync_tables_identity]: ../../guides/blocks/sync-tables/index.md#identity\n[schemas_references]: ../../guides/advanced/schemas.md#references\n[auth_user]: ../../guides/basics/authentication/index.md#user\n\n[]\n\nnav: Call an API\ndescription: Learn how to call an external API from within a Pack.\nicon: material/api\nhide:\n\n['toc\\ncSpell:words: exchangerate']\n\n[]",
  "Learn to call an API": {
    ":material-api: Select the API": "When building a Pack around data from an external API, it's usually best to first select the API and examine its capabilities and requirements, as those may have a large influence on the design of your formula.\n\nFor this Pack we'll be using the API provided by [ExchangeRate-API][exchangerate_home], which has a free plan that doesn't require any keys or credentials. As shown in their documentation, you can get the latest exchange rates using the following URL:\n\n```\nhttps://open.er-api.com/v6/latest/CAD\n```\n\nThe endpoint returns a JSON response, which includes the conversion rate for all of the currencies it supports:\n\n```\n{\n  \"result\": \"success\",\n  \"base_code\": \"CAD\",\n  \"time_last_update_utc\": \"Wed, 06 Dec 2023 00:02:31 +0000\",\n  // ...\n  \"rates\": {\n    \"AED\": 2.704071,\n    \"AFN\": 52.369208,\n    // ...\n    \"USD\": 0.736528,\n  }\n}\n```\n\nHere we see that one Canadian dollar converts to about 0.74 US dollars (at the time this request was made.) This will provide us the information we need to build our formula.",
    ":material-ruler-square-compass: Design the formula": "Looking at the inputs and outputs to the API, we could imagine a formula that takes an amount and currency code as input and returns a converted amount as a number.\n\n```\nToUSD(100, \"CAD\") ==> $79.65\n```",
    ":fontawesome-solid-laptop-code: Write the code": {
      "Try it out": "Now that the Pack is written, let's see it in action.\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nBuild the Pack and install it in a doc. Add the `ToUSD` formula to the page and fill in the parameters.\n\nIf everything is working correctly you should get back the currency value converted to dollars.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_fetcher_result.png\" srcset=\"../../../images/tutorial_fetcher_result_2x.png 2x\" class=\"screenshot\" alt=\"The formula working in a doc.\">\n\n</div>\n</section>\n\n!!! tip \"Bonus points\"\nTry adding [autocomplete][autocomplete] on the `from` parameter to provide the user with the list of supported currency codes, and [throw an error][uservisibleerror] if they input an invalid one.\n\n??? example \"View the full code\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"er-api.com\");\n\npack.addFormula({\n  name: \"ToUSD\",\n  description: \"Convert a currency to US dollars.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"amount\",\n      description: \"The amount to convert.\"\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The currency to convert from.\"\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([amount, from], context) {\n    let url =\n      \"https://open.er-api.com/v6/latest/\" + from;\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url\n    });\n    let json = response.body;\n    return json.rates.USD * amount;\n  },\n});\n```\n\n"
    },
    ":material-view-list: View the logs": "Coda logs every API request that your Pack makes, and examining those logs can be very useful when troubleshooting.\n\n=== \":material-numeric-1-circle: Open the logs\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nIn the Pack's side panel click the **View logs** button to bring up the Pack Maker Tools. If you have navigated away from the Pack's panel, click {{ coda.pack_panel_clicks }}.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_fetcher_panel.png\" srcset=\"../../../images/tutorial_fetcher_panel_2x.png 2x\" class=\"screenshot\" alt=\"Where to fine the open logs button in the panel\">\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-2-circle: View the request log entry\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nFind the most recent invocation of your formula (that isn't from the cache) and expand it to reveal the log entry for the fetch request.\n\nExpanding that log entry reveals additional metadata about the request, including the response code and duration.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_fetcher_logs.png\" srcset=\"../../../images/tutorial_fetcher_logs_2x.png 2x\" class=\"screenshot\" alt=\"The fetch request showing in the logs.\">\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-3-circle: View the HTTP response\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nClick the link **Show HTTP request details** under the log entry to bring up a dialog containing the full HTTP request and response. Expand the response body to inspect the JSON structure that was returned by the API.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_fetcher_http.png\" srcset=\"../../../images/tutorial_fetcher_http_2x.png 2x\" class=\"screenshot\" alt=\"The raw HTTP request and response.\">\n\n</div>\n</section>\n\n",
    ":material-fast-forward: Next steps": "Now that you have an understanding of how to call an external API, here are some more resources you can explore:\n\n['[Fetcher guide][fetcher] - More in-depth information about how to use the fetcher.', '[Sample code][samples_fetcher] - A collection of sample Packs that show how to use the fetcher.', '[Pack maker tools guide][pmt] - More information on how to view the logs for your Pack.']\n\n[quickstart_web]: ../get-started/web.md\n[quickstart_cli]: ../get-started/cli.md\n[tutorial_formula]: formula.md\n[exchangerate_home]: https://www.exchangerate-api.com/\n[fetcher]: ../../guides/basics/fetcher.md\n[samples_fetcher]: ../../samples/topic/fetcher.md\n[pmt]: ../../guides/development/pack-maker-tools.md\n[autocomplete]: ../../guides/basics/parameters/autocomplete.md\n[uservisibleerror]: ../../reference/sdk/classes/core.UserVisibleError.md\n\n[]\n\nnav: Basic formula\ndescription: Learn how to build a basic formula from scratch.\nicon: material/function\nhide:\n\n['toc']\n\n[]"
  },
  "Learn to build a formula": {
    ":material-ruler-square-compass: Design the formula": "Before we start writing any code, let's first think through how we want the formula to look and work. This includes the name, the inputs, the outputs, etc. For a formula that reverses text we could imagine it working like this:\n\n```\nReverse(\"Hello\") ==> \"olleH\"\n```\n\nIt's also a good time think through how it should handle edge cases, where the input is different than what we'd normally expect. For example, empty inputs, large amounts of data, etc.\n\n```\nReverse(\"a\") ==> \"a\"\nReverse(\"\") ==> \"\"\n```\n\nNow that we have a destination in mind, let's get coding!",
    ":material-crane: Scaffold the formula": {
      "Try it out": "<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nWith the scaffold complete you can now build your Pack and give it a spin. Install your Pack in a doc and try out one of the use cases you defined at the start.\n\nYou should see the name, description, and parameters in the help text, get back the placeholder string as expected.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_formula_scaffold.png\" srcset=\"../../../images/tutorial_formula_scaffold_2x.png 2x\" class=\"screenshot\" alt=\"Working scaffold\">\n\n</div>\n</section>\n\n??? tip \"Tip: Slash command\"\nWhen you write Packs using the Pack Studio web editor you can use the slash command `/addFormula` to generate the scaffolding for you!\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of using the addFormula slash command.\" class=\"screenshot\"><source src=\"../../../images/tutorial_formula_slash.mp4\" type=\"video/mp4\"></source></video>\n\n"
    },
    ":fontawesome-solid-laptop-code: Write the logic": {
      "Try it out": "<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nRebuild your Pack, and refresh the formula the formula in the doc. If everything is working correctly you'll now see it reversing text as expected!\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_formula_logic.png\" srcset=\"../../../images/tutorial_formula_logic_2x.png 2x\" class=\"screenshot\" alt=\"The logic working.\">\n\n</div>\n</section>\n\n??? example \"View the full code\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"Reverse\",\n  description: \"Reverses some text.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to reverse.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    let [text] = args;\n    return text.split(\"\").reverse().join(\"\");\n  },\n});\n```\n\n"
    },
    ":material-plus-box: Add another feature": {
      "Try it out": "<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nRebuild your Pack, and try out the new `byWord` parameter in a formula. If everything is working correctly when you set that parameter to true it should now reverse word-by-word.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_formula_feature.png\" srcset=\"../../../images/tutorial_formula_feature_2x.png 2x\" class=\"screenshot\" alt=\"The new feature working.\">\n\n</div>\n</section>\n\n??? example \"View the full code\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"Reverse\",\n  description: \"Reverses some text.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to reverse.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"byWord\",\n      description: \"Whether to split by word.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    let [text, byWord = false] = args;\n    let separator = \"\";\n    if (byWord) {\n      separator = \" \";\n    }\n    return text.split(separator).reverse().join(separator);\n  },\n});\n```\n\n"
    },
    ":material-fast-forward: Next steps": "Now that you have an understanding of how to build formulas, here are some more resources you can explore:\n\n['[Formulas guide][formulas] - More in-depth information about how formulas are structured.', '[Sample code][samples_formulas] - A collection of example formulas you can examine or try.', '[Parameters guide][parameters] - An overview of all the available parameter types, and some advanced features.', '[Data types guide][data_types] - Information on the result types that formulas can return.']\n\n[quickstart_web]: ../get-started/web.md\n[quickstart_cli]: ../get-started/cli.md\n[mdn_destructuring]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n[formulas]: ../../guides/blocks/formulas.md\n[samples_formulas]: ../../samples/topic/formula.md\n[parameters]: ../../guides/basics/parameters/index.md\n[data_types]: ../../guides/basics/data-types.md\n[javascript_key_value]: https://javascript.info/object\n\n[]\n\nnav: Using OAuth2\ndescription: Learn how to access private data in an API using OAuth2.\nicon: material/shield-key\nhide:\n\n['toc']\n\n[]"
  },
  "Learn to authenticate with an API using OAuth2": {
    ":material-shield-key: What is OAuth2?": "[OAuth][oauth] is a standard way for a user to connect one application to another, without needing to share their password. [OAuth2][oauth2] is the most recent version of the protocol, and has been widely adopted across the industry.\n\nTo learn about why OAuth was created an how it works at a high level, we recommend watching one of the following videos:\n\n['[\"What is OAuth and why does it matter?\"][youtube_oktadev]', '[\"What is OAuth really all about\"][youtube_javabrains]']",
    ":material-book-open-variant: Read the API docs": "Although OAuth2 is a standard, there is a lot of variation in how APIs choose to implement it. When working with a new API, first consult their OAuth2 documentation carefully to determine the specific requirements.\n\nTodoist describes their OAuth2 support [in their developer docs][todoist_oauth]. There are a few key pieces of information you need to obtain from their documentation:\n\n=== \":material-numeric-1-circle: Authorization URL\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nTo start the OAuth2 flow, the user is directed to the website of the API provider to sign in and/or grant access to the application. The URL to open in the user's browser is called the authorization URL.\n\nFor Todoist this URL is\n\n```\nhttps://todoist.com/oauth/authorize\n```\n\nThe `client_id`, `scope`, and `state` parameters mentioned in the documentation will be added automatically by the Pack.\n\n</div>\n<div markdown>\n\n<a href=\"https://developer.todoist.com/guides/#step-1-authorization-request\">\n  <img src=\"../../../images/tutorial_oauth_authorization_url.png\" srcset=\"../../../images/tutorial_oauth_authorization_url_2x.png 2x\" class=\"screenshot\" alt=\"The documentation for the authorization URL.\">\n</a>\n\n</div>\n</section>\n\n\n=== \":material-numeric-2-circle: Token URL\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nAfter the user approves the access request, the Pack is given a temporary code that can be exchanged for an access token. To perform that exchange the Pack makes a request to the API's token URL.\n\nFor Todoist this URL is\n\n```\nhttps://todoist.com/oauth/access_token\n```\n\nThe `client_id`, `client_secret`, and `code` parameters mentioned in the documentation will be added automatically by the Pack.\n\n</div>\n<div markdown>\n\n<a href=\"https://developer.todoist.com/guides/#step-3-token-exchange\">\n  <img src=\"../../../images/tutorial_oauth_token_url.png\" srcset=\"../../../images/tutorial_oauth_token_url_2x.png 2x\" class=\"screenshot\" alt=\"The documentation for the token URL.\">\n</a>\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-3-circle: Scopes\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nMany APIs allow the application to request access to only a limited set of permissions, which are shown to the user when approving access. A scope is an identifier that corresponds to a given permission or set of permissions in the API.\n\nThe Todoist API supports a few different scopes. When building a Pack it's usually best to request the most narrow scope that allows your Pack to function. Our Pack only requires reading the user's tasks, so the `data:read` scope is sufficient.\n\n</div>\n<div markdown>\n\n<a href=\"https://developer.todoist.com/guides/#step-1-authorization-request\">\n  <img src=\"../../../images/tutorial_oauth_scopes.png\" srcset=\"../../../images/tutorial_oauth_scopes_2x.png 2x\" class=\"screenshot\" alt=\"The documentation for the scopes.\">\n</a>\n\n</div>\n</section>\n\n\n=== \":material-numeric-4-circle: Additional requirements\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nWhile the [OAuth2 standard][oauth_standard] provides a common foundation, many providers add their own unique requirements that need to be accounted for. Learning to spot these can be difficult, especially if you are new to OAuth2 and don't know what \"normal\" OAuth2 entails.\n\nThe Todoist API deviates from the standard by requiring that scopes be comma-separated, instead of the default space-separated. Although we currently only plan to use one scope, this is important to note if our Pack later requires additional permissions.\n\n</div>\n<div markdown>\n\n<a href=\"https://developer.todoist.com/guides/#step-1-authorization-request\">\n  <img src=\"../../../images/tutorial_oauth_scope_comma.png\" srcset=\"../../../images/tutorial_oauth_scope_comma_2x.png 2x\" class=\"screenshot\" alt=\"The documentation for the scope separator.\">\n</a>\n\n</div>\n</section>\n\n",
    ":material-application-edit: Register your application": {
      "Hold tight": "There is a bit more configuration needed to complete the application setup, but we'll get to that in a later step. Keep this tab open as you'll need to refer back to it later."
    },
    ":material-ruler-square-compass: Design the formula": "You're just about ready to start writing code, but before diving in let's design the formula behavior.\n\nThe [Todoist API documentation][todoist_tasks] provides an endpoint for listing tasks, which doesn't require any parameters. The API returns a bunch of metadata for each task, but for simplicity let's just return the text of the task itself.\n\n```\nTasks() ==> [\"Pick up milk\", \"Walk the dog\", \"Clean the bathroom\"]\n```",
    ":fontawesome-solid-laptop-code: Write the code": {
      "Build the Pack": "All the code is written, but we're not ready to start using the Pack just yet. Build a new version of the Pack before moving on to the next step.\n\n??? example \"View the full code\"\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read\"],\n  scopeDelimiter: \",\",\n});\n\npack.addFormula({\n  name: \"Tasks\",\n  description: \"A list of your current tasks.\",\n  parameters: [],\n  resultType: coda.ValueType.Array,\n  items: { type: coda.ValueType.String },\n  execute: async function ([], context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n    });\n    let tasks = response.body;\n    let results = [];\n    for (let task of tasks) {\n      results.push(task.content)\n    }\n    return results;\n  },\n});\n```\n\n"
    },
    ":material-key-plus: Add credentials": "In the software world it's a best practice to keep your credentials separate from your code. This makes it easier to share your code with others, and allows you to update credentials quickly in they are compromised and need to be reset.\n\nThe code we've written so far includes only public information about the OAuth flow, but the last step is to enter the private credentials (client ID and secret) associated with your Todoist application.\n\n=== \":material-numeric-1-circle: Open Pack settings\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nClick on the **Settings** tab on the left side of the Pack Studio to bring up the settings for your Pack.\n\nClick the **Add OAuth Credentials** button. If you don't see this button, make sure you have built a new version of your Pack that includes the OAuth configuration code.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_oauth_pack_settings.png\" srcset=\"../../../images/tutorial_oauth_pack_settings_2x.png 2x\" class=\"screenshot\" alt=\"The Pack settings\">\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-2-circle: Copy redirect URL\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nThe field **Redirect URL** shows the redirect URL for your Pack. This is the URL that Todoist should send users back to after they have approved access to their account.\n\nClick the copy icon (:material-clipboard-outline:) next to the redirect URL to copy it to your clipboard.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_oauth_pack_redirect.png\" srcset=\"../../../images/tutorial_oauth_pack_redirect_2x.png 2x\" class=\"screenshot\" alt=\"The redirect URL shown in the OAuth settings\">\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-3-circle: Edit application settings\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nGo back to your application settings in the Todoist App Management Console.\n\nSet the **OAuth redirect URL** field to the value you copied above and click the **Save settings** button. Todoist will use this to verify that no other applications use this set of credentials.\n\nNext copy the **Client ID** and **Client secret** shown on that screen. We need to provide this to your Pack so Coda can properly identify it during the OAuth flow.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_oauth_settings.png\" srcset=\"../../../images/tutorial_oauth_settings_2x.png 2x\" class=\"screenshot\" alt=\"The settings for the new application\">\n\n</div>\n</section>\n\n\n\n=== \":material-numeric-4-circle: Set credentials\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nBack in the **Add OAuth credentials** dialog open in the Pack Studio, enter the client ID and secret you copied.\n\nClick the **Save** button.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_oauth_pack_credentials.png\" srcset=\"../../../images/tutorial_oauth_pack_credentials_2x.png 2x\" class=\"screenshot\" alt=\"Entering the OAuth credentials\">\n\n</div>\n</section>\n\n",
    ":fontawesome-solid-user-check: Sign in": {
      "Try it out": "<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nAdd the `Tasks()` formula to the doc. If everything is working correctly you should see a list of tasks from your Todoist account.\n\nYou'll notice that it takes in an account as a parameter, and it should auto-select the account you just connected. This account parameter will appear before any other parameters you defined for the formula.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_oauth_formula.png\" srcset=\"../../../images/tutorial_oauth_formula_2x.png 2x\" class=\"screenshot\" alt=\"Use the formula in a doc\">\n\n</div>\n</section>"
    },
    ":material-fast-forward: Next steps": "Now that you have an understanding of how to use OAuth2 in Packs, here are some more resources you can explore:\n\n['[Authentication guide][authentication] - Information about how authentication works in Packs.', '[OAuth guide][oauth_guide] - More in-depth information about how to setup OAuth authentication.', '[Sample code][samples_apis] - A collection of sample Packs that use OAuth2 to connect to various popular APIs.']\n\n[quickstart_web]: ../get-started/web.md\n[quickstart_cli]: ../get-started/cli.md\n[tutorial_fetcher]: fetcher.md\n[oauth]: https://oauth.net/\n[oauth2]: https://oauth.net/2/\n[youtube_oktadev]: https://www.youtube.com/watch?v=KT8ybowdyr0&t=227s\n[youtube_javabrains]: https://www.youtube.com/watch?v=t4-416mg6iU\n[todoist_oauth]: https://developer.todoist.com/guides/#oauth\n[todoist_console]: https://developer.todoist.com/appconsole.html\n[oauth_standard]: https://datatracker.ietf.org/doc/html/rfc6749\n[todoist_tasks]: https://developer.todoist.com/rest/v2/#get-active-tasks\n[authentication]: ../../guides/basics/authentication/index.md\n[samples_apis]: ../../samples/topic/apis.md\n[oauth_guide]: ../../guides/basics/authentication/oauth2.md\n\n[]\n\nnav: Sync table\ndescription: Learn how to build a sync table of external data.\nicon: material/table-sync\nhide:\n\n['toc\\ncSpell:words: Gutendex gutendex']\n\n[]"
  },
  "Learn to build a sync table": {
    ":material-api: Understand the API": "[Project Gutenberg][gutenberg] is a library of over 60,000 free eBooks, with a website to browse and download them. They don't offer an API to access the data in their collection, but the related project [Gutendex][gutendex] does. It provides one endpoint, which lists the available books\n\n```\nhttps://gutendex.com/books\n```\n\nIt supports a variety for query parameters for filtering the results, for example by topic:\n\n```\nhttps://gutendex.com/books?topic=Cooking\n```\n\nThe endpoint returns a JSON response which includes some metadata about the query and the details of the matching books:\n\n```\n{\n  \"count\": 308,\n  \"next\": \"https://gutendex.com/books/?page=2&topic=Cooking\",\n  \"previous\": null,\n  \"results\": [\n    {\n      \"id\": 29728,\n      \"title\": \"Cookery and Dining in Imperial Rome\",\n      \"authors\": [\n        {\n          \"name\": \"Apicius\",\n          \"birth_year\": null,\n          \"death_year\": null\n        }\n      ],\n      \"translators\": [\n        {\n          \"name\": \"Vehling, Joseph Dommers\",\n          \"birth_year\": 1879,\n          \"death_year\": 1950\n        }\n      ],\n      \"subjects\": [\n        \"Cookbooks\",\n        \"Cooking, Roman -- Early works to 1800\"\n      ],\n      \"bookshelves\": [\n        \"Cookbooks and Cooking\"\n      ],\n      \"languages\": [\n        \"en\"\n      ],\n      \"copyright\": false,\n      \"media_type\": \"Text\",\n      \"formats\": {\n        \"text/plain; charset=utf-8\": \"https://www.gutenberg.org/files/29728/29728-0.txt\",\n        \"application/x-mobipocket-ebook\": \"https://www.gutenberg.org/ebooks/29728.kindle.images\",\n        \"application/rdf+xml\": \"https://www.gutenberg.org/ebooks/29728.rdf\",\n        \"application/epub+zip\": \"https://www.gutenberg.org/ebooks/29728.epub.images\",\n        \"text/plain; charset=us-ascii\": \"https://www.gutenberg.org/files/29728/29728.txt\",\n        \"text/html\": \"https://www.gutenberg.org/ebooks/29728.html.images\",\n        \"text/html; charset=iso-8859-1\": \"https://www.gutenberg.org/files/29728/29728-h/29728-h.htm\",\n        \"text/plain; charset=iso-8859-1\": \"https://www.gutenberg.org/files/29728/29728-8.txt\",\n        \"image/jpeg\": \"https://www.gutenberg.org/cache/epub/29728/pg29728.cover.small.jpg\",\n        \"application/zip\": \"https://www.gutenberg.org/files/29728/29728-h.zip\"\n      },\n      \"download_count\": 2308\n    },\n    // ... 31 more results ...\n  ]\n}\n```\n\nHere you can see that there are 308 books on the topic of cooking, returned in pages of 32 at a time. The `next` link provides the URL you can use to fetch the next page of results in the set. The `next` link is null when there are no pages left to fetch:\n\n```\nhttps://gutendex.com/books/?page=10&topic=Cooking\n```\n\n```\n{\n  \"count\": 308,\n  \"next\": null,\n  \"previous\": \"https://gutendex.com/books/?page=9&topic=Cooking\",\n  \"results\": [\n    // ...\n  ]\n}\n```\n\nMany APIs paginate their data like this, since most platforms have a maximum HTTP response size and they need to provide a way to fetch the full set.",
    ":material-ruler-square-compass: Design the sync table": "The goal is to create a sync table called \"Books\" that has a row for each book in the collection. Optionally allow users to filter the collection down to a specific topic. For each book include the following columns:\n\n['Title', 'Authors', 'Subjects', 'Link', 'Thumbnail']\n\nThe API returns more data than that, but you don't need to expose it all in our sync table.",
    ":material-crane: Scaffold the sync table": "Start by scaffolding out the structure of the sync table, coming back to some of the details later.\n\n=== \":material-numeric-1-circle: Add the boilerplate\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nAdd the standard Pack boilerplate and declare the network domain.\n\nThen add a sync table definition to your Pack using the `addSyncTable()` method. This method takes in a set of [key-value pairs][javascript_key_value] that configure the various settings of the sync table.\n\n</div>\n<div markdown>\n\n```ts\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"gutendex.com\");\n\npack.addSyncTable({\n\n});\n```\n\n</div>\n</section>\n\n\n=== \":material-numeric-2-circle: Set the properties\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nThe first key-value pairs to set are the name and description of the sync table, both of which will be visible to users of the Pack. For the name use a plural noun corresponding to what the rows represent, \"Books\" in this case.\n\nNext set the field `identityName`. This acts as the unique ID for this sync table, which is used for creating references between sync tables. It is not visible to the user, but the normal convention is to use the singular version of the sync table name.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"7-9\"}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"gutendex.com\");\n\npack.addSyncTable({\n  name: \"Books\",\n  description: \"Lists books in the collection.\",\n  identityName: \"Book\",\n});\n```\n\n</div>\n</section>\n\n\n=== \":material-numeric-3-circle: Set the schema\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nThe sync table's schema defines the structure of each row in the table. You'll define the schema in a later step, but for now just pencil in a name.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"10\"}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"gutendex.com\");\n\npack.addSyncTable({\n  name: \"Books\",\n  description: \"Lists books in the collection.\",\n  identityName: \"Book\",\n  schema: BookSchema,  // TODO: Define this schema.\n});\n```\n\n</div>\n</section>\n\n\n=== \":material-numeric-4-circle: Add the sync formula\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nA sync table definition contains a formula definition, known as the sync formula, which does the actual fetching of the data. It's similar to regular formula, but with a few key differences:\n\n- The name and description are never shown to the user (but are still required).\n- It doesn't declare a `resultType`, since it returns a special type used by sync tables.\n\nYou'll write the syncing logic later, so for now just place a TODO comment in the code.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"11-18\"}\nimport * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"gutendex.com\");\n\npack.addSyncTable({\n  name: \"Books\",\n  description: \"Lists books in the collection.\",\n  identityName: \"Book\",\n  schema: BookSchema,  // TODO: Define this schema.\n  formula: {\n    name: \"SyncBooks\",\n    description: \"Syncs the books.\",\n    parameters: [],\n    execute: async function (args, context) {\n      // TODO: Write sync logic.\n    },\n  },\n});\n```\n\n</div>\n</section>\n\n\n[]\n\nYou now have the basic structure of the sync table itself. Your code still won't build at this point, but it's a good start!",
    ":material-table-sync: Write the sync formula": "With the structure set up, you can now write the code that fetches the rows.\n\n=== \":material-numeric-1-circle: Define a topic parameter\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nTo allow users to optionally filter the collection by subject, add a `topic` parameter to the sync formula. This will be displayed as an option in the sync table's side panel.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"7-12\"}\npack.addSyncTable({\n  // ...\n  formula: {\n    name: \"SyncBooks\",\n    description: \"Syncs the books.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"topic\",\n        description: \"Limit books to this topic.\",\n        optional: true,\n      }),\n    ],\n    execute: async function (args, context) {\n      // TODO: Write sync logic.\n    },\n  },\n});\n```\n\n</div>\n</section>\n\n\n=== \":material-numeric-2-circle: Fetch the data\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nMove on to the `execute` function, which is run every time the table needs to sync.\n\nFirst retrieve the value of the `topic` parameter, if set. Then use it to construct the API URL to fetch.\n\nFinally, use the fetcher to make a request to that URL.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"6-14\"}\npack.addSyncTable({\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      let [topic] = args;\n      let baseUrl = \"https://gutendex.com/books\";\n      let url = coda.withQueryParams(baseUrl, {\n        topic: topic,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n    },\n  },\n});\n```\n\n</div>\n</section>\n\n\n=== \":material-numeric-3-circle: Return the rows\"\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nNow that you have the API response you need to extract the row data from it. The rows you want to return are in the JSON response body under the key `results`.\n\nThe sync table expects the rows to be returned in an object, under the key `result`. The return value for a sync table must always match this pattern.\n\n</div>\n<div markdown>\n\n```{.ts hl_lines=\"15-18\"}\npack.addSyncTable({\n  // ...\n  formula: {\n    // ...\n    execute: async function (args, context) {\n      let [topic] = args;\n      let baseUrl = \"https://gutendex.com/books\";\n      let url = coda.withQueryParams(baseUrl, {\n        topic: topic,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let rows = response.body.results;\n      return {\n        result: rows,\n      };\n    },\n  },\n});\n```\n\n</div>\n</section>\n\n\n[]\n\nYour Pack can now fetch the matching books and return them as rows. The code still won't build until you define the schema, so onwards!",
    ":material-format-list-group: Define the schema": {
      "Try it out": "Now that the schema is finished you're finally ready to see the sync table in action.\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nBuild the Pack and install it in a doc. Drag the **Books** table on to the page and click the **Sync now** button.\n\nIf everything is working correctly you should get a table with 32 books in it. Hovering over the chip in the first column will show the title and ID of the book.\n\nTo filter to a specific topic, open the sync option for the table, click **Add criteria** > **Topic**, enter a topic (like \"Cooking\") and click **Sync now**.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_sync_table_build1.png\" srcset=\"../../../images/tutorial_sync_table_build1_2x.png 2x\" class=\"screenshot\" alt=\"The resulting sync table with name and ID fields\">\n\n</div>\n</section>\n\n??? example \"View the full code\"\n```ts\n--8<-- \"samples/packs/tutorials/sync-table/build1.ts\"\n```"
    },
    ":material-table-plus: Extend the schema": {
      "Try it out": "Let's see how your sync table looks with these additional properties.\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nRebuild the Pack. Remove the existing **Books** sync table from the doc and drag it in again (featured columns are only used when you first drag in the table). Click **Sync now**.\n\nIf everything is working correctly you should have additional columns in your table, correctly populated with the author, subjects, link and thumbnail.\n\nThe author column displays as a chip, since it's a rich object itself, and hovering over it reveals the information within.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_sync_table_build2.png\" srcset=\"../../../images/tutorial_sync_table_build2_2x.png 2x\" class=\"screenshot\" alt=\"The resulting sync table with more fields\">\n\n</div>\n</section>\n\n??? example \"View the full code\"\n```ts\n--8<-- \"samples/packs/tutorials/sync-table/build2.ts\"\n```"
    },
    ":material-page-previous-outline: Sync more pages": {
      "Try it out": "Now that you've added in continuations, see if you can fetch the full set of results.\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nRebuild the Pack and then click refresh icon (:material-refresh:) in the sync table.\n\nIf everything is working correctly you should have more than 32 rows in your sync table.\n\nThe Pack maker tools will show multiple executions of the sync formula, with those after the first marked as continuations.\n\n!!! info \"Truncated results\"\nSync tables have a maximum number of rows they can store, which varies depending on what Coda plan you are subscribed to. When your sync hits that limit the sync formula will be terminated, even if you returned another continuation.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_sync_table_build3.png\" srcset=\"../../../images/tutorial_sync_table_build3_2x.png 2x\" class=\"screenshot\" alt=\"The resulting sync table with more rows\">\n\n</div>\n</section>\n\n??? example \"View the full code\"\n```ts\n--8<-- \"samples/packs/tutorials/sync-table/build3.ts\"\n```"
    },
    ":material-fast-forward: Next steps": "Now that you have an understanding of how to build a sync table, here are some more resources you can explore:\n\n['[Sync tables guide][sync_table] - More in-depth information about how sync tables work.', '[Sample code][samples_sync_table] - A collection of sample Packs that contain sync tables.', '[Schemas guide][schemas] - Designing a schema are a core part of building a sync table, and this guide covers schemas in more depth.']\n\n[gutenberg]: https://www.gutenberg.org\n[quickstart_web]: ../get-started/web.md\n[quickstart_cli]: ../get-started/cli.md\n[tutorial_fetcher]: fetcher.md\n[gutendex]: https://gutendex.com\n[javascript_key_value]: https://javascript.info/object\n[sync_table]: ../../guides/blocks/sync-tables/index.md\n[samples_sync_table]: ../../samples/topic/sync-table.md\n[schemas]: ../../guides/advanced/schemas.md\n\nTo create a Pack you will need a Coda account, with [Doc Maker access][hc_doc_maker] in your workspace. If you're new to Coda, [sign up][sign_up] for a free account and you'll automatically be made a Doc Maker in your personal workspace.\n\nThe instructions below assume some familiarity with the terminal / command prompt. If you aren't used to using this interface consult the help material for your operating system.\n\n[hc_doc_maker]: https://help.coda.io/en/articles/3388781-members-and-roles\n[sign_up]: https://coda.io/signup\n\nOne of the advantages of developing with the CLI is that you can test your Pack code without having to upload it to Coda's servers. Let's test the `Hello` formula in the Pack:\n\n```\nnpx coda execute pack.ts Hello \"World\"\n```\n\nIf everything works correctly this should output `Hello World!`.",
    "Upload the Pack": {
      "Register an API token": "The `coda` CLI uses the Coda API under the hood to upload your code, and likewise needs an API token to operate. Registering an API token is a one-time setup step.\n\n['Register an API key for Pack uploads:', '```\\nnpx coda register\\n```', 'When prompted to create a new API token, type `y` and hit enter.', 'This will open your browser to the API token creation dialog. If your browser fails to open, [click this link][coda_api_token]{ target=\"_blank\" } instead.', 'In the **Name** field enter \"Hello World Pack\" and then click **Generate API token**.', 'In the **Coda API tokens** section, find the token you just created, and click the **Copy token** link.', 'Switch back to your terminal, paste your token into the prompt, and hit enter.']\n\nThis will create a new file `.coda.json` in your working directory that contains the API token.",
      "Create the Pack": "Now that you have the access configured you can create the new Pack on Coda's servers. This setup step that needs to be done for each Pack you create.\n\n```\nnpx coda create pack.ts --name \"Hello World\" --description \"My first Pack.\"\n```\n\n??? info \"Edit your branding later\"\nThe `name` and `description` arguments are optional and can be changed later in the Pack Studio's **Listing** tab, along with a variety of other branding options.\n\nThis will create a new, empty Pack on Coda's servers and output its URL in the Pack Studio. It stores the Pack's ID in the new file `.coda-pack.json`.",
      "Upload the first version": "Now that you've established access and created the empty Pack, you're finally ready to upload your code.\n\n```\nnpx coda upload pack.ts --notes \"Initial version.\"\n```\n\n??? warning \"Source code not available\"\nIf you open your Pack in the online Pack Studio code editor you'll see a message like:\n\n```ts\n// Source code is not available for Pack versions uploaded from the command line interface (CLI).\n```\n\nThis is expected, since the CLI will only upload the built Pack and not the source code.\n\n"
    },
    "Install and use the Pack": "Your new Pack is now available to use in all your docs, and you can install it just like any other Pack. Let's create a new document and install it:\n\n['Open [Coda][coda_home] in your browser.', 'Click the **+ New doc** button and select **Start blank doc**.', 'In your doc, click **Insert**, then **Packs**.', 'Find your new Pack, **Hello World**, and click on it.', 'This will open a dialog with more information about the Pack.', 'Click the **Install** button in the upper right.']\n\n--8<-- \"tutorials/get-started/.use.md\"",
    "Update the Pack": "Now that you have your Pack up and running let's make a change to how it works.\n\n['Back in your code editor, open `pack.ts` and update it to say \"Howdy\" instead of \"Hello\":', '=== \"formulas.ts\"\\n```ts hl_lines=\"2\"\\nexecute: function ([name]) {\\nreturn \"Howdy \" + name + \"!\";\\n},\\n```', 'Run your code locally to ensure it works:', '```\\nnpx coda execute pack.ts Hello \"World\"\\n```', 'This should output `Howdy World!`.', 'Run `coda upload` again to upload a new version.', '```\\nnpx coda upload pack.ts --notes \"Changed to Howdy.\"\\n```', 'When the upload has completed, switch back to your test document.', \"You'll notice that the formula is still returning `Hello World!`, and that's because formulas aren't automatically recalculated when you update your Pack code.\"]\n\n--8<-- \"tutorials/get-started/.rebuild.md\"\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of adding a dynamic sync table.\" class=\"screenshot\"><source src=\"../../../images/cli_rebuild.mp4\" type=\"video/mp4\"></source></video>",
    "Next steps": "You've built your fist Pack, congrats!  Now that you have some experience with the mechanics of building and using Packs, here are some recommended next steps:\n\n['Learn about Pack basics by reading through the [available guides][guides].', 'Check out the [example Packs][github_examples] built using the CLI, as well as the other [code samples][samples].', 'Dive deeper into the command line tool by reading the [CLI guide][cli].']\n\n[template_pack]: https://github.com/coda/packs-examples/tree/main/examples/template\n[coda_home]: https://coda.io/docs\n[cli]: ../../guides/development/cli.md\n[github_examples]: https://github.com/coda/packs-examples\n[samples]: ../../samples/topic/formula.md\n[guides]: ../../guides/blocks/formulas.md\n[coda_api_token]: https://coda.io/account?openDialog=CREATE_API_TOKEN&scopeType=pack#apiSettings\n\n[\"In the Pack's panel, click the **About** tab.\", 'The **INSTALLED** version of the Pack should now read **v2**.', '??? info \"Re-opening the Pack\\'s panel\"\\n<!-- Update the line below when the variable coda.pack_panel_clicks is changed in mkdocs.yml. -->\\nIf you have navigated away from the Pack\\'s panel, click **Insert** > **Packs** > **{Pack name}**.', 'Click the **View logs** button.', 'In the Pack maker tools bar, click the three dots icon :material-dots-vertical: and then **:material-refresh: Refresh Pack formulas and tables**.', 'A **Syncing...** indicator will appear at the top of the screen while the formulas are being refreshed.']\n\nYour formula result should now be `Howdy World!`.\n\n!!! tip\nTo avoid having to manually refresh the formulas on every update, click the gear icon :material-cog-outline: in the Pack maker toolbar and toggle on the **AUTO-REFRESH**  setting.\n\n['Drag the **Hello** formula from the panel on the right into your doc.', '??? info \"Alternative: Type the formula\"\\nPlace your cursor in the doc and type `=Hello`, and then press the tab key to select formula from your Pack.', 'Complete the formula by passing in a **name** value, such as `Hello(\"World\")`, and hit enter.']\n\nIf everything has gone right you should see the result `Hello World` as the output of your formula.\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of using the new Pack.\" class=\"screenshot\"><source src=\"../../../images/web_ide_use.mp4\" type=\"video/mp4\"></source></video>\n\n!!! tip\nFor a more personalized message, try changing the formula to `Hello(User())`.\n\n[]\n\nnav: On your local machine\ndescription: Build your first Pack on your local machine using the CLI.\nicon: octicons/terminal-16\n\n[]"
  },
  "Get started on your local machine": {
    "Before you get started": "Make sure you have `node` and `npm` available on your machine. These two tools often come bundled together, and more information on how to install them is available in the [npm docs][npm_install].\n\n--8<-- \"tutorials/get-started/.cli-before.md\"",
    "Create a directory": "Installing the SDK and creating a Pack creates multiple files, so you'll want to make sure you are working in a clean directory.\n\n```\nmkdir my-pack\ncd my-pack\n```",
    "Initialize the Pack": [
      "Initialize the project.",
      "```\nnpm init\n```",
      "Install the Pack SDK.",
      "```\nnpm install --save @codahq/packs-sdk\n```",
      "The Pack SDK includes both the `coda` CLI as well as the libraries and type definitions needed to build Packs.",
      "Create the file structure for your Pack.",
      "```\nnpx coda init\n```",
      "The `coda init` command creates the basic skeleton of a Pack based off of our [template Pack][template_pack]. It's not required, but it's a fast way to get started."
    ],
    "Add code to the Pack": "Now that you've got the basic structure of a Pack it's time to add some code. In this tutorial you'll be creating a simple \"Hello World\" Pack with a single formula.\n\nReplace the contents of `pack.ts` with the following code, which adds a \"Hello\" formula:\n\n=== \"pack.ts\"\n```ts\n--8<-- \"samples/packs/hello_world/hello_world.ts\"\n```\n\nTake a moment to read through the code and comments and get an understanding of how a formula is structured.",
    "Test the Pack": "--8<-- \"tutorials/get-started/.cli-test.md\"\n\n--8<-- \"tutorials/get-started/.cli.md\"\n\n[vs_code]: https://code.visualstudio.com/\n[github]: https://github.com\n[npm]: https://www.npmjs.com/\n[libraries]: ../../guides/development/libraries.md\n[npm_install]: https://docs.npmjs.com/downloading-and-installing-node-js-and-npm\n[isolated_vm_requirements]: https://github.com/laverdet/isolated-vm#requirements\n[template_pack]: https://github.com/coda/packs-examples/tree/main/examples/template\n\n[]\n\nnav: With GitHub\ndescription: Build your first Pack using GitHub Codespaces and the CLI.\nicon: octicons/mark-github-16\ncSpell:words: Codespaces codespace\n\n[]"
  },
  "Get started with GitHub Codespaces": {
    "Before you get started": "You will need a GitHub account in order to create a Pack using Codespaces. If you don't already have one you can [sign up][github_signup] for free on their website.\n\n--8<-- \"tutorials/get-started/.cli-before.md\"",
    "Create a codespace": "<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nClick the button below to create a new repository from the [Packs starter project][github_packs_starter] template.\n\n[Create repository][github_use_template]{ .md-button .md-button--primary target=\"_blank\" }\n\nName the new repository \"hello-pack\", set the visibility to **Private**, and then click the button **Create repository from template**.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_github_repo.png\" srcset=\"../../../images/tutorial_github_repo_2x.png 2x\" class=\"screenshot\" alt=\"Create a repository from the template.\">\n\n</div>\n</section>\n\n[]\n\n<section class=\"tutorial-row\" markdown>\n<div markdown>\n\nFrom you new repository click the button **Code**. In the resulting dropdown menu select the tab **Codespaces** tab and then click the button **Create codespace on main**.\n\n</div>\n<div markdown>\n\n<img src=\"../../../images/tutorial_github_codespace.png\" srcset=\"../../../images/tutorial_github_codespace_2x.png 2x\" class=\"screenshot\" alt=\"Create a codespace for your repo.\">\n\n</div>\n</section>\n\n[]\n\nIt may take a few minutes for the codespace to fully initialize and install the dependencies. When it's complete you will see a `pack.ts` file in your codespace, and you should take a moment to read through it.",
    "Test the Pack": "--8<-- \"tutorials/get-started/.cli-test.md\"\n\n--8<-- \"tutorials/get-started/.cli.md\"\n\n!!! info \"Save your work\"\nYour Pack code will be preserved in the codespace, but it's a good idea to publish it to a GitHub repository as well. You can read more about this in the [GitHub documentation][github_codespace_template].\n\n[github_codespaces]: https://github.com/features/codespaces\n[github_signup]: https://github.com/signup\n[github_new]: https://github.com/new\n[github_use_template]: https://github.com/coda/packs-starter/generate\n[github_packs_starter]: https://github.com/coda/packs-starter\n[github_codespace_template]: https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace-from-a-template#publishing-to-a-repository-on-github\n\n[]\n\nnav: With Gitpod\ndescription: Build your first Pack using Gitpod and the CLI.\nicon: simple/gitpod\n\n[]"
  },
  "Get started with Gitpod": {
    "Before you get started": "You will need a Gitpod account in order to create a Pack using it. If you don't already have one you can [sign up][gitpod_signup] for free on their website.\n\n--8<-- \"tutorials/get-started/.cli-before.md\"",
    "Create a workspace": "A project in Gitpod is called a workspace, and to start you'll need to create one. Click the button below to create a new workspace from the [Packs starter project][github_packs_starter] template.\n\n[Create workspace][gitpod_from_github]{ .md-button .md-button--primary target=\"_blank\" }\n\nIt may take a few minutes for the workspace to fully initialize. When it's complete you will see a `pack.ts` file in your workspace, and you should take a moment to read through it.",
    "Test the Pack": "--8<-- \"tutorials/get-started/.cli-test.md\"\n\n--8<-- \"tutorials/get-started/.cli.md\"\n\n[gitpod_home]: https://www.gitpod.io/\n[gitpod_signup]: https://gitpod.io/workspaces/\n[gitpod_from_github]: https://gitpod.io/#https://github.com/coda/packs-starter\n[github_packs_starter]: https://github.com/coda/packs-starter\n\n[]\n\nnav: With Replit\ndescription: Build your first Pack using Replit and the CLI.\nicon: simple/replit\ncSpell:words: Replit repl\n\n[]"
  },
  "Get started with Replit": {
    "Before you get started": "You will need a Replit account in order to create a Pack using it. If you don't already have one you can [sign up][replit_signup] for free on their website.\n\n--8<-- \"tutorials/get-started/.cli-before.md\"",
    "Create a repl": "A project in Replit is called a \"repl\", and to start you'll need to create one. Click the button below to create a new repl from the [Packs starter project][github_packs_starter] template.\n\n[Create repl][replit_from_github]{ .md-button .md-button--primary target=\"_blank\" }\n\nIt may take a few minutes for the repl to fully initialize. When it's complete you will see a `pack.ts` file in your repl, and you should take a moment to read through it.",
    "Test the Pack": "To finish the setup and test the Pack, click the **Run** button in the Replit UI. This will install the Node dependencies and run following command in the console:\n\n```\nnpx coda execute pack.ts Hello \"World\"\n```\n\nIf everything works correctly this should output `Hello World!`.\n\n--8<-- \"tutorials/get-started/.cli.md\"\n\n[replit_home]: https://replit.com/\n[replit_signup]: https://replit.com/signup\n[replit_from_github]: https://replit.com/new/github/coda/packs-starter\n[github_packs_starter]: https://github.com/coda/packs-starter\n\n[]\n\nnav: In the browser\ndescription: Build your first Pack in minutes using the Pack Studio web editor.\nicon: octicons/browser-16\n\n[]"
  },
  "Get started in the browser": {
    "Navigate to the Pack Studio": "The Pack Studio is built right in to the Coda application. To get there:\n\n['Open [Coda][coda_home] in your browser.', 'Click on **Packs** in the navigation menu on the left. If you are a member of multiple workspaces you will need to select a workspace first.', 'Click the **Create a Pack** button in the upper right.']\n\n!!! tip\nType **[pack.new](https://pack.new)** into your browser to quickly create a new Pack.\n\nYou are now in the Pack Studio, ready to start building!\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of navigating to the Pack Studio.\" class=\"screenshot\"><source src=\"../../../images/web_ide_navigate.mp4\" type=\"video/mp4\"></source></video>",
    "Create a Pack from an example": "When starting a new Pack you have the choice to begin with an existing example or or start from scratch. In this tutorial we'll use the basic [Hello World][samples_hello_world] sample code. Take a moment to read through the code and comments and get an understanding of how a Pack is structured.\n\nNext we'll use the Pack Studio to build that code and get it ready to use:\n\n['Click on the **Hello World** example to add in the sample code.', 'Click on the Pack name **Untitled Pack** in the upper left, and change it to \"Hello World\".', 'Click the **Build** button in the bottom left.', 'This checks your Pack for errors and Packages it up for use in a Coda doc. It can take a few seconds for the build to complete.', 'When the confirmation screen appears, click **Create a test doc**.']\n\nYour Pack is now built and ready to use!\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of building the Pack.\" class=\"screenshot\"><source src=\"../../../images/web_ide_build.mp4\" type=\"video/mp4\"></source></video>",
    "Use the Pack": "The Pack can now be installed in any of your docs, and the test doc you created comes with the Pack pre-installed. Now let's use your new Pack in the document.\n\n--8<-- \"tutorials/get-started/.use.md\"",
    "Update the Pack": "Now that you have your Pack up and running let's make a change to how it works.\n\n['Back in the Pack Studio, update your code to say \"Howdy\" instead of \"Hello\":', '```\\nexecute: async function ([name]) {\\n    return \"Howdy \" + name + \"!\";\\n},\\n```', 'Click the **Build** button again to rebuild your Pack with this change.', 'When the Build has completed, switch back to your test document.', \"You'll notice that the formula is still returning `Hello World!`, and that's because formulas aren't automatically recalculated when you update your Pack code.\"]\n\n--8<-- \"tutorials/get-started/.rebuild.md\"\n\n<video style=\"width:auto\" loop muted autoplay alt=\"Recording of adding a dynamic sync table.\" class=\"screenshot\"><source src=\"../../../images/web_ide_rebuild.mp4\" type=\"video/mp4\"></source></video>",
    "Next steps": "You've built your fist Pack, congrats!  Now that you have some experience with the mechanics of building and using Packs, here are some recommended next steps:\n\n['Learn about Pack basics by reading through the [available guides][guides].', 'Check out the [code samples][samples] to see examples of specific Pack features as well as complete sample Packs.']\n\n[coda_sign_up]: https://coda.io/signup\n[hc_doc_maker]: https://help.coda.io/en/articles/3388781-members-and-roles\n[coda_home]: https://coda.io/docs\n[samples_hello_world]: ../../samples/full/hello-world.md\n[samples]: ../../samples/topic/formula.md\n[guides]: ../../guides/blocks/formulas.md\n\n[]\n\nnav: Tutorials\ndescription: An index of guided lessons to help you learn various aspects of the SDK.\nhide:\n\n['toc']\n\n[]"
  },
  "Tutorials": {
    "{{section.title}}": {
      "{% if child.meta.icon %}:{{child.meta.icon|replace(\"/\", \"-\")}}:{% endif %} {{ child.meta.get(\"nav\", child.title) }}": "{% if child.meta.description %}{{child.meta.description}}{% endif %}\n\n[View]({{getRelativePath(child,page)}}){ .md-button }\n\n{% elif child.is_link %}",
      "{{ child.title }}": "[View]({{fix_url(child.url)}}){ .md-button }\n\n{% endif %}\n\n</div>\n\n{% endfor %}\n\n</section>\n\n{% endfor %}"
    },
    "Videos": "Sometimes a video is worth a thousand tutorials. Check out recordings from some of our recent webinars as well as other videos on Pack building.\n\n[Watch][videos]{ .md-button }\n\n[videos]: videos.md\n\n[]\n\nnav: Videos\ndescription: A collection of videos showing how to build Packs or use the SDK.\n\n[]"
  },
  "Videos": {
    "An introduction to Packs in Coda": "_June 2022_\n\nA basic overview of Packs and how they can be used to enrich your docs.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/OGfudEBEW1U\" title=\"YouTube video player: An introduction to Packs in Coda\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
    "Build a Todoist Coda Pack from Scratch": "_June 2022_\n\nLearn how to build a Pack from scratch that retrieves your task list from Todoist. It was built in under 10 minutes and with less than 30 lines of code in Coda's browser-based Pack Studio.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/OoR1qX9w4Js\" title=\"YouTube video player: Build a Todoist Coda Pack from Scratch\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
    "Building Packs with the CLI": "_August 2022_\n\nAn introduction to the Pack Command Line Tool (CLI), including what it has to offer, how to set it up and use it, and how to leverage it to create better Packs.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7K142m0aqBc\" title=\"YouTube video player: Building Packs with the CLI\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
    "Your team hub needs more photos of dogs": "_March 2023_\n\nLearn how to develop a simple Pack to bring random dog photos into your docs. In real-time, he shows you everything you need to develop your first Coda Pack.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/z8J6kBxAod4\" title=\"YouTube video player: Your team hub needs more photos of dogs\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
    "Adding two-way sync to your Packs": "_November 2023_\n\nCoda 4.0 included a new featured called two-way sync, that allows users to directly edit data in sync tables and push the changes back to the source. In this webinar Developer Advocate Eric Koleda will show you how use new parts of the Packs SDK to add two-way sync to your own Packs.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/jfFdBNfUta8\" title=\"YouTube video player: Adding two-way sync to your Packs\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n[webinars]: https://coda.io/webinars"
  }
}
